import{r as m,R as bt}from"./index-CBYaBgW8.js";import{s as qt}from"./index-lnksFm0-.js";import{c as Gt,H as ue,C as le,U as fe,B as V,I as de,G as pe,O as he,d as ge,M as we,e as Ee,f as Re,D as me,g as ve}from"./api-DEOfkrPC.js";const Jt=0,Yt=1,Xt=2,Ht=3;var kt=Object.prototype.hasOwnProperty;function Ot(t,e){var n,s;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((s=t.length)===e.length)for(;s--&&Ot(t[s],e[s]););return s===-1}if(!n||typeof t=="object"){s=0;for(n in t)if(kt.call(t,n)&&++s&&!kt.call(e,n)||!(n in e)||!Ot(t[n],e[n]))return!1;return Object.keys(e).length===s}}return t!==t&&e!==e}const q=new WeakMap,H=()=>{},S=H(),St=Object,i=t=>t===S,M=t=>typeof t=="function",k=(t,e)=>({...t,...e}),Qt=t=>M(t.then),gt={},lt={},It="undefined",ot=typeof window!=It,At=typeof document!=It,Oe=ot&&"Deno"in window,Se=()=>ot&&typeof window.requestAnimationFrame!=It,Zt=(t,e)=>{const n=q.get(t);return[()=>!i(e)&&t.get(e)||gt,s=>{if(!i(e)){const c=t.get(e);e in lt||(lt[e]=c),n[5](e,k(c,s),c||gt)}},n[6],()=>!i(e)&&e in lt?lt[e]:!i(e)&&t.get(e)||gt]};let Ct=!0;const Ae=()=>Ct,[Dt,Tt]=ot&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[H,H],Ce=()=>{const t=At&&document.visibilityState;return i(t)||t!=="hidden"},De=t=>(At&&document.addEventListener("visibilitychange",t),Dt("focus",t),()=>{At&&document.removeEventListener("visibilitychange",t),Tt("focus",t)}),Te=t=>{const e=()=>{Ct=!0,t()},n=()=>{Ct=!1};return Dt("online",e),Dt("offline",n),()=>{Tt("online",e),Tt("offline",n)}},ye={isOnline:Ae,isVisible:Ce},_e={initFocus:De,initReconnect:Te},$t=!bt.useId,et=!ot||Oe,be=t=>Se()?window.requestAnimationFrame(t):setTimeout(t,1),wt=et?m.useEffect:m.useLayoutEffect,Et=typeof navigator<"u"&&navigator.connection,Bt=!et&&Et&&(["slow-2g","2g"].includes(Et.effectiveType)||Et.saveData),ft=new WeakMap,Ie=t=>St.prototype.toString.call(t),Rt=(t,e)=>t===`[object ${e}]`;let Le=0;const yt=t=>{const e=typeof t,n=Ie(t),s=Rt(n,"Date"),c=Rt(n,"RegExp"),a=Rt(n,"Object");let r,u;if(St(t)===t&&!s&&!c){if(r=ft.get(t),r)return r;if(r=++Le+"~",ft.set(t,r),Array.isArray(t)){for(r="@",u=0;u<t.length;u++)r+=yt(t[u])+",";ft.set(t,r)}if(a){r="#";const p=St.keys(t).sort();for(;!i(u=p.pop());)i(t[u])||(r+=u+":"+yt(t[u])+",");ft.set(t,r)}}else r=s?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return r},Lt=t=>{if(M(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?yt(t):"",[t,e]};let Ve=0;const _t=()=>++Ve;async function te(...t){const[e,n,s,c]=t,a=k({populateCache:!0,throwOnError:!0},typeof c=="boolean"?{revalidate:c}:c||{});let r=a.populateCache;const u=a.rollbackOnError;let p=a.optimisticData;const _=A=>typeof u=="function"?u(A):u!==!1,v=a.throwOnError;if(M(n)){const A=n,O=[],T=e.keys();for(const b of T)!/^\$(inf|sub)\$/.test(b)&&A(e.get(b)._k)&&O.push(b);return Promise.all(O.map(w))}return w(n);async function w(A){const[O]=Lt(A);if(!O)return;const[T,b]=Zt(e,O),[N,nt,o,it]=q.get(e),z=()=>{const I=N[O];return(M(a.revalidate)?a.revalidate(T().data,A):a.revalidate!==!1)&&(delete o[O],delete it[O],I&&I[0])?I[0](Xt).then(()=>T().data):T().data};if(t.length<3)return z();let E=s,j,x=!1;const G=_t();nt[O]=[G,0];const f=!i(p),J=T(),F=J.data,Y=J._c,$=i(Y)?F:Y;if(f&&(p=M(p)?p($,F):p,b({data:p,_c:$})),M(E))try{E=E($)}catch(I){j=I,x=!0}if(E&&Qt(E))if(E=await E.catch(I=>{j=I,x=!0}),G!==nt[O][0]){if(x)throw j;return E}else x&&f&&_(j)&&(r=!0,b({data:$,_c:S}));if(r&&!x)if(M(r)){const I=r(E,$);b({data:I,error:S,_c:S})}else b({data:E,error:S,_c:S});if(nt[O][1]=_t(),Promise.resolve(z()).then(()=>{b({_c:S})}),x){if(v)throw j;return}return E}}const Kt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},Pe=(t,e)=>{if(!q.has(t)){const n=k(_e,e),s=Object.create(null),c=te.bind(S,t);let a=H;const r=Object.create(null),u=(v,w)=>{const A=r[v]||[];return r[v]=A,A.push(w),()=>A.splice(A.indexOf(w),1)},p=(v,w,A)=>{t.set(v,w);const O=r[v];if(O)for(const T of O)T(w,A)},_=()=>{if(!q.has(t)&&(q.set(t,[s,Object.create(null),Object.create(null),Object.create(null),c,p,u]),!et)){const v=n.initFocus(setTimeout.bind(S,Kt.bind(S,s,Jt))),w=n.initReconnect(setTimeout.bind(S,Kt.bind(S,s,Yt)));a=()=>{v&&v(),w&&w(),q.delete(t)}}};return _(),[t,c,_,a]}return[t,q.get(t)[4]]},Ne=(t,e,n,s,c)=>{const a=n.errorRetryCount,r=c.retryCount,u=~~((Math.random()+.5)*(1<<(r<8?r:8)))*n.errorRetryInterval;!i(a)&&r>a||setTimeout(s,u,c)},je=Ot,[ee,xe]=Pe(new Map),Fe=k({onLoadingSlow:H,onSuccess:H,onError:H,onErrorRetry:Ne,onDiscarded:H,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Bt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Bt?5e3:3e3,compare:je,isPaused:()=>!1,cache:ee,mutate:xe,fallback:{}},ye),Me=(t,e)=>{const n=k(t,e);if(e){const{use:s,fallback:c}=t,{use:a,fallback:r}=e;s&&a&&(n.use=s.concat(a)),c&&r&&(n.fallback=k(c,r))}return n},We=m.createContext({}),Ue="$inf$",ne=ot&&window.__SWR_DEVTOOLS_USE__,qe=ne?window.__SWR_DEVTOOLS_USE__:[],He=()=>{ne&&(window.__SWR_DEVTOOLS_REACT__=bt)},se=t=>M(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],ke=()=>{const t=m.useContext(We);return m.useMemo(()=>k(Fe,t),[t])},$e=t=>(e,n,s)=>t(e,n&&((...a)=>{const[r]=Lt(e),[,,,u]=q.get(ee);if(r.startsWith(Ue))return n(...a);const p=u[r];return i(p)?n(...a):(delete u[r],p)}),s),Be=qe.concat($e),Ke=t=>function(...n){const s=ke(),[c,a,r]=se(n),u=Me(s,r);let p=t;const{use:_}=u,v=(_||[]).concat(Be);for(let w=v.length;w--;)p=v[w](p);return p(c,a||u.fetcher||null,u)},ze=(t,e,n)=>{const s=e[t]||(e[t]=[]);return s.push(n),()=>{const c=s.indexOf(n);c>=0&&(s[c]=s[s.length-1],s.pop())}},tn=(t,e)=>(...n)=>{const[s,c,a]=se(n),r=(a.use||[]).concat(e);return t(s,c,{...a,use:r})};He();const mt=bt.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),vt={dedupe:!0},zt=Promise.resolve(S),Ge=(t,e,n)=>{const{cache:s,compare:c,suspense:a,fallbackData:r,revalidateOnMount:u,revalidateIfStale:p,refreshInterval:_,refreshWhenHidden:v,refreshWhenOffline:w,keepPreviousData:A,strictServerPrefetchWarning:O}=n,[T,b,N,nt]=q.get(s),[o,it]=Lt(t),z=m.useRef(!1),E=m.useRef(!1),j=m.useRef(o),x=m.useRef(e),G=m.useRef(n),f=()=>G.current,J=()=>f().isVisible()&&f().isOnline(),[F,Y,$,I]=Zt(s,o),X=m.useRef({}).current,at=i(r)?i(n.fallback)?S:n.fallback[o]:r,Vt=(l,d)=>{for(const g in X){const h=g;if(h==="data"){if(!c(l[h],d[h])&&(!i(l[h])||!c(ut,d[h])))return!1}else if(d[h]!==l[h])return!1}return!0},Pt=m.useMemo(()=>{const l=!o||!e?!1:i(u)?f().isPaused()||a?!1:p!==!1:u,d=C=>{const W=k(C);return delete W._k,l?{isValidating:!0,isLoading:!0,...W}:W},g=F(),h=I(),L=d(g),tt=g===h?L:d(h);let R=L;return[()=>{const C=d(F());return Vt(C,R)?(R.data=C.data,R.isLoading=C.isLoading,R.isValidating=C.isValidating,R.error=C.error,R):(R=C,C)},()=>tt]},[s,o]),Q=qt.useSyncExternalStore(m.useCallback(l=>$(o,(d,g)=>{Vt(g,d)||l()}),[s,o]),Pt[0],Pt[1]),Nt=!z.current,re=T[o]&&T[o].length>0,Z=Q.data,B=i(Z)?at&&Qt(at)?mt(at):at:Z,ct=Q.error,dt=m.useRef(B),ut=A?i(Z)?i(dt.current)?B:dt.current:Z:B,K=o&&i(B),oe=!et&&qt.useSyncExternalStore(()=>H,()=>!1,()=>!0);O&&oe&&!a&&K&&console.warn(`Missing pre-initiated data for serialized key "${o}" during server-side rendering. Data fethcing should be initiated on the server and provided to SWR via fallback data. You can set "strictServerPrefetchWarning: false" to disable this warning.`);const jt=re&&!i(ct)?!1:Nt&&!i(u)?u:f().isPaused()?!1:a?i(B)?!1:p:i(B)||p,xt=!!(o&&e&&Nt&&jt),ie=i(Q.isValidating)?xt:Q.isValidating,ae=i(Q.isLoading)?xt:Q.isLoading,st=m.useCallback(async l=>{const d=x.current;if(!o||!d||E.current||f().isPaused())return!1;let g,h,L=!0;const tt=l||{},R=!N[o]||!tt.dedupe,C=()=>$t?!E.current&&o===j.current&&z.current:o===j.current,W={isValidating:!1,isLoading:!1},Mt=()=>{Y(W)},Wt=()=>{const y=N[o];y&&y[1]===h&&delete N[o]},Ut={isValidating:!0};i(F().data)&&(Ut.isLoading=!0);try{if(R&&(Y(Ut),n.loadingTimeout&&i(F().data)&&setTimeout(()=>{L&&C()&&f().onLoadingSlow(o,n)},n.loadingTimeout),N[o]=[d(it),_t()]),[g,h]=N[o],g=await g,R&&setTimeout(Wt,n.dedupingInterval),!N[o]||N[o][1]!==h)return R&&C()&&f().onDiscarded(o),!1;W.error=S;const y=b[o];if(!i(y)&&(h<=y[0]||h<=y[1]||y[1]===0))return Mt(),R&&C()&&f().onDiscarded(o),!1;const U=F().data;W.data=c(U,g)?U:g,R&&C()&&f().onSuccess(g,o,n)}catch(y){Wt();const U=f(),{shouldRetryOnError:pt}=U;U.isPaused()||(W.error=y,R&&C()&&(U.onError(y,o,U),(pt===!0||M(pt)&&pt(y))&&(!f().revalidateOnFocus||!f().revalidateOnReconnect||J())&&U.onErrorRetry(y,o,U,ce=>{const ht=T[o];ht&&ht[0]&&ht[0](Ht,ce)},{retryCount:(tt.retryCount||0)+1,dedupe:!0})))}return L=!1,Mt(),!0},[o,s]),Ft=m.useCallback((...l)=>te(s,j.current,...l),[]);if(wt(()=>{x.current=e,G.current=n,i(Z)||(dt.current=Z)}),wt(()=>{if(!o)return;const l=st.bind(S,vt);let d=0;f().revalidateOnFocus&&(d=Date.now()+f().focusThrottleInterval);const h=ze(o,T,(L,tt={})=>{if(L==Jt){const R=Date.now();f().revalidateOnFocus&&R>d&&J()&&(d=R+f().focusThrottleInterval,l())}else if(L==Yt)f().revalidateOnReconnect&&J()&&l();else{if(L==Xt)return st();if(L==Ht)return st(tt)}});return E.current=!1,j.current=o,z.current=!0,Y({_k:it}),jt&&(N[o]||(i(B)||et?l():be(l))),()=>{E.current=!0,h()}},[o]),wt(()=>{let l;function d(){const h=M(_)?_(F().data):_;h&&l!==-1&&(l=setTimeout(g,h))}function g(){!F().error&&(v||f().isVisible())&&(w||f().isOnline())?st(vt).then(d):d()}return d(),()=>{l&&(clearTimeout(l),l=-1)}},[_,v,w,o]),m.useDebugValue(ut),a){if(!$t&&et&&K)throw new Error("Fallback data is required when using Suspense in SSR.");K&&(x.current=e,G.current=n,E.current=!1);const l=nt[o],d=!i(l)&&K?Ft(l):zt;if(mt(d),!i(ct)&&K)throw ct;const g=K?st(vt):zt;!i(ut)&&K&&(g.status="fulfilled",g.value=!0),mt(g)}return{mutate:Ft,get data(){return X.data=!0,ut},get error(){return X.error=!0,ct},get isValidating(){return X.isValidating=!0,ie},get isLoading(){return X.isLoading=!0,ae}}},en=Ke(Ge);class Je{constructor(e={}){var n;this.apiKey=e.apiKey,this.username=e.username,this.password=e.password,this.accessToken=e.accessToken,this.basePath=e.basePath,this.serverIndex=e.serverIndex,this.baseOptions={...e.baseOptions,headers:{...(n=e.baseOptions)==null?void 0:n.headers}},this.formDataCtor=e.formDataCtor}isJsonMime(e){const n=new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$","i");return e!==null&&(n.test(e)||e.toLowerCase()==="application/json-patch+json")}}const D=Gt.create({baseURL:"/api",headers:{"Content-Type":"application/json"}});let rt=null;D.interceptors.response.use(t=>t,async t=>{const e=t.config;if(rt)return await rt,D(e);if(t.response.status===ue.Unauthorized&&!e._retry){e._retry=!0;try{return rt=Gt.post("/auth/refresh-token").finally(()=>{rt=null}),await rt,D(e)}catch(n){return window.location.href="/auth/logout",Promise.reject(n)}}return Promise.reject(t)});const P=new Je({basePath:"/api"});new Re(P,V,D);const nn=new he(P,V,D),sn=new ge(P,V,D),rn=new fe(P,V,D),on=new we(P,V,D),an=new le(P,V,D);new me(P,V,D);new ve(P,V,D);const cn=new Ee(P,V,D),un=new de(P,V,D),ln=new pe(P,V,D);export{$t as I,S as U,ke as a,wt as b,an as c,rn as d,ln as e,on as f,_t as g,un as h,sn as i,cn as j,k as m,nn as o,Lt as s,en as u,tn as w};

import{r as m,R as bt}from"./index-CBYaBgW8.js";import{s as Ut}from"./index-lnksFm0-.js";import{c as Gt,H as ue,C as le,B as F,I as fe,G as de,O as pe,d as he,M as ge,e as we,f as Ee,D as Re,g as me}from"./api-DmowGS_I.js";const Jt=0,Yt=1,Xt=2,Ht=3;var kt=Object.prototype.hasOwnProperty;function Ot(t,e){var n,s;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((s=t.length)===e.length)for(;s--&&Ot(t[s],e[s]););return s===-1}if(!n||typeof t=="object"){s=0;for(n in t)if(kt.call(t,n)&&++s&&!kt.call(e,n)||!(n in e)||!Ot(t[n],e[n]))return!1;return Object.keys(e).length===s}}return t!==t&&e!==e}const U=new WeakMap,H=()=>{},S=H(),St=Object,i=t=>t===S,j=t=>typeof t=="function",k=(t,e)=>({...t,...e}),Qt=t=>j(t.then),gt={},lt={},It="undefined",ot=typeof window!=It,Ct=typeof document!=It,ve=ot&&"Deno"in window,Oe=()=>ot&&typeof window.requestAnimationFrame!=It,Zt=(t,e)=>{const n=U.get(t);return[()=>!i(e)&&t.get(e)||gt,s=>{if(!i(e)){const c=t.get(e);e in lt||(lt[e]=c),n[5](e,k(c,s),c||gt)}},n[6],()=>!i(e)&&e in lt?lt[e]:!i(e)&&t.get(e)||gt]};let Dt=!0;const Se=()=>Dt,[Tt,At]=ot&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[H,H],Ce=()=>{const t=Ct&&document.visibilityState;return i(t)||t!=="hidden"},De=t=>(Ct&&document.addEventListener("visibilitychange",t),Tt("focus",t),()=>{Ct&&document.removeEventListener("visibilitychange",t),At("focus",t)}),Te=t=>{const e=()=>{Dt=!0,t()},n=()=>{Dt=!1};return Tt("online",e),Tt("offline",n),()=>{At("online",e),At("offline",n)}},Ae={isOnline:Se,isVisible:Ce},ye={initFocus:De,initReconnect:Te},$t=!bt.useId,et=!ot||ve,_e=t=>Oe()?window.requestAnimationFrame(t):setTimeout(t,1),wt=et?m.useEffect:m.useLayoutEffect,Et=typeof navigator<"u"&&navigator.connection,Bt=!et&&Et&&(["slow-2g","2g"].includes(Et.effectiveType)||Et.saveData),ft=new WeakMap,be=t=>St.prototype.toString.call(t),Rt=(t,e)=>t===`[object ${e}]`;let Ie=0;const yt=t=>{const e=typeof t,n=be(t),s=Rt(n,"Date"),c=Rt(n,"RegExp"),a=Rt(n,"Object");let r,u;if(St(t)===t&&!s&&!c){if(r=ft.get(t),r)return r;if(r=++Ie+"~",ft.set(t,r),Array.isArray(t)){for(r="@",u=0;u<t.length;u++)r+=yt(t[u])+",";ft.set(t,r)}if(a){r="#";const p=St.keys(t).sort();for(;!i(u=p.pop());)i(t[u])||(r+=u+":"+yt(t[u])+",");ft.set(t,r)}}else r=s?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return r},Lt=t=>{if(j(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?yt(t):"",[t,e]};let Le=0;const _t=()=>++Le;async function te(...t){const[e,n,s,c]=t,a=k({populateCache:!0,throwOnError:!0},typeof c=="boolean"?{revalidate:c}:c||{});let r=a.populateCache;const u=a.rollbackOnError;let p=a.optimisticData;const _=C=>typeof u=="function"?u(C):u!==!1,v=a.throwOnError;if(j(n)){const C=n,O=[],T=e.keys();for(const b of T)!/^\$(inf|sub)\$/.test(b)&&C(e.get(b)._k)&&O.push(b);return Promise.all(O.map(w))}return w(n);async function w(C){const[O]=Lt(C);if(!O)return;const[T,b]=Zt(e,O),[V,nt,o,it]=U.get(e),z=()=>{const I=V[O];return(j(a.revalidate)?a.revalidate(T().data,C):a.revalidate!==!1)&&(delete o[O],delete it[O],I&&I[0])?I[0](Xt).then(()=>T().data):T().data};if(t.length<3)return z();let E=s,N,P=!1;const G=_t();nt[O]=[G,0];const f=!i(p),J=T(),x=J.data,Y=J._c,$=i(Y)?x:Y;if(f&&(p=j(p)?p($,x):p,b({data:p,_c:$})),j(E))try{E=E($)}catch(I){N=I,P=!0}if(E&&Qt(E))if(E=await E.catch(I=>{N=I,P=!0}),G!==nt[O][0]){if(P)throw N;return E}else P&&f&&_(N)&&(r=!0,b({data:$,_c:S}));if(r&&!P)if(j(r)){const I=r(E,$);b({data:I,error:S,_c:S})}else b({data:E,error:S,_c:S});if(nt[O][1]=_t(),Promise.resolve(z()).then(()=>{b({_c:S})}),P){if(v)throw N;return}return E}}const Kt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},Ve=(t,e)=>{if(!U.has(t)){const n=k(ye,e),s=Object.create(null),c=te.bind(S,t);let a=H;const r=Object.create(null),u=(v,w)=>{const C=r[v]||[];return r[v]=C,C.push(w),()=>C.splice(C.indexOf(w),1)},p=(v,w,C)=>{t.set(v,w);const O=r[v];if(O)for(const T of O)T(w,C)},_=()=>{if(!U.has(t)&&(U.set(t,[s,Object.create(null),Object.create(null),Object.create(null),c,p,u]),!et)){const v=n.initFocus(setTimeout.bind(S,Kt.bind(S,s,Jt))),w=n.initReconnect(setTimeout.bind(S,Kt.bind(S,s,Yt)));a=()=>{v&&v(),w&&w(),U.delete(t)}}};return _(),[t,c,_,a]}return[t,U.get(t)[4]]},Ne=(t,e,n,s,c)=>{const a=n.errorRetryCount,r=c.retryCount,u=~~((Math.random()+.5)*(1<<(r<8?r:8)))*n.errorRetryInterval;!i(a)&&r>a||setTimeout(s,u,c)},Pe=Ot,[ee,xe]=Ve(new Map),je=k({onLoadingSlow:H,onSuccess:H,onError:H,onErrorRetry:Ne,onDiscarded:H,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Bt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Bt?5e3:3e3,compare:Pe,isPaused:()=>!1,cache:ee,mutate:xe,fallback:{}},Ae),Fe=(t,e)=>{const n=k(t,e);if(e){const{use:s,fallback:c}=t,{use:a,fallback:r}=e;s&&a&&(n.use=s.concat(a)),c&&r&&(n.fallback=k(c,r))}return n},Me=m.createContext({}),We="$inf$",ne=ot&&window.__SWR_DEVTOOLS_USE__,qe=ne?window.__SWR_DEVTOOLS_USE__:[],Ue=()=>{ne&&(window.__SWR_DEVTOOLS_REACT__=bt)},se=t=>j(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],He=()=>{const t=m.useContext(Me);return m.useMemo(()=>k(je,t),[t])},ke=t=>(e,n,s)=>t(e,n&&((...a)=>{const[r]=Lt(e),[,,,u]=U.get(ee);if(r.startsWith(We))return n(...a);const p=u[r];return i(p)?n(...a):(delete u[r],p)}),s),$e=qe.concat(ke),Be=t=>function(...n){const s=He(),[c,a,r]=se(n),u=Fe(s,r);let p=t;const{use:_}=u,v=(_||[]).concat($e);for(let w=v.length;w--;)p=v[w](p);return p(c,a||u.fetcher||null,u)},Ke=(t,e,n)=>{const s=e[t]||(e[t]=[]);return s.push(n),()=>{const c=s.indexOf(n);c>=0&&(s[c]=s[s.length-1],s.pop())}},Ze=(t,e)=>(...n)=>{const[s,c,a]=se(n),r=(a.use||[]).concat(e);return t(s,c,{...a,use:r})};Ue();const mt=bt.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),vt={dedupe:!0},zt=Promise.resolve(S),ze=(t,e,n)=>{const{cache:s,compare:c,suspense:a,fallbackData:r,revalidateOnMount:u,revalidateIfStale:p,refreshInterval:_,refreshWhenHidden:v,refreshWhenOffline:w,keepPreviousData:C,strictServerPrefetchWarning:O}=n,[T,b,V,nt]=U.get(s),[o,it]=Lt(t),z=m.useRef(!1),E=m.useRef(!1),N=m.useRef(o),P=m.useRef(e),G=m.useRef(n),f=()=>G.current,J=()=>f().isVisible()&&f().isOnline(),[x,Y,$,I]=Zt(s,o),X=m.useRef({}).current,at=i(r)?i(n.fallback)?S:n.fallback[o]:r,Vt=(l,d)=>{for(const g in X){const h=g;if(h==="data"){if(!c(l[h],d[h])&&(!i(l[h])||!c(ut,d[h])))return!1}else if(d[h]!==l[h])return!1}return!0},Nt=m.useMemo(()=>{const l=!o||!e?!1:i(u)?f().isPaused()||a?!1:p!==!1:u,d=D=>{const W=k(D);return delete W._k,l?{isValidating:!0,isLoading:!0,...W}:W},g=x(),h=I(),L=d(g),tt=g===h?L:d(h);let R=L;return[()=>{const D=d(x());return Vt(D,R)?(R.data=D.data,R.isLoading=D.isLoading,R.isValidating=D.isValidating,R.error=D.error,R):(R=D,D)},()=>tt]},[s,o]),Q=Ut.useSyncExternalStore(m.useCallback(l=>$(o,(d,g)=>{Vt(g,d)||l()}),[s,o]),Nt[0],Nt[1]),Pt=!z.current,re=T[o]&&T[o].length>0,Z=Q.data,B=i(Z)?at&&Qt(at)?mt(at):at:Z,ct=Q.error,dt=m.useRef(B),ut=C?i(Z)?i(dt.current)?B:dt.current:Z:B,K=o&&i(B),oe=!et&&Ut.useSyncExternalStore(()=>H,()=>!1,()=>!0);O&&oe&&!a&&K&&console.warn(`Missing pre-initiated data for serialized key "${o}" during server-side rendering. Data fethcing should be initiated on the server and provided to SWR via fallback data. You can set "strictServerPrefetchWarning: false" to disable this warning.`);const xt=re&&!i(ct)?!1:Pt&&!i(u)?u:f().isPaused()?!1:a?i(B)?!1:p:i(B)||p,jt=!!(o&&e&&Pt&&xt),ie=i(Q.isValidating)?jt:Q.isValidating,ae=i(Q.isLoading)?jt:Q.isLoading,st=m.useCallback(async l=>{const d=P.current;if(!o||!d||E.current||f().isPaused())return!1;let g,h,L=!0;const tt=l||{},R=!V[o]||!tt.dedupe,D=()=>$t?!E.current&&o===N.current&&z.current:o===N.current,W={isValidating:!1,isLoading:!1},Mt=()=>{Y(W)},Wt=()=>{const y=V[o];y&&y[1]===h&&delete V[o]},qt={isValidating:!0};i(x().data)&&(qt.isLoading=!0);try{if(R&&(Y(qt),n.loadingTimeout&&i(x().data)&&setTimeout(()=>{L&&D()&&f().onLoadingSlow(o,n)},n.loadingTimeout),V[o]=[d(it),_t()]),[g,h]=V[o],g=await g,R&&setTimeout(Wt,n.dedupingInterval),!V[o]||V[o][1]!==h)return R&&D()&&f().onDiscarded(o),!1;W.error=S;const y=b[o];if(!i(y)&&(h<=y[0]||h<=y[1]||y[1]===0))return Mt(),R&&D()&&f().onDiscarded(o),!1;const q=x().data;W.data=c(q,g)?q:g,R&&D()&&f().onSuccess(g,o,n)}catch(y){Wt();const q=f(),{shouldRetryOnError:pt}=q;q.isPaused()||(W.error=y,R&&D()&&(q.onError(y,o,q),(pt===!0||j(pt)&&pt(y))&&(!f().revalidateOnFocus||!f().revalidateOnReconnect||J())&&q.onErrorRetry(y,o,q,ce=>{const ht=T[o];ht&&ht[0]&&ht[0](Ht,ce)},{retryCount:(tt.retryCount||0)+1,dedupe:!0})))}return L=!1,Mt(),!0},[o,s]),Ft=m.useCallback((...l)=>te(s,N.current,...l),[]);if(wt(()=>{P.current=e,G.current=n,i(Z)||(dt.current=Z)}),wt(()=>{if(!o)return;const l=st.bind(S,vt);let d=0;f().revalidateOnFocus&&(d=Date.now()+f().focusThrottleInterval);const h=Ke(o,T,(L,tt={})=>{if(L==Jt){const R=Date.now();f().revalidateOnFocus&&R>d&&J()&&(d=R+f().focusThrottleInterval,l())}else if(L==Yt)f().revalidateOnReconnect&&J()&&l();else{if(L==Xt)return st();if(L==Ht)return st(tt)}});return E.current=!1,N.current=o,z.current=!0,Y({_k:it}),xt&&(V[o]||(i(B)||et?l():_e(l))),()=>{E.current=!0,h()}},[o]),wt(()=>{let l;function d(){const h=j(_)?_(x().data):_;h&&l!==-1&&(l=setTimeout(g,h))}function g(){!x().error&&(v||f().isVisible())&&(w||f().isOnline())?st(vt).then(d):d()}return d(),()=>{l&&(clearTimeout(l),l=-1)}},[_,v,w,o]),m.useDebugValue(ut),a){if(!$t&&et&&K)throw new Error("Fallback data is required when using Suspense in SSR.");K&&(P.current=e,G.current=n,E.current=!1);const l=nt[o],d=!i(l)&&K?Ft(l):zt;if(mt(d),!i(ct)&&K)throw ct;const g=K?st(vt):zt;!i(ut)&&K&&(g.status="fulfilled",g.value=!0),mt(g)}return{mutate:Ft,get data(){return X.data=!0,ut},get error(){return X.error=!0,ct},get isValidating(){return X.isValidating=!0,ie},get isLoading(){return X.isLoading=!0,ae}}},tn=Be(ze);class Ge{constructor(e={}){var n;this.apiKey=e.apiKey,this.username=e.username,this.password=e.password,this.accessToken=e.accessToken,this.basePath=e.basePath,this.serverIndex=e.serverIndex,this.baseOptions={...e.baseOptions,headers:{...(n=e.baseOptions)==null?void 0:n.headers}},this.formDataCtor=e.formDataCtor}isJsonMime(e){const n=new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$","i");return e!==null&&(n.test(e)||e.toLowerCase()==="application/json-patch+json")}}const A=Gt.create({baseURL:"/api",headers:{"Content-Type":"application/json"}});let rt=null;A.interceptors.response.use(t=>t,async t=>{const e=t.config;if(rt)return await rt,A(e);if(t.response.status===ue.Unauthorized&&!e._retry){e._retry=!0;try{return rt=Gt.post("/auth/refresh-token").finally(()=>{rt=null}),await rt,A(e)}catch(n){return window.location.href="/auth/logout",Promise.reject(n)}}return Promise.reject(t)});const M=new Ge({basePath:"/api"});new Ee(M,F,A);const en=new pe(M,F,A),nn=new he(M,F,A),sn=new ge(M,F,A),rn=new le(M,F,A);new Re(M,F,A);new me(M,F,A);const on=new we(M,F,A),an=new fe(M,F,A),cn=new de(M,F,A);export{$t as I,S as U,He as a,_t as b,rn as c,wt as d,on as e,nn as f,cn as g,sn as h,an as i,k as m,en as o,Lt as s,tn as u,Ze as w};

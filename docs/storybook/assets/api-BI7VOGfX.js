import{r as m,R as bt}from"./index-CBYaBgW8.js";import{s as qt}from"./index-lnksFm0-.js";import{c as Jt,H as ue,C as le,B as q,I as fe,O as de,d as pe,M as he,A as ge,e as we,D as Ee,f as Re}from"./api-DSP0ZUQ6.js";const Gt=0,Yt=1,Xt=2,Ht=3;var kt=Object.prototype.hasOwnProperty;function Ot(t,e){var n,s;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((s=t.length)===e.length)for(;s--&&Ot(t[s],e[s]););return s===-1}if(!n||typeof t=="object"){s=0;for(n in t)if(kt.call(t,n)&&++s&&!kt.call(e,n)||!(n in e)||!Ot(t[n],e[n]))return!1;return Object.keys(e).length===s}}return t!==t&&e!==e}const W=new WeakMap,U=()=>{},S=U(),St=Object,i=t=>t===S,j=t=>typeof t=="function",k=(t,e)=>({...t,...e}),Qt=t=>j(t.then),gt={},lt={},It="undefined",ot=typeof window!=It,At=typeof document!=It,me=ot&&"Deno"in window,ve=()=>ot&&typeof window.requestAnimationFrame!=It,Zt=(t,e)=>{const n=W.get(t);return[()=>!i(e)&&t.get(e)||gt,s=>{if(!i(e)){const c=t.get(e);e in lt||(lt[e]=c),n[5](e,k(c,s),c||gt)}},n[6],()=>!i(e)&&e in lt?lt[e]:!i(e)&&t.get(e)||gt]};let Ct=!0;const Oe=()=>Ct,[Dt,Tt]=ot&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[U,U],Se=()=>{const t=At&&document.visibilityState;return i(t)||t!=="hidden"},Ae=t=>(At&&document.addEventListener("visibilitychange",t),Dt("focus",t),()=>{At&&document.removeEventListener("visibilitychange",t),Tt("focus",t)}),Ce=t=>{const e=()=>{Ct=!0,t()},n=()=>{Ct=!1};return Dt("online",e),Dt("offline",n),()=>{Tt("online",e),Tt("offline",n)}},De={isOnline:Oe,isVisible:Se},Te={initFocus:Ae,initReconnect:Ce},$t=!bt.useId,et=!ot||me,ye=t=>ve()?window.requestAnimationFrame(t):setTimeout(t,1),wt=et?m.useEffect:m.useLayoutEffect,Et=typeof navigator<"u"&&navigator.connection,Bt=!et&&Et&&(["slow-2g","2g"].includes(Et.effectiveType)||Et.saveData),ft=new WeakMap,_e=t=>St.prototype.toString.call(t),Rt=(t,e)=>t===`[object ${e}]`;let be=0;const yt=t=>{const e=typeof t,n=_e(t),s=Rt(n,"Date"),c=Rt(n,"RegExp"),a=Rt(n,"Object");let r,u;if(St(t)===t&&!s&&!c){if(r=ft.get(t),r)return r;if(r=++be+"~",ft.set(t,r),Array.isArray(t)){for(r="@",u=0;u<t.length;u++)r+=yt(t[u])+",";ft.set(t,r)}if(a){r="#";const p=St.keys(t).sort();for(;!i(u=p.pop());)i(t[u])||(r+=u+":"+yt(t[u])+",");ft.set(t,r)}}else r=s?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return r},Lt=t=>{if(j(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?yt(t):"",[t,e]};let Ie=0;const _t=()=>++Ie;async function te(...t){const[e,n,s,c]=t,a=k({populateCache:!0,throwOnError:!0},typeof c=="boolean"?{revalidate:c}:c||{});let r=a.populateCache;const u=a.rollbackOnError;let p=a.optimisticData;const _=A=>typeof u=="function"?u(A):u!==!1,v=a.throwOnError;if(j(n)){const A=n,O=[],D=e.keys();for(const b of D)!/^\$(inf|sub)\$/.test(b)&&A(e.get(b)._k)&&O.push(b);return Promise.all(O.map(w))}return w(n);async function w(A){const[O]=Lt(A);if(!O)return;const[D,b]=Zt(e,O),[V,nt,o,it]=W.get(e),z=()=>{const I=V[O];return(j(a.revalidate)?a.revalidate(D().data,A):a.revalidate!==!1)&&(delete o[O],delete it[O],I&&I[0])?I[0](Xt).then(()=>D().data):D().data};if(t.length<3)return z();let E=s,P,N=!1;const J=_t();nt[O]=[J,0];const f=!i(p),G=D(),x=G.data,Y=G._c,$=i(Y)?x:Y;if(f&&(p=j(p)?p($,x):p,b({data:p,_c:$})),j(E))try{E=E($)}catch(I){P=I,N=!0}if(E&&Qt(E))if(E=await E.catch(I=>{P=I,N=!0}),J!==nt[O][0]){if(N)throw P;return E}else N&&f&&_(P)&&(r=!0,b({data:$,_c:S}));if(r&&!N)if(j(r)){const I=r(E,$);b({data:I,error:S,_c:S})}else b({data:E,error:S,_c:S});if(nt[O][1]=_t(),Promise.resolve(z()).then(()=>{b({_c:S})}),N){if(v)throw P;return}return E}}const Kt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},Le=(t,e)=>{if(!W.has(t)){const n=k(Te,e),s=Object.create(null),c=te.bind(S,t);let a=U;const r=Object.create(null),u=(v,w)=>{const A=r[v]||[];return r[v]=A,A.push(w),()=>A.splice(A.indexOf(w),1)},p=(v,w,A)=>{t.set(v,w);const O=r[v];if(O)for(const D of O)D(w,A)},_=()=>{if(!W.has(t)&&(W.set(t,[s,Object.create(null),Object.create(null),Object.create(null),c,p,u]),!et)){const v=n.initFocus(setTimeout.bind(S,Kt.bind(S,s,Gt))),w=n.initReconnect(setTimeout.bind(S,Kt.bind(S,s,Yt)));a=()=>{v&&v(),w&&w(),W.delete(t)}}};return _(),[t,c,_,a]}return[t,W.get(t)[4]]},Ve=(t,e,n,s,c)=>{const a=n.errorRetryCount,r=c.retryCount,u=~~((Math.random()+.5)*(1<<(r<8?r:8)))*n.errorRetryInterval;!i(a)&&r>a||setTimeout(s,u,c)},Pe=Ot,[ee,Ne]=Le(new Map),xe=k({onLoadingSlow:U,onSuccess:U,onError:U,onErrorRetry:Ve,onDiscarded:U,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Bt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Bt?5e3:3e3,compare:Pe,isPaused:()=>!1,cache:ee,mutate:Ne,fallback:{}},De),je=(t,e)=>{const n=k(t,e);if(e){const{use:s,fallback:c}=t,{use:a,fallback:r}=e;s&&a&&(n.use=s.concat(a)),c&&r&&(n.fallback=k(c,r))}return n},Fe=m.createContext({}),Me="$inf$",ne=ot&&window.__SWR_DEVTOOLS_USE__,We=ne?window.__SWR_DEVTOOLS_USE__:[],Ue=()=>{ne&&(window.__SWR_DEVTOOLS_REACT__=bt)},se=t=>j(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],qe=()=>{const t=m.useContext(Fe);return m.useMemo(()=>k(xe,t),[t])},He=t=>(e,n,s)=>t(e,n&&((...a)=>{const[r]=Lt(e),[,,,u]=W.get(ee);if(r.startsWith(Me))return n(...a);const p=u[r];return i(p)?n(...a):(delete u[r],p)}),s),ke=We.concat(He),$e=t=>function(...n){const s=qe(),[c,a,r]=se(n),u=je(s,r);let p=t;const{use:_}=u,v=(_||[]).concat(ke);for(let w=v.length;w--;)p=v[w](p);return p(c,a||u.fetcher||null,u)},Be=(t,e,n)=>{const s=e[t]||(e[t]=[]);return s.push(n),()=>{const c=s.indexOf(n);c>=0&&(s[c]=s[s.length-1],s.pop())}},Qe=(t,e)=>(...n)=>{const[s,c,a]=se(n),r=(a.use||[]).concat(e);return t(s,c,{...a,use:r})};Ue();const mt=bt.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),vt={dedupe:!0},zt=Promise.resolve(S),Ke=(t,e,n)=>{const{cache:s,compare:c,suspense:a,fallbackData:r,revalidateOnMount:u,revalidateIfStale:p,refreshInterval:_,refreshWhenHidden:v,refreshWhenOffline:w,keepPreviousData:A,strictServerPrefetchWarning:O}=n,[D,b,V,nt]=W.get(s),[o,it]=Lt(t),z=m.useRef(!1),E=m.useRef(!1),P=m.useRef(o),N=m.useRef(e),J=m.useRef(n),f=()=>J.current,G=()=>f().isVisible()&&f().isOnline(),[x,Y,$,I]=Zt(s,o),X=m.useRef({}).current,at=i(r)?i(n.fallback)?S:n.fallback[o]:r,Vt=(l,d)=>{for(const g in X){const h=g;if(h==="data"){if(!c(l[h],d[h])&&(!i(l[h])||!c(ut,d[h])))return!1}else if(d[h]!==l[h])return!1}return!0},Pt=m.useMemo(()=>{const l=!o||!e?!1:i(u)?f().isPaused()||a?!1:p!==!1:u,d=C=>{const F=k(C);return delete F._k,l?{isValidating:!0,isLoading:!0,...F}:F},g=x(),h=I(),L=d(g),tt=g===h?L:d(h);let R=L;return[()=>{const C=d(x());return Vt(C,R)?(R.data=C.data,R.isLoading=C.isLoading,R.isValidating=C.isValidating,R.error=C.error,R):(R=C,C)},()=>tt]},[s,o]),Q=qt.useSyncExternalStore(m.useCallback(l=>$(o,(d,g)=>{Vt(g,d)||l()}),[s,o]),Pt[0],Pt[1]),Nt=!z.current,re=D[o]&&D[o].length>0,Z=Q.data,B=i(Z)?at&&Qt(at)?mt(at):at:Z,ct=Q.error,dt=m.useRef(B),ut=A?i(Z)?i(dt.current)?B:dt.current:Z:B,K=o&&i(B),oe=!et&&qt.useSyncExternalStore(()=>U,()=>!1,()=>!0);O&&oe&&!a&&K&&console.warn(`Missing pre-initiated data for serialized key "${o}" during server-side rendering. Data fethcing should be initiated on the server and provided to SWR via fallback data. You can set "strictServerPrefetchWarning: false" to disable this warning.`);const xt=re&&!i(ct)?!1:Nt&&!i(u)?u:f().isPaused()?!1:a?i(B)?!1:p:i(B)||p,jt=!!(o&&e&&Nt&&xt),ie=i(Q.isValidating)?jt:Q.isValidating,ae=i(Q.isLoading)?jt:Q.isLoading,st=m.useCallback(async l=>{const d=N.current;if(!o||!d||E.current||f().isPaused())return!1;let g,h,L=!0;const tt=l||{},R=!V[o]||!tt.dedupe,C=()=>$t?!E.current&&o===P.current&&z.current:o===P.current,F={isValidating:!1,isLoading:!1},Mt=()=>{Y(F)},Wt=()=>{const T=V[o];T&&T[1]===h&&delete V[o]},Ut={isValidating:!0};i(x().data)&&(Ut.isLoading=!0);try{if(R&&(Y(Ut),n.loadingTimeout&&i(x().data)&&setTimeout(()=>{L&&C()&&f().onLoadingSlow(o,n)},n.loadingTimeout),V[o]=[d(it),_t()]),[g,h]=V[o],g=await g,R&&setTimeout(Wt,n.dedupingInterval),!V[o]||V[o][1]!==h)return R&&C()&&f().onDiscarded(o),!1;F.error=S;const T=b[o];if(!i(T)&&(h<=T[0]||h<=T[1]||T[1]===0))return Mt(),R&&C()&&f().onDiscarded(o),!1;const M=x().data;F.data=c(M,g)?M:g,R&&C()&&f().onSuccess(g,o,n)}catch(T){Wt();const M=f(),{shouldRetryOnError:pt}=M;M.isPaused()||(F.error=T,R&&C()&&(M.onError(T,o,M),(pt===!0||j(pt)&&pt(T))&&(!f().revalidateOnFocus||!f().revalidateOnReconnect||G())&&M.onErrorRetry(T,o,M,ce=>{const ht=D[o];ht&&ht[0]&&ht[0](Ht,ce)},{retryCount:(tt.retryCount||0)+1,dedupe:!0})))}return L=!1,Mt(),!0},[o,s]),Ft=m.useCallback((...l)=>te(s,P.current,...l),[]);if(wt(()=>{N.current=e,J.current=n,i(Z)||(dt.current=Z)}),wt(()=>{if(!o)return;const l=st.bind(S,vt);let d=0;f().revalidateOnFocus&&(d=Date.now()+f().focusThrottleInterval);const h=Be(o,D,(L,tt={})=>{if(L==Gt){const R=Date.now();f().revalidateOnFocus&&R>d&&G()&&(d=R+f().focusThrottleInterval,l())}else if(L==Yt)f().revalidateOnReconnect&&G()&&l();else{if(L==Xt)return st();if(L==Ht)return st(tt)}});return E.current=!1,P.current=o,z.current=!0,Y({_k:it}),xt&&(V[o]||(i(B)||et?l():ye(l))),()=>{E.current=!0,h()}},[o]),wt(()=>{let l;function d(){const h=j(_)?_(x().data):_;h&&l!==-1&&(l=setTimeout(g,h))}function g(){!x().error&&(v||f().isVisible())&&(w||f().isOnline())?st(vt).then(d):d()}return d(),()=>{l&&(clearTimeout(l),l=-1)}},[_,v,w,o]),m.useDebugValue(ut),a){if(!$t&&et&&K)throw new Error("Fallback data is required when using Suspense in SSR.");K&&(N.current=e,J.current=n,E.current=!1);const l=nt[o],d=!i(l)&&K?Ft(l):zt;if(mt(d),!i(ct)&&K)throw ct;const g=K?st(vt):zt;!i(ut)&&K&&(g.status="fulfilled",g.value=!0),mt(g)}return{mutate:Ft,get data(){return X.data=!0,ut},get error(){return X.error=!0,ct},get isValidating(){return X.isValidating=!0,ie},get isLoading(){return X.isLoading=!0,ae}}},Ze=$e(Ke);class ze{constructor(e={}){var n;this.apiKey=e.apiKey,this.username=e.username,this.password=e.password,this.accessToken=e.accessToken,this.basePath=e.basePath,this.serverIndex=e.serverIndex,this.baseOptions={headers:{...(n=e.baseOptions)==null?void 0:n.headers,"User-Agent":"OpenAPI-Generator/typescript-axios"},...e.baseOptions},this.formDataCtor=e.formDataCtor}isJsonMime(e){const n=new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$","i");return e!==null&&(n.test(e)||e.toLowerCase()==="application/json-patch+json")}}const y=Jt.create({baseURL:"/api",headers:{"Content-Type":"application/json"}});let rt=null;y.interceptors.response.use(t=>t,async t=>{const e=t.config;if(rt)return await rt,y(e);if(t.response.status===ue.Unauthorized&&!e._retry){e._retry=!0;try{return rt=Jt.post("/auth/refresh-token").finally(()=>{rt=null}),await rt,y(e)}catch(n){return window.location.href="/auth/logout",Promise.reject(n)}}return Promise.reject(t)});const H=new ze({basePath:"/api"});new we(H,q,y);const tn=new de(H,q,y),en=new pe(H,q,y),nn=new he(H,q,y),sn=new le(H,q,y);new Ee(H,q,y);new Re(H,q,y);const rn=new ge(H,q,y),on=new fe(H,q,y);export{$t as I,S as U,qe as a,wt as b,sn as c,rn as d,en as e,nn as f,_t as g,on as i,k as m,tn as o,Lt as s,Ze as u,Qe as w};

/* tslint:disable */
/* eslint-disable */
/**
 * Radiant API
 * This is the API for Radiant data platform.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Aggregation represents an aggregation result
 * @export
 * @interface Aggregation
 */
export interface Aggregation {
    /**
     * Count in the bucket
     * @type {number}
     * @memberof Aggregation
     */
    'count'?: number;
    /**
     * Bucket key
     * @type {string}
     * @memberof Aggregation
     */
    'key'?: string;
    /**
     * Label corresponding to the key
     * @type {string}
     * @memberof Aggregation
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface AggregationBodyWithSqon
 */
export interface AggregationBodyWithSqon {
    /**
     * 
     * @type {string}
     * @memberof AggregationBodyWithSqon
     */
    'field'?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregationBodyWithSqon
     */
    'size'?: number;
    /**
     * 
     * @type {Sqon}
     * @memberof AggregationBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * ApiError represents an error
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {any}
     * @memberof ApiError
     */
    'detail'?: any;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ApiError
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface Assay
 */
export interface Assay {
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'aliquot'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'capture_kit'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'category_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'created_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'experiment_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'experimental_strategy_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'experimental_strategy_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'histology_code'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Assay
     */
    'is_paired_end': boolean;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'platform_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof Assay
     */
    'read_length'?: number;
    /**
     * 
     * @type {number}
     * @memberof Assay
     */
    'request_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'run_alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'run_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'run_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Assay
     */
    'sample_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'sample_type_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof Assay
     */
    'seq_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'status_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'submitter_sample_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'tissue_site'?: string;
    /**
     * 
     * @type {string}
     * @memberof Assay
     */
    'updated_on'?: string;
}
/**
 * 
 * @export
 * @interface AutoCompleteTerm
 */
export interface AutoCompleteTerm {
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteTerm
     */
    'highlight'?: Term;
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteTerm
     */
    'source'?: Term;
}
/**
 * 
 * @export
 * @interface AutocompleteResult
 */
export interface AutocompleteResult {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'value': string;
}
/**
 * Assay to display in a Case
 * @export
 * @interface CaseAssay
 */
export interface CaseAssay {
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'affected_status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'experimental_strategy_code': string;
    /**
     * 
     * @type {boolean}
     * @memberof CaseAssay
     */
    'has_variants': boolean;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'histology_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseAssay
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'relationship_to_proband': string;
    /**
     * 
     * @type {number}
     * @memberof CaseAssay
     */
    'request_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CaseAssay
     */
    'sample_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'sample_submitter_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'sample_type_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseAssay
     */
    'seq_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'updated_on': string;
}
/**
 * Data for Case Entity Page
 * @export
 * @interface CaseEntity
 */
export interface CaseEntity {
    /**
     * 
     * @type {Array<CaseAssay>}
     * @memberof CaseEntity
     */
    'assays': Array<CaseAssay>;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'case_analysis_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'case_analysis_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseEntity
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'case_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'created_on': string;
    /**
     * 
     * @type {Array<CasePatientClinicalInformation>}
     * @memberof CaseEntity
     */
    'members': Array<CasePatientClinicalInformation>;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'prescriber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'primary_condition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'primary_condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'priority_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'project_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'project_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseEntity
     */
    'request_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'requested_by_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'requested_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'status_code': string;
    /**
     * 
     * @type {Array<CaseTask>}
     * @memberof CaseEntity
     */
    'tasks': Array<CaseTask>;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'updated_on': string;
}
/**
 * 
 * @export
 * @interface CaseFilters
 */
export interface CaseFilters {
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'case_analysis': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'performer_lab': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'priority': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'project': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'requested_by': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'status': Array<Aggregation>;
}
/**
 * Patient clinical information to display in Case Entity
 * @export
 * @interface CasePatientClinicalInformation
 */
export interface CasePatientClinicalInformation {
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'affected_status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'date_of_birth'?: string;
    /**
     * TODO
     * @type {Array<string>}
     * @memberof CasePatientClinicalInformation
     */
    'ethnicity_codes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'managing_organization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'managing_organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'mrn'?: string;
    /**
     * 
     * @type {Array<Term>}
     * @memberof CasePatientClinicalInformation
     */
    'non_observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {Array<Term>}
     * @memberof CasePatientClinicalInformation
     */
    'observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {number}
     * @memberof CasePatientClinicalInformation
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'relationship_to_proband': string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'sex_code': string;
}
/**
 * Line represented a case in case list
 * @export
 * @interface CaseResult
 */
export interface CaseResult {
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'case_analysis_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'case_analysis_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseResult
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'case_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'created_on': string;
    /**
     * 
     * @type {boolean}
     * @memberof CaseResult
     */
    'has_variants': boolean;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'managing_organization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'managing_organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'prescriber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'primary_condition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'primary_condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'priority_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseResult
     */
    'proband_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'proband_mrn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'project_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'project_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseResult
     */
    'request_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'requested_by_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'requested_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'updated_on': string;
}
/**
 * 
 * @export
 * @interface CaseTask
 */
export interface CaseTask {
    /**
     * 
     * @type {string}
     * @memberof CaseTask
     */
    'created_on': string;
    /**
     * 
     * @type {number}
     * @memberof CaseTask
     */
    'id': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CaseTask
     */
    'patients': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CaseTask
     */
    'type_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseTask
     */
    'type_name': string;
}
/**
 * 
 * @export
 * @interface CasesSearchResponse
 */
export interface CasesSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof CasesSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<CaseResult>}
     * @memberof CasesSearchResponse
     */
    'list': Array<CaseResult>;
}
/**
 * ClinvarRCV represents a Reference ClinVar record - data aggregated by variant-condition pair
 * @export
 * @interface ClinvarRCV
 */
export interface ClinvarRCV {
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'accession'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClinvarRCV
     */
    'clinical_significance'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'clinvar_id': string;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'date_last_evaluated'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'locus_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClinvarRCV
     */
    'origins'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'review_status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClinvarRCV
     */
    'review_status_stars'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClinvarRCV
     */
    'submission_count'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClinvarRCV
     */
    'traits'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ClinvarRCV
     */
    'version'?: number;
}
/**
 * Count represents count result
 * @export
 * @interface Count
 */
export interface Count {
    /**
     * Number of results
     * @type {number}
     * @memberof Count
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface CountBodyWithSqon
 */
export interface CountBodyWithSqon {
    /**
     * 
     * @type {Sqon}
     * @memberof CountBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * 
 * @export
 * @interface DocumentFilters
 */
export interface DocumentFilters {
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'data_type': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'format': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'performer_lab': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'project': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'relationship_to_proband': Array<Aggregation>;
}
/**
 * 
 * @export
 * @interface DocumentResult
 */
export interface DocumentResult {
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'data_type_code': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'document_id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'format_code': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'relationship_to_proband_code': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'run_alias'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'seq_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'submitter_sample_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'task_id': number;
}
/**
 * 
 * @export
 * @interface DocumentsSearchResponse
 */
export interface DocumentsSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof DocumentsSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<DocumentResult>}
     * @memberof DocumentsSearchResponse
     */
    'list': Array<DocumentResult>;
}
/**
 * 
 * @export
 * @interface ExpandedGermlineSNVOccurrence
 */
export interface ExpandedGermlineSNVOccurrence {
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'ad_alt'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'ad_total'?: number;
    /**
     * TODO
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'af'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'chromosome'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'dann_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'dna_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'end'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exomiser_acmg_classification'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exomiser_acmg_evidence': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exomiser_gene_combined_score': number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exon_rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exon_total'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'father_calls'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'genotype_quality': number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'hgvsg': string;
    /**
     * 
     * @type {boolean}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'is_mane_plus'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'locus': string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'locus_id': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'mother_calls'?: Array<number>;
    /**
     * 
     * @type {Array<OmimGenePanel>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'omim_conditions'?: Array<OmimGenePanel>;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'parental_origin'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pc_wgs_affected'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pc_wgs_not_affected'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pf_wgs'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pf_wgs_affected'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pf_wgs_not_affected'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pn_wgs_affected'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pn_wgs_not_affected'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'qd'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'sift_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'start'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'transmission'?: string;
    /**
     * 
     * @type {VepImpact}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'vep_impact'?: VepImpact;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'zygosity'?: string;
}


/**
 * 
 * @export
 * @interface FiltersBodyWithCriteria
 */
export interface FiltersBodyWithCriteria {
    /**
     * 
     * @type {Array<SearchCriterion>}
     * @memberof FiltersBodyWithCriteria
     */
    'search_criteria'?: Array<SearchCriterion>;
}
/**
 * 
 * @export
 * @interface GenePanelCondition
 */
export interface GenePanelCondition {
    /**
     * 
     * @type {Array<string>}
     * @memberof GenePanelCondition
     */
    'inheritance_code'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GenePanelCondition
     */
    'panel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenePanelCondition
     */
    'panel_name': string;
}
/**
 * 
 * @export
 * @interface GenePanelConditions
 */
export interface GenePanelConditions {
    /**
     * 
     * @type {{ [key: string]: Array<GenePanelCondition>; }}
     * @memberof GenePanelConditions
     */
    'conditions': { [key: string]: Array<GenePanelCondition>; };
    /**
     * 
     * @type {number}
     * @memberof GenePanelConditions
     */
    'count_hpo': number;
    /**
     * 
     * @type {number}
     * @memberof GenePanelConditions
     */
    'count_omim': number;
    /**
     * 
     * @type {number}
     * @memberof GenePanelConditions
     */
    'count_orphanet': number;
}
/**
 * GermlineCNVOccurrence represents a germline CNV occurrence
 * @export
 * @interface GermlineCNVOccurrence
 */
export interface GermlineCNVOccurrence {
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'aliquot'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'bc'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof GermlineCNVOccurrence
     */
    'calls'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'chromosome'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof GermlineCNVOccurrence
     */
    'ciend'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof GermlineCNVOccurrence
     */
    'cipos'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'cn'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'end'?: number;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'length'?: number;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'name'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof GermlineCNVOccurrence
     */
    'pe'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'quality'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'reflen'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'seq_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'sm'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'start'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'svlen'?: number;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'svtype'?: string;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'type'?: string;
}
/**
 * GermlineSNVOccurrence represents a germline SNV occurrence
 * @export
 * @interface GermlineSNVOccurrence
 */
export interface GermlineSNVOccurrence {
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'ad_ratio': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'chromosome': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineSNVOccurrence
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_acmg_classification': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_acmg_evidence': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_gene_combined_score': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_moi': string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_variant_score': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'genotype_quality': number;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {boolean}
     * @memberof GermlineSNVOccurrence
     */
    'has_interpretation': boolean;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'hgvsg': string;
    /**
     * 
     * @type {boolean}
     * @memberof GermlineSNVOccurrence
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GermlineSNVOccurrence
     */
    'is_mane_plus'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GermlineSNVOccurrence
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'locus': string;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'locus_id': string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'max_impact_score': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineSNVOccurrence
     */
    'omim_inheritance_code'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'pc_wgs'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'pf_wgs': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineSNVOccurrence
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'pn_wgs'?: number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'seq_id': number;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'start': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'task_id': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'variant_class': string;
    /**
     * 
     * @type {VepImpact}
     * @memberof GermlineSNVOccurrence
     */
    'vep_impact'?: VepImpact;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'zygosity': string;
}


/**
 * 
 * @export
 * @interface IGVTrackEnriched
 */
export interface IGVTrackEnriched {
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'family_role'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'format'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'indexURL'?: string;
    /**
     * 
     * @type {number}
     * @memberof IGVTrackEnriched
     */
    'indexURLExpireAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof IGVTrackEnriched
     */
    'patient_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'sex'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof IGVTrackEnriched
     */
    'urlExpireAt'?: number;
}
/**
 * 
 * @export
 * @interface IGVTracks
 */
export interface IGVTracks {
    /**
     * 
     * @type {Array<IGVTrackEnriched>}
     * @memberof IGVTracks
     */
    'alignment'?: Array<IGVTrackEnriched>;
}
/**
 * 
 * @export
 * @interface InterpretationGermline
 */
export interface InterpretationGermline {
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'classification'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationGermline
     */
    'classification_criterias'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'condition'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'interpretation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'locus_id'?: string;
    /**
     * 
     * @type {InterpretationMetadata}
     * @memberof InterpretationGermline
     */
    'metadata'?: InterpretationMetadata;
    /**
     * 
     * @type {Array<InterpretationPubmed>}
     * @memberof InterpretationGermline
     */
    'pubmed'?: Array<InterpretationPubmed>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'sequencing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationGermline
     */
    'transmission_modes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_by_name'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationMetadata
 */
export interface InterpretationMetadata {
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'analysis_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'patient_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'variant_hash'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationPubmed
 */
export interface InterpretationPubmed {
    /**
     * 
     * @type {string}
     * @memberof InterpretationPubmed
     */
    'citation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationPubmed
     */
    'citation_id'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationSomatic
 */
export interface InterpretationSomatic {
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'clinical_utility'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'interpretation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'locus_id'?: string;
    /**
     * 
     * @type {InterpretationMetadata}
     * @memberof InterpretationSomatic
     */
    'metadata'?: InterpretationMetadata;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'oncogenicity'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationSomatic
     */
    'oncogenicity_classification_criterias'?: Array<string>;
    /**
     * 
     * @type {Array<InterpretationPubmed>}
     * @memberof InterpretationSomatic
     */
    'pubmed'?: Array<InterpretationPubmed>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'sequencing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'tumoral_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_by_name'?: string;
}
/**
 * 
 * @export
 * @interface LeafContent
 */
export interface LeafContent {
    /**
     * 
     * @type {string}
     * @memberof LeafContent
     */
    'field'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof LeafContent
     */
    'value'?: Array<any>;
}
/**
 * Body of a list request with search criteria
 * @export
 * @interface ListBodyWithCriteria
 */
export interface ListBodyWithCriteria {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListBodyWithCriteria
     */
    'additional_fields'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithCriteria
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithCriteria
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithCriteria
     */
    'page_index'?: number;
    /**
     * 
     * @type {Array<SearchCriterion>}
     * @memberof ListBodyWithCriteria
     */
    'search_criteria'?: Array<SearchCriterion>;
    /**
     * 
     * @type {Array<SortBody>}
     * @memberof ListBodyWithCriteria
     */
    'sort'?: Array<SortBody>;
}
/**
 * Body of a list request
 * @export
 * @interface ListBodyWithSqon
 */
export interface ListBodyWithSqon {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListBodyWithSqon
     */
    'additional_fields'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithSqon
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithSqon
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithSqon
     */
    'page_index'?: number;
    /**
     * 
     * @type {Array<SortBody>}
     * @memberof ListBodyWithSqon
     */
    'sort'?: Array<SortBody>;
    /**
     * 
     * @type {Sqon}
     * @memberof ListBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * 
 * @export
 * @interface OmimGenePanel
 */
export interface OmimGenePanel {
    /**
     * 
     * @type {Array<string>}
     * @memberof OmimGenePanel
     */
    'inheritance_code'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OmimGenePanel
     */
    'omim_phenotype_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OmimGenePanel
     */
    'panel'?: string;
}
/**
 * 
 * @export
 * @interface PubmedCitation
 */
export interface PubmedCitation {
    /**
     * 
     * @type {string}
     * @memberof PubmedCitation
     */
    'id'?: string;
    /**
     * 
     * @type {PubmedCitationDetails}
     * @memberof PubmedCitation
     */
    'nlm'?: PubmedCitationDetails;
}
/**
 * 
 * @export
 * @interface PubmedCitationDetails
 */
export interface PubmedCitationDetails {
    /**
     * 
     * @type {string}
     * @memberof PubmedCitationDetails
     */
    'format'?: string;
}
/**
 * 
 * @export
 * @interface SavedFilter
 */
export interface SavedFilter {
    /**
     * 
     * @type {string}
     * @memberof SavedFilter
     */
    'created_on': string;
    /**
     * 
     * @type {boolean}
     * @memberof SavedFilter
     */
    'favorite': boolean;
    /**
     * 
     * @type {number}
     * @memberof SavedFilter
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SavedFilter
     */
    'name': string;
    /**
     * 
     * @type {Array<Sqon>}
     * @memberof SavedFilter
     */
    'queries': Array<Sqon>;
    /**
     * 
     * @type {SavedFilterType}
     * @memberof SavedFilter
     */
    'type': SavedFilterType;
    /**
     * 
     * @type {string}
     * @memberof SavedFilter
     */
    'updated_on': string;
    /**
     * 
     * @type {string}
     * @memberof SavedFilter
     */
    'user_id': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SavedFilterType = {
    GERMLINE_SNV_OCCURRENCE: 'germline_snv_occurrence',
    GERMLINE_CNV_OCCURRENCE: 'germline_cnv_occurrence',
    SOMATIC_SNV_OCCURRENCE: 'somatic_snv_occurrence',
    SOMATIC_CNV_OCCURRENCE: 'somatic_cnv_occurrence',
    GERMLINE_SNV_VARIANT: 'germline_snv_variant',
    GERMLINE_CNV_VARIANT: 'germline_cnv_variant',
    SOMATIC_SNV_VARIANT: 'somatic_snv_variant',
    SOMATIC_CNV_VARIANT: 'somatic_cnv_variant'
} as const;

export type SavedFilterType = typeof SavedFilterType[keyof typeof SavedFilterType];


/**
 * 
 * @export
 * @interface SearchCriterion
 */
export interface SearchCriterion {
    /**
     * 
     * @type {string}
     * @memberof SearchCriterion
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchCriterion
     */
    'operator'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof SearchCriterion
     */
    'value'?: Array<any>;
}
/**
 * Sequencing represents a sequencing
 * @export
 * @interface Sequencing
 */
export interface Sequencing {
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'affected_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'analysis_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'case_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'experimental_strategy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'family_role'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'part'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'patient_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'request_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'request_priority'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'sample_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'seq_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'sex'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'task_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'vcf_filepath'?: string;
}
/**
 * 
 * @export
 * @interface SortBody
 */
export interface SortBody {
    /**
     * 
     * @type {string}
     * @memberof SortBody
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortBody
     */
    'order'?: SortBodyOrderEnum;
}

export const SortBodyOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortBodyOrderEnum = typeof SortBodyOrderEnum[keyof typeof SortBodyOrderEnum];

/**
 * 
 * @export
 * @interface Sqon
 */
export interface Sqon {
    /**
     * 
     * @type {SqonContent}
     * @memberof Sqon
     */
    'content'?: SqonContent;
    /**
     * 
     * @type {string}
     * @memberof Sqon
     */
    'op'?: SqonOpEnum;
}

export const SqonOpEnum = {
    In: 'in',
    And: 'and',
    Or: 'or',
    Not: 'not',
    Between: 'between',
    GreaterThan: '>',
    LessThan: '<',
    GreaterThanOrEqualTo: '>=',
    LessThanOrEqualTo: '<=',
    NotIn: 'not-in',
    All: 'all'
} as const;

export type SqonOpEnum = typeof SqonOpEnum[keyof typeof SqonOpEnum];

/**
 * @type SqonContent
 * @export
 */
export type SqonContent = Array<Sqon> | LeafContent;

/**
 * Statistics represents statistics about a column
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * Max for numeric facet
     * @type {number}
     * @memberof Statistics
     */
    'max'?: number;
    /**
     * Min for numeric facet
     * @type {number}
     * @memberof Statistics
     */
    'min'?: number;
    /**
     * To tell UI if it\'s an integer or a decimal
     * @type {string}
     * @memberof Statistics
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface StatisticsBodyWithSqon
 */
export interface StatisticsBodyWithSqon {
    /**
     * 
     * @type {string}
     * @memberof StatisticsBodyWithSqon
     */
    'field'?: string;
    /**
     * 
     * @type {Sqon}
     * @memberof StatisticsBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * 
 * @export
 * @interface Term
 */
export interface Term {
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'onset_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'term'?: string;
}
/**
 * 
 * @export
 * @interface Transcript
 */
export interface Transcript {
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Transcript
     */
    'consequences'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'dann_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'dna_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'exon_rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'exon_total'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Transcript
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transcript
     */
    'is_mane_plus'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transcript
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'lrt_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'lrt_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'phyloP17way_primate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'polyphen2_hvar_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'polyphen2_hvar_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'sift_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {VepImpact}
     * @memberof Transcript
     */
    'vep_impact'?: VepImpact;
}


/**
 * 
 * @export
 * @interface UserSet
 */
export interface UserSet {
    /**
     * 
     * @type {boolean}
     * @memberof UserSet
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSet
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface VariantCasesCount
 */
export interface VariantCasesCount {
    /**
     * 
     * @type {number}
     * @memberof VariantCasesCount
     */
    'count_interpreted': number;
    /**
     * 
     * @type {number}
     * @memberof VariantCasesCount
     */
    'count_uninterpreted': number;
}
/**
 * 
 * @export
 * @interface VariantCasesFilters
 */
export interface VariantCasesFilters {
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof VariantCasesFilters
     */
    'case_analysis': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof VariantCasesFilters
     */
    'classification': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof VariantCasesFilters
     */
    'performer_lab': Array<Aggregation>;
}
/**
 * 
 * @export
 * @interface VariantConsequence
 */
export interface VariantConsequence {
    /**
     * 
     * @type {string}
     * @memberof VariantConsequence
     */
    'biotype'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantConsequence
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantConsequence
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VariantConsequence
     */
    'is_picked'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VariantConsequence
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantConsequence
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantConsequence
     */
    'symbol'?: string;
    /**
     * 
     * @type {Array<Transcript>}
     * @memberof VariantConsequence
     */
    'transcripts'?: Array<Transcript>;
}
/**
 * 
 * @export
 * @interface VariantExpandedInterpretedCase
 */
export interface VariantExpandedInterpretedCase {
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantExpandedInterpretedCase
     */
    'classification_criterias': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantExpandedInterpretedCase
     */
    'gene_symbol': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantExpandedInterpretedCase
     */
    'inheritances': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantExpandedInterpretedCase
     */
    'interpretation': string;
    /**
     * 
     * @type {string}
     * @memberof VariantExpandedInterpretedCase
     */
    'interpreter_name': string;
    /**
     * 
     * @type {number}
     * @memberof VariantExpandedInterpretedCase
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantExpandedInterpretedCase
     */
    'patient_sex_code': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantExpandedInterpretedCase
     */
    'pubmed_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface VariantHeader
 */
export interface VariantHeader {
    /**
     * 
     * @type {string}
     * @memberof VariantHeader
     */
    'assembly_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantHeader
     */
    'hgvsg': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantHeader
     */
    'source'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VariantInterpretedCase
 */
export interface VariantInterpretedCase {
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'affected_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'case_analysis_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'case_analysis_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCase
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'classification': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'condition_id': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'condition_name': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'interpretation_updated_on': string;
    /**
     * 
     * @type {Array<Term>}
     * @memberof VariantInterpretedCase
     */
    'observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCase
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'relationship_to_proband'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCase
     */
    'seq_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'submitter_sample_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'transcript_id': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'zygosity': string;
}
/**
 * 
 * @export
 * @interface VariantInterpretedCasesSearchResponse
 */
export interface VariantInterpretedCasesSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCasesSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<VariantInterpretedCase>}
     * @memberof VariantInterpretedCasesSearchResponse
     */
    'list': Array<VariantInterpretedCase>;
}
/**
 * 
 * @export
 * @interface VariantOverview
 */
export interface VariantOverview {
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'clinvar_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'dann_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'dna_change'?: string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof VariantOverview
     */
    'exomiser_acmg_classification_counts'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'exon_rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'exon_total'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof VariantOverview
     */
    'interpretation_classification_counts'?: { [key: string]: number; };
    /**
     * 
     * @type {boolean}
     * @memberof VariantOverview
     */
    'is_canonical': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VariantOverview
     */
    'is_mane_plus': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VariantOverview
     */
    'is_mane_select': boolean;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'locus': string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'lrt_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'lrt_score'?: number;
    /**
     * 
     * @type {Array<OmimGenePanel>}
     * @memberof VariantOverview
     */
    'omim_conditions'?: Array<OmimGenePanel>;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pc_wgs'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pf_wgs': number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'phyloP17way_primate'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pn_wgs'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'polyphen2_hvar_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'polyphen2_hvar_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'sift_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {VepImpact}
     * @memberof VariantOverview
     */
    'vep_impact'?: VepImpact;
}


/**
 * 
 * @export
 * @interface VariantUninterpretedCase
 */
export interface VariantUninterpretedCase {
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'affected_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'case_analysis_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'case_analysis_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCase
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'exomiser_acmg_classification'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantUninterpretedCase
     */
    'exomiser_acmg_evidence'?: Array<string>;
    /**
     * 
     * @type {Array<Term>}
     * @memberof VariantUninterpretedCase
     */
    'observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCase
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'primary_condition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'primary_condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'relationship_to_proband'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCase
     */
    'seq_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'submitter_sample_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'updated_on': string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'zygosity': string;
}
/**
 * 
 * @export
 * @interface VariantUninterpretedCasesSearchResponse
 */
export interface VariantUninterpretedCasesSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCasesSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<VariantUninterpretedCase>}
     * @memberof VariantUninterpretedCasesSearchResponse
     */
    'list': Array<VariantUninterpretedCase>;
}
/**
 * TODO
 * @export
 * @enum {string}
 */

export const VepImpact = {
    MODIFIER: 'MODIFIER',
    LOW: 'LOW',
    MODERATE: 'MODERATE',
    HIGH: 'HIGH'
} as const;

export type VepImpact = typeof VepImpact[keyof typeof VepImpact];



/**
 * AssaysApi - axios parameter creator
 * @export
 */
export const AssaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Assay by seq_id
         * @summary Get Assay by seq_id
         * @param {string} seqId Seq ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssayBySeqId: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getAssayBySeqId', 'seqId', seqId)
            const localVarPath = `/assays/{seq_id}`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssaysApi - functional programming interface
 * @export
 */
export const AssaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssaysApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Assay by seq_id
         * @summary Get Assay by seq_id
         * @param {string} seqId Seq ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssayBySeqId(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssayBySeqId(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssaysApi.getAssayBySeqId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssaysApi - factory interface
 * @export
 */
export const AssaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssaysApiFp(configuration)
    return {
        /**
         * Get Assay by seq_id
         * @summary Get Assay by seq_id
         * @param {string} seqId Seq ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssayBySeqId(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<Assay> {
            return localVarFp.getAssayBySeqId(seqId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssaysApi - object-oriented interface
 * @export
 * @class AssaysApi
 * @extends {BaseAPI}
 */
export class AssaysApi extends BaseAPI {
    /**
     * Get Assay by seq_id
     * @summary Get Assay by seq_id
     * @param {string} seqId Seq ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssaysApi
     */
    public getAssayBySeqId(seqId: string, options?: RawAxiosRequestConfig) {
        return AssaysApiFp(this.configuration).getAssayBySeqId(seqId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CasesApi - axios parameter creator
 * @export
 */
export const CasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCases: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('autocompleteCases', 'prefix', prefix)
            const localVarPath = `/cases/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {string} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntity: async (caseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntity', 'caseId', caseId)
            const localVarPath = `/cases/{case_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve DocumentFilters documents filters for a specific case
         * @summary Get DocumentFilters documents filters for a specific case
         * @param {string} caseId Case ID
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsFilters: async (caseId: string, filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntityDocumentsFilters', 'caseId', caseId)
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('caseEntityDocumentsFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/cases/{case_id}/documents/filters`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for DocumentResult list for a case entity
         * @summary Search DocumentResult list for a case entity
         * @param {string} caseId Case ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsSearch: async (caseId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntityDocumentsSearch', 'caseId', caseId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('caseEntityDocumentsSearch', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/cases/{case_id}/documents/search`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesFilters: async (filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('casesFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/cases/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCases: async (listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('searchCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/cases/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CasesApi - functional programming interface
 * @export
 */
export const CasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CasesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteCases(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.autocompleteCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {string} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntity(caseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntity(caseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve DocumentFilters documents filters for a specific case
         * @summary Get DocumentFilters documents filters for a specific case
         * @param {string} caseId Case ID
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntityDocumentsFilters(caseId: string, filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntityDocumentsFilters(caseId, filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntityDocumentsFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for DocumentResult list for a case entity
         * @summary Search DocumentResult list for a case entity
         * @param {string} caseId Case ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntityDocumentsSearch(caseId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntityDocumentsSearch(caseId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntityDocumentsSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesFilters(filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.casesFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCases(listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.searchCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CasesApi - factory interface
 * @export
 */
export const CasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CasesApiFp(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutocompleteResult>> {
            return localVarFp.autocompleteCases(prefix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {string} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntity(caseId: string, options?: RawAxiosRequestConfig): AxiosPromise<CaseEntity> {
            return localVarFp.caseEntity(caseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve DocumentFilters documents filters for a specific case
         * @summary Get DocumentFilters documents filters for a specific case
         * @param {string} caseId Case ID
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsFilters(caseId: string, filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFilters> {
            return localVarFp.caseEntityDocumentsFilters(caseId, filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for DocumentResult list for a case entity
         * @summary Search DocumentResult list for a case entity
         * @param {string} caseId Case ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsSearch(caseId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsSearchResponse> {
            return localVarFp.caseEntityDocumentsSearch(caseId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<CaseFilters> {
            return localVarFp.casesFilters(filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<CasesSearchResponse> {
            return localVarFp.searchCases(listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CasesApi - object-oriented interface
 * @export
 * @class CasesApi
 * @extends {BaseAPI}
 */
export class CasesApi extends BaseAPI {
    /**
     * Retrieve AutocompleteResult list of ids matching prefix
     * @summary Get AutocompleteResult list of matching prefix
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).autocompleteCases(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve CaseEntity by its ID
     * @summary Get CaseEntity case entity
     * @param {string} caseId Case ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public caseEntity(caseId: string, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntity(caseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve DocumentFilters documents filters for a specific case
     * @summary Get DocumentFilters documents filters for a specific case
     * @param {string} caseId Case ID
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public caseEntityDocumentsFilters(caseId: string, filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntityDocumentsFilters(caseId, filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for DocumentResult list for a case entity
     * @summary Search DocumentResult list for a case entity
     * @param {string} caseId Case ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public caseEntityDocumentsSearch(caseId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntityDocumentsSearch(caseId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve CaseFilters cases filters
     * @summary Get CaseFilters cases filters
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).casesFilters(filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search cases
     * @summary Search cases
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).searchCases(listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteDocuments: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('autocompleteDocuments', 'prefix', prefix)
            const localVarPath = `/documents/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve DocumentFilters documents filters
         * @summary Get DocumentFilters documents filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilters: async (filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('documentsFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/documents/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search documents
         * @summary Search documents
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments: async (listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('searchDocuments', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/documents/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteDocuments(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteDocuments(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.autocompleteDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve DocumentFilters documents filters
         * @summary Get DocumentFilters documents filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilters(filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search documents
         * @summary Search documents
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocuments(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDocuments(listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteDocuments(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutocompleteResult>> {
            return localVarFp.autocompleteDocuments(prefix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve DocumentFilters documents filters
         * @summary Get DocumentFilters documents filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFilters> {
            return localVarFp.documentsFilters(filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Search documents
         * @summary Search documents
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsSearchResponse> {
            return localVarFp.searchDocuments(listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Retrieve AutocompleteResult list of ids matching prefix
     * @summary Get AutocompleteResult list of matching prefix
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public autocompleteDocuments(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).autocompleteDocuments(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve DocumentFilters documents filters
     * @summary Get DocumentFilters documents filters
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilters(filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search documents
     * @summary Search documents
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public searchDocuments(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchDocuments(listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HpoApi - axios parameter creator
 * @export
 */
export const HpoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('hpoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/hpo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HpoApi - functional programming interface
 * @export
 */
export const HpoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HpoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hpoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HpoApi.hpoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HpoApi - factory interface
 * @export
 */
export const HpoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HpoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.hpoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HpoApi - object-oriented interface
 * @export
 * @class HpoApi
 * @extends {BaseAPI}
 */
export class HpoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HpoApi
     */
    public hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return HpoApiFp(this.configuration).hpoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IgvApi - axios parameter creator
 * @export
 */
export const IgvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get IGV tracks for a sequencing experiment
         * @summary Get IGV
         * @param {string} seqId Sequencing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIGV: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getIGV', 'seqId', seqId)
            const localVarPath = `/igv/{seq_id}`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IgvApi - functional programming interface
 * @export
 */
export const IgvApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IgvApiAxiosParamCreator(configuration)
    return {
        /**
         * Get IGV tracks for a sequencing experiment
         * @summary Get IGV
         * @param {string} seqId Sequencing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIGV(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IGVTracks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIGV(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IgvApi.getIGV']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IgvApi - factory interface
 * @export
 */
export const IgvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IgvApiFp(configuration)
    return {
        /**
         * Get IGV tracks for a sequencing experiment
         * @summary Get IGV
         * @param {string} seqId Sequencing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIGV(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<IGVTracks> {
            return localVarFp.getIGV(seqId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IgvApi - object-oriented interface
 * @export
 * @class IgvApi
 * @extends {BaseAPI}
 */
export class IgvApi extends BaseAPI {
    /**
     * Get IGV tracks for a sequencing experiment
     * @summary Get IGV
     * @param {string} seqId Sequencing ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IgvApi
     */
    public getIGV(seqId: string, options?: RawAxiosRequestConfig) {
        return IgvApiFp(this.configuration).getIGV(seqId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InterpretationsApi - axios parameter creator
 * @export
 */
export const InterpretationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation: async (citationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'citationId' is not null or undefined
            assertParamExists('getPubmedCitation', 'citationId', citationId)
            const localVarPath = `/interpretations/pubmed/{citation_id}`
                .replace(`{${"citation_id"}}`, encodeURIComponent(String(citationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline: async (sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationGermline' is not null or undefined
            assertParamExists('postInterpretationGermline', 'interpretationGermline', interpretationGermline)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationGermline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic: async (sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationSomatic' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'interpretationSomatic', interpretationSomatic)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationSomatic, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/germline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/somatic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterpretationsApi - functional programming interface
 * @export
 */
export const InterpretationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InterpretationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationGermline(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationSomatic(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PubmedCitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPubmedCitation(citationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getPubmedCitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationGermline(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterpretationGermline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationGermline(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationSomatic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterpretationSomatic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationSomatic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InterpretationsApi - factory interface
 * @export
 */
export const InterpretationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InterpretationsApiFp(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.getInterpretationGermline(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.getInterpretationSomatic(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): AxiosPromise<PubmedCitation> {
            return localVarFp.getPubmedCitation(citationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline(options?: RawAxiosRequestConfig): AxiosPromise<Array<InterpretationGermline>> {
            return localVarFp.searchInterpretationGermline(options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic(options?: RawAxiosRequestConfig): AxiosPromise<Array<InterpretationSomatic>> {
            return localVarFp.searchInterpretationSomatic(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InterpretationsApi - object-oriented interface
 * @export
 * @class InterpretationsApi
 * @extends {BaseAPI}
 */
export class InterpretationsApi extends BaseAPI {
    /**
     * Get interpretation germline
     * @summary Get interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationGermline(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get interpretation somatic
     * @summary Get interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationSomatic(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pubmed citation by ID
     * @summary Get pubmed citation by ID
     * @param {string} citationId Citation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getPubmedCitation(citationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation germline
     * @summary Create or Update interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationGermline} interpretationGermline Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation somatic
     * @summary Create or Update interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation germline
     * @summary Search interpretation germline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public searchInterpretationGermline(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationGermline(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation somatic
     * @summary Search interpretation somatic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public searchInterpretationSomatic(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationSomatic(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MondoApi - axios parameter creator
 * @export
 */
export const MondoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('mondoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/mondo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MondoApi - functional programming interface
 * @export
 */
export const MondoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MondoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mondoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MondoApi.mondoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MondoApi - factory interface
 * @export
 */
export const MondoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MondoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.mondoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MondoApi - object-oriented interface
 * @export
 * @class MondoApi
 * @extends {BaseAPI}
 */
export class MondoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MondoApi
     */
    public mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return MondoApiFp(this.configuration).mondoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OccurrencesApi - axios parameter creator
 * @export
 */
export const OccurrencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aggregate germline SNV occurrences for a given sequence ID
         * @summary Aggregate germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineSNVOccurrences: async (seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('aggregateGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'aggregationBodyWithSqon' is not null or undefined
            assertParamExists('aggregateGermlineSNVOccurrences', 'aggregationBodyWithSqon', aggregationBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/aggregate`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts germline CNV occurrences for a given sequence ID
         * @summary Count germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineCNVOccurrences: async (seqId: string, countBodyWithSqon: CountBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('countGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'countBodyWithSqon' is not null or undefined
            assertParamExists('countGermlineCNVOccurrences', 'countBodyWithSqon', countBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{seq_id}/count`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts germline SNV occurrences for a given sequence ID
         * @summary Count germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineSNVOccurrences: async (seqId: string, countBodyWithSqon: CountBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('countGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'countBodyWithSqon' is not null or undefined
            assertParamExists('countGermlineSNVOccurrences', 'countBodyWithSqon', countBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/count`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
         * @summary Get a germline ExpandedGermlineSNVOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineSNVOccurrence: async (seqId: string, locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getExpandedGermlineSNVOccurrence', 'seqId', seqId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getExpandedGermlineSNVOccurrence', 'locusId', locusId)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/{locus_id}/expanded`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List germline CNV occurrences for a given sequence ID
         * @summary List germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVOccurrences: async (seqId: string, listBodyWithSqon: ListBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'listBodyWithSqon' is not null or undefined
            assertParamExists('listGermlineCNVOccurrences', 'listBodyWithSqon', listBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{seq_id}/list`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List germline SNV occurrences for a given sequence ID
         * @summary List germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineSNVOccurrences: async (seqId: string, listBodyWithSqon: ListBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'listBodyWithSqon' is not null or undefined
            assertParamExists('listGermlineSNVOccurrences', 'listBodyWithSqon', listBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/list`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineSNVOccurrences: async (seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('statisticsGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'statisticsBodyWithSqon' is not null or undefined
            assertParamExists('statisticsGermlineSNVOccurrences', 'statisticsBodyWithSqon', statisticsBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/statistics`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticsBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OccurrencesApi - functional programming interface
 * @export
 */
export const OccurrencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OccurrencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Aggregate germline SNV occurrences for a given sequence ID
         * @summary Aggregate germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateGermlineSNVOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Aggregation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateGermlineSNVOccurrences(seqId, aggregationBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.aggregateGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Counts germline CNV occurrences for a given sequence ID
         * @summary Count germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countGermlineCNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Count>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countGermlineCNVOccurrences(seqId, countBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.countGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Counts germline SNV occurrences for a given sequence ID
         * @summary Count germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countGermlineSNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Count>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countGermlineSNVOccurrences(seqId, countBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.countGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
         * @summary Get a germline ExpandedGermlineSNVOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpandedGermlineSNVOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandedGermlineSNVOccurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpandedGermlineSNVOccurrence(seqId, locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.getExpandedGermlineSNVOccurrence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List germline CNV occurrences for a given sequence ID
         * @summary List germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGermlineCNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GermlineCNVOccurrence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGermlineCNVOccurrences(seqId, listBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List germline SNV occurrences for a given sequence ID
         * @summary List germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGermlineSNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GermlineSNVOccurrence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGermlineSNVOccurrences(seqId, listBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsGermlineSNVOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsGermlineSNVOccurrences(seqId, statisticsBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.statisticsGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OccurrencesApi - factory interface
 * @export
 */
export const OccurrencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OccurrencesApiFp(configuration)
    return {
        /**
         * Aggregate germline SNV occurrences for a given sequence ID
         * @summary Aggregate germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineSNVOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<Aggregation>> {
            return localVarFp.aggregateGermlineSNVOccurrences(seqId, aggregationBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts germline CNV occurrences for a given sequence ID
         * @summary Count germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineCNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Count> {
            return localVarFp.countGermlineCNVOccurrences(seqId, countBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts germline SNV occurrences for a given sequence ID
         * @summary Count germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineSNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Count> {
            return localVarFp.countGermlineSNVOccurrences(seqId, countBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
         * @summary Get a germline ExpandedGermlineSNVOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineSNVOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExpandedGermlineSNVOccurrence> {
            return localVarFp.getExpandedGermlineSNVOccurrence(seqId, locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * List germline CNV occurrences for a given sequence ID
         * @summary List germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<GermlineCNVOccurrence>> {
            return localVarFp.listGermlineCNVOccurrences(seqId, listBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * List germline SNV occurrences for a given sequence ID
         * @summary List germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineSNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<GermlineSNVOccurrence>> {
            return localVarFp.listGermlineSNVOccurrences(seqId, listBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineSNVOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Statistics> {
            return localVarFp.statisticsGermlineSNVOccurrences(seqId, statisticsBodyWithSqon, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OccurrencesApi - object-oriented interface
 * @export
 * @class OccurrencesApi
 * @extends {BaseAPI}
 */
export class OccurrencesApi extends BaseAPI {
    /**
     * Aggregate germline SNV occurrences for a given sequence ID
     * @summary Aggregate germline SNV occurrences
     * @param {string} seqId Sequence ID
     * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public aggregateGermlineSNVOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).aggregateGermlineSNVOccurrences(seqId, aggregationBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts germline CNV occurrences for a given sequence ID
     * @summary Count germline CNV occurrences
     * @param {string} seqId Sequence ID
     * @param {CountBodyWithSqon} countBodyWithSqon Count Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public countGermlineCNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).countGermlineCNVOccurrences(seqId, countBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts germline SNV occurrences for a given sequence ID
     * @summary Count germline SNV occurrences
     * @param {string} seqId Sequence ID
     * @param {CountBodyWithSqon} countBodyWithSqon Count Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public countGermlineSNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).countGermlineSNVOccurrences(seqId, countBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
     * @summary Get a germline ExpandedGermlineSNVOccurrence
     * @param {string} seqId Sequence ID
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public getExpandedGermlineSNVOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).getExpandedGermlineSNVOccurrence(seqId, locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List germline CNV occurrences for a given sequence ID
     * @summary List germline CNV occurrences
     * @param {string} seqId Sequence ID
     * @param {ListBodyWithSqon} listBodyWithSqon List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public listGermlineCNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listGermlineCNVOccurrences(seqId, listBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List germline SNV occurrences for a given sequence ID
     * @summary List germline SNV occurrences
     * @param {string} seqId Sequence ID
     * @param {ListBodyWithSqon} listBodyWithSqon List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public listGermlineSNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listGermlineSNVOccurrences(seqId, listBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return statistics about a field for a given sequence ID
     * @summary Statistics of germline SNV occurrences
     * @param {string} seqId Sequence ID
     * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public statisticsGermlineSNVOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).statisticsGermlineSNVOccurrences(seqId, statisticsBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SavedFiltersApi - axios parameter creator
 * @export
 */
export const SavedFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get saved filter by id
         * @summary Get saved filter by id
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilterById: async (savedFilterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedFilterId' is not null or undefined
            assertParamExists('getSavedFilterById', 'savedFilterId', savedFilterId)
            const localVarPath = `/users/saved_filters/{saved_filter_id}`
                .replace(`{${"saved_filter_id"}}`, encodeURIComponent(String(savedFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user saved filters
         * @summary Get user saved filters
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFiltersByUserID: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getSavedFiltersByUserID', 'userId', userId)
            const localVarPath = `/users/{user_id}/saved_filters`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user saved filters by type
         * @summary Get user saved filters by type
         * @param {string} userId User ID
         * @param {string} savedFilterType Saved Filter Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFiltersByUserIDAndType: async (userId: string, savedFilterType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getSavedFiltersByUserIDAndType', 'userId', userId)
            // verify required parameter 'savedFilterType' is not null or undefined
            assertParamExists('getSavedFiltersByUserIDAndType', 'savedFilterType', savedFilterType)
            const localVarPath = `/users/{user_id}/saved_filters/{saved_filter_type}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"saved_filter_type"}}`, encodeURIComponent(String(savedFilterType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedFiltersApi - functional programming interface
 * @export
 */
export const SavedFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get saved filter by id
         * @summary Get saved filter by id
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedFilterById(savedFilterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedFilterById(savedFilterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.getSavedFilterById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user saved filters
         * @summary Get user saved filters
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedFiltersByUserID(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedFilter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedFiltersByUserID(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.getSavedFiltersByUserID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user saved filters by type
         * @summary Get user saved filters by type
         * @param {string} userId User ID
         * @param {string} savedFilterType Saved Filter Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedFiltersByUserIDAndType(userId: string, savedFilterType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedFilter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedFiltersByUserIDAndType(userId, savedFilterType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.getSavedFiltersByUserIDAndType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SavedFiltersApi - factory interface
 * @export
 */
export const SavedFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedFiltersApiFp(configuration)
    return {
        /**
         * Get saved filter by id
         * @summary Get saved filter by id
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilterById(savedFilterId: string, options?: RawAxiosRequestConfig): AxiosPromise<SavedFilter> {
            return localVarFp.getSavedFilterById(savedFilterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user saved filters
         * @summary Get user saved filters
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFiltersByUserID(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SavedFilter>> {
            return localVarFp.getSavedFiltersByUserID(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user saved filters by type
         * @summary Get user saved filters by type
         * @param {string} userId User ID
         * @param {string} savedFilterType Saved Filter Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFiltersByUserIDAndType(userId: string, savedFilterType: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SavedFilter>> {
            return localVarFp.getSavedFiltersByUserIDAndType(userId, savedFilterType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SavedFiltersApi - object-oriented interface
 * @export
 * @class SavedFiltersApi
 * @extends {BaseAPI}
 */
export class SavedFiltersApi extends BaseAPI {
    /**
     * Get saved filter by id
     * @summary Get saved filter by id
     * @param {string} savedFilterId Saved Filter ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedFiltersApi
     */
    public getSavedFilterById(savedFilterId: string, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).getSavedFilterById(savedFilterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user saved filters
     * @summary Get user saved filters
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedFiltersApi
     */
    public getSavedFiltersByUserID(userId: string, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).getSavedFiltersByUserID(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user saved filters by type
     * @summary Get user saved filters by type
     * @param {string} userId User ID
     * @param {string} savedFilterType Saved Filter Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedFiltersApi
     */
    public getSavedFiltersByUserIDAndType(userId: string, savedFilterType: string, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).getSavedFiltersByUserIDAndType(userId, savedFilterType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SequencingApi - axios parameter creator
 * @export
 */
export const SequencingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getSequencing', 'seqId', seqId)
            const localVarPath = `/sequencing/{seq_id}`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SequencingApi - functional programming interface
 * @export
 */
export const SequencingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SequencingApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSequencing(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequencing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSequencing(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SequencingApi.getSequencing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SequencingApi - factory interface
 * @export
 */
export const SequencingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SequencingApiFp(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<Sequencing> {
            return localVarFp.getSequencing(seqId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SequencingApi - object-oriented interface
 * @export
 * @class SequencingApi
 * @extends {BaseAPI}
 */
export class SequencingApi extends BaseAPI {
    /**
     * Retrieve Sequencing data for a given sequence ID
     * @summary Get a Sequencing
     * @param {string} seqId Sequence ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SequencingApi
     */
    public getSequencing(seqId: string, options?: RawAxiosRequestConfig) {
        return SequencingApiFp(this.configuration).getSequencing(seqId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Returns the current status of the API
     * @summary Get API status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusGet(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSetsApi - axios parameter creator
 * @export
 */
export const UserSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet: async (userSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSetId' is not null or undefined
            assertParamExists('getUserSet', 'userSetId', userSetId)
            const localVarPath = `/users/sets/{user_set_id}`
                .replace(`{${"user_set_id"}}`, encodeURIComponent(String(userSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSetsApi - functional programming interface
 * @export
 */
export const UserSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSet(userSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSet(userSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSetsApi.getUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserSetsApi - factory interface
 * @export
 */
export const UserSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSetsApiFp(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet(userSetId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSet> {
            return localVarFp.getUserSet(userSetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSetsApi - object-oriented interface
 * @export
 * @class UserSetsApi
 * @extends {BaseAPI}
 */
export class UserSetsApi extends BaseAPI {
    /**
     * Get user set
     * @summary Get user set by id
     * @param {string} userSetId UserSet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSetsApi
     */
    public getUserSet(userSetId: string, options?: RawAxiosRequestConfig) {
        return UserSetsApiFp(this.configuration).getUserSet(userSetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariantApi - axios parameter creator
 * @export
 */
export const VariantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
         * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineVariantInterpretedCase: async (locusId: string, seqId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'locusId', locusId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'seqId', seqId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'transcriptId', transcriptId)
            const localVarPath = `/variants/germline/{locus_id}/cases/interpreted/{seq_id}/{transcript_id}`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesCount: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantCasesCount', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/cases/count`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesFilters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variants/germline/cases/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditions: async (locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConditions', 'locusId', locusId)
            // verify required parameter 'panelType' is not null or undefined
            assertParamExists('getGermlineVariantConditions', 'panelType', panelType)
            const localVarPath = `/variants/germline/{locus_id}/conditions/{panel_type}`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"panel_type"}}`, encodeURIComponent(String(panelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditionsClinvar: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConditionsClinvar', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/conditions/clinvar`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConsequences: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConsequences', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/consequences`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantHeader: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantHeader', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/header`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantInterpretedCases: async (locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantInterpretedCases', 'locusId', locusId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('getGermlineVariantInterpretedCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/variants/germline/{locus_id}/cases/interpreted`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantOverview: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantOverview', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/overview`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantUninterpretedCases: async (locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantUninterpretedCases', 'locusId', locusId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('getGermlineVariantUninterpretedCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/variants/germline/{locus_id}/cases/uninterpreted`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariantApi - functional programming interface
 * @export
 */
export const VariantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariantApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
         * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpandedGermlineVariantInterpretedCase(locusId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantExpandedInterpretedCase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpandedGermlineVariantInterpretedCase(locusId, seqId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getExpandedGermlineVariantInterpretedCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantCasesCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantCasesCount(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantCasesCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantCasesFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantCasesFilters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantCasesFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenePanelConditions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConditions(locusId, panelType, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConditions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClinvarRCV>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConditionsClinvar(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConditionsClinvar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariantConsequence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConsequences(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConsequences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantHeader(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantHeader']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantInterpretedCasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantInterpretedCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantOverview(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantUninterpretedCasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantUninterpretedCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariantApi - factory interface
 * @export
 */
export const VariantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariantApiFp(configuration)
    return {
        /**
         * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
         * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineVariantInterpretedCase(locusId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantExpandedInterpretedCase> {
            return localVarFp.getExpandedGermlineVariantInterpretedCase(locusId, seqId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantCasesCount> {
            return localVarFp.getGermlineVariantCasesCount(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig): AxiosPromise<VariantCasesFilters> {
            return localVarFp.getGermlineVariantCasesFilters(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<GenePanelConditions> {
            return localVarFp.getGermlineVariantConditions(locusId, panelType, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClinvarRCV>> {
            return localVarFp.getGermlineVariantConditionsClinvar(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariantConsequence>> {
            return localVarFp.getGermlineVariantConsequences(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantHeader> {
            return localVarFp.getGermlineVariantHeader(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<VariantInterpretedCasesSearchResponse> {
            return localVarFp.getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantOverview> {
            return localVarFp.getGermlineVariantOverview(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<VariantUninterpretedCasesSearchResponse> {
            return localVarFp.getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariantApi - object-oriented interface
 * @export
 * @class VariantApi
 * @extends {BaseAPI}
 */
export class VariantApi extends BaseAPI {
    /**
     * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
     * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
     * @param {string} locusId Locus ID
     * @param {string} seqId Seq ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getExpandedGermlineVariantInterpretedCase(locusId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getExpandedGermlineVariantInterpretedCase(locusId, seqId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve cases count for a given locus id
     * @summary Get germline cases count for a given locus
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantCasesCount(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve cases filters for germline variant entity
     * @summary Get cases filters for germline variant entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantCasesFilters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve conditions for germline variant entity for a specific gene panel
     * @summary Get conditions for germline variant entity for a specific gene panel
     * @param {string} locusId Locus ID
     * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
     * @param {string} [filter] Condition filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConditions(locusId, panelType, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ClinVar conditions for germline variant entity
     * @summary Get ClinVar conditions for germline variant entity
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConditionsClinvar(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Consequences for a given locus
     * @summary Get list of VariantConsequences for a germline variant
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConsequences(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Header data for a given locus
     * @summary Get a germline VariantHeader
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantHeader(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Germline Variant interpreted cases for a given locus
     * @summary Get list of interpreted Cases for a germline variant
     * @param {string} locusId Locus ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Overview data for a given locus
     * @summary Get a germline VariantOverview
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantOverview(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Germline Variant uninterpreted cases for a given locus
     * @summary Get list of uninterpreted Cases for a germline variant
     * @param {string} locusId Locus ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetGermlineVariantConditionsPanelTypeEnum = {
    Omim: 'omim',
    Hpo: 'hpo',
    Orphanet: 'orphanet'
} as const;
export type GetGermlineVariantConditionsPanelTypeEnum = typeof GetGermlineVariantConditionsPanelTypeEnum[keyof typeof GetGermlineVariantConditionsPanelTypeEnum];



/* tslint:disable */
/* eslint-disable */
/**
 * Radiant API
 * This is the API for Radiant data platform.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Aggregation represents an aggregation result
 * @export
 * @interface Aggregation
 */
export interface Aggregation {
    /**
     * Count in the bucket
     * @type {number}
     * @memberof Aggregation
     */
    'count'?: number;
    /**
     * Bucket key
     * @type {string}
     * @memberof Aggregation
     */
    'key'?: string;
    /**
     * Label corresponding to the key
     * @type {string}
     * @memberof Aggregation
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface AggregationBodyWithSqon
 */
export interface AggregationBodyWithSqon {
    /**
     * 
     * @type {string}
     * @memberof AggregationBodyWithSqon
     */
    'field'?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregationBodyWithSqon
     */
    'size'?: number;
    /**
     * 
     * @type {Sqon}
     * @memberof AggregationBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * ApiError represents an error
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {any}
     * @memberof ApiError
     */
    'detail'?: any;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ApiError
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface AutoCompleteTerm
 */
export interface AutoCompleteTerm {
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteTerm
     */
    'highlight'?: Term;
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteTerm
     */
    'source'?: Term;
}
/**
 * 
 * @export
 * @interface AutocompleteResult
 */
export interface AutocompleteResult {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'value': string;
}
/**
 * Assay to display in a Case
 * @export
 * @interface CaseAssay
 */
export interface CaseAssay {
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'affected_status_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'experimental_strategy_code': string;
    /**
     * 
     * @type {boolean}
     * @memberof CaseAssay
     */
    'has_variants': boolean;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'histology_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseAssay
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'relationship_to_proband'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseAssay
     */
    'request_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CaseAssay
     */
    'sample_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'sample_submitter_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'sample_type_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseAssay
     */
    'seq_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseAssay
     */
    'updated_on': string;
}
/**
 * Data for Case Entity Page
 * @export
 * @interface CaseEntity
 */
export interface CaseEntity {
    /**
     * 
     * @type {Array<CaseAssay>}
     * @memberof CaseEntity
     */
    'assays': Array<CaseAssay>;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'case_analysis_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'case_analysis_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseEntity
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'case_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'created_on': string;
    /**
     * 
     * @type {Array<CasePatientClinicalInformation>}
     * @memberof CaseEntity
     */
    'members': Array<CasePatientClinicalInformation>;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'prescriber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'primary_condition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'primary_condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'priority_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseEntity
     */
    'request_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'requested_by_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'requested_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'status_code': string;
    /**
     * 
     * @type {Array<CaseTask>}
     * @memberof CaseEntity
     */
    'tasks': Array<CaseTask>;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'updated_on': string;
}
/**
 * 
 * @export
 * @interface CaseFilters
 */
export interface CaseFilters {
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'case_analysis': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'performer_lab': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'priority': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'project': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'requested_by': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'status': Array<Aggregation>;
}
/**
 * Patient clinical information to display in Case Entity
 * @export
 * @interface CasePatientClinicalInformation
 */
export interface CasePatientClinicalInformation {
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'affected_status_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'date_of_birth'?: string;
    /**
     * TODO
     * @type {Array<string>}
     * @memberof CasePatientClinicalInformation
     */
    'ethnicity_codes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'managing_organization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'managing_organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'mrn'?: string;
    /**
     * 
     * @type {Array<Term>}
     * @memberof CasePatientClinicalInformation
     */
    'non_observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {Array<Term>}
     * @memberof CasePatientClinicalInformation
     */
    'observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {number}
     * @memberof CasePatientClinicalInformation
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'relationship_to_proband'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'sex_code': string;
}
/**
 * Line represented a case in case list
 * @export
 * @interface CaseResult
 */
export interface CaseResult {
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'case_analysis_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'case_analysis_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseResult
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'case_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'managing_organization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'managing_organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'mrn'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseResult
     */
    'patient_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'prescriber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'primary_condition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'primary_condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'priority_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'project_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseResult
     */
    'request_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'requested_by_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'requested_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'updated_on': string;
}
/**
 * 
 * @export
 * @interface CaseTask
 */
export interface CaseTask {
    /**
     * 
     * @type {string}
     * @memberof CaseTask
     */
    'created_on': string;
    /**
     * 
     * @type {number}
     * @memberof CaseTask
     */
    'id': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CaseTask
     */
    'patients': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CaseTask
     */
    'type_code': string;
}
/**
 * 
 * @export
 * @interface CasesSearchResponse
 */
export interface CasesSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof CasesSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<CaseResult>}
     * @memberof CasesSearchResponse
     */
    'list': Array<CaseResult>;
}
/**
 * ClinvarRCV represents a Reference ClinVar record - data aggregated by variant-condition pair
 * @export
 * @interface ClinvarRCV
 */
export interface ClinvarRCV {
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'accession'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClinvarRCV
     */
    'clinical_significance'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'clinvar_id': string;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'date_last_evaluated'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'locus_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClinvarRCV
     */
    'origins'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'review_status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClinvarRCV
     */
    'review_status_stars'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClinvarRCV
     */
    'submission_count'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClinvarRCV
     */
    'traits'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ClinvarRCV
     */
    'version'?: number;
}
/**
 * Count represents count result
 * @export
 * @interface Count
 */
export interface Count {
    /**
     * Number of results
     * @type {number}
     * @memberof Count
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface CountBodyWithSqon
 */
export interface CountBodyWithSqon {
    /**
     * 
     * @type {Sqon}
     * @memberof CountBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * 
 * @export
 * @interface ExpendedOccurrence
 */
export interface ExpendedOccurrence {
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'ad_alt'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'ad_total'?: number;
    /**
     * TODO
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'af'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'chromosome'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpendedOccurrence
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'dann_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'dna_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'end'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpendedOccurrence
     */
    'exomiser_acmg_evidence': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'exomiser_gene_combined_score': number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'exon_rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'exon_total'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExpendedOccurrence
     */
    'father_calls'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'genotype_quality': number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'hgvsg': string;
    /**
     * 
     * @type {boolean}
     * @memberof ExpendedOccurrence
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpendedOccurrence
     */
    'is_mane_plus'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpendedOccurrence
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'locus': string;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'locus_id': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExpendedOccurrence
     */
    'mother_calls'?: Array<number>;
    /**
     * 
     * @type {Array<OmimGenePanel>}
     * @memberof ExpendedOccurrence
     */
    'omim_conditions'?: Array<OmimGenePanel>;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'parental_origin'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'pf_wgs'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpendedOccurrence
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'qd'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'sift_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpendedOccurrence
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'start'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'transmission'?: string;
    /**
     * 
     * @type {VepImpact}
     * @memberof ExpendedOccurrence
     */
    'vep_impact'?: VepImpact;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'zygosity'?: string;
}


/**
 * 
 * @export
 * @interface FiltersBodyWithCriteria
 */
export interface FiltersBodyWithCriteria {
    /**
     * 
     * @type {Array<SearchCriterion>}
     * @memberof FiltersBodyWithCriteria
     */
    'search_criteria'?: Array<SearchCriterion>;
}
/**
 * 
 * @export
 * @interface InterpretationGermline
 */
export interface InterpretationGermline {
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'classification'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationGermline
     */
    'classification_criterias'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'condition'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'interpretation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'locus_id'?: string;
    /**
     * 
     * @type {InterpretationMetadata}
     * @memberof InterpretationGermline
     */
    'metadata'?: InterpretationMetadata;
    /**
     * 
     * @type {Array<InterpretationPubmed>}
     * @memberof InterpretationGermline
     */
    'pubmed'?: Array<InterpretationPubmed>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'sequencing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationGermline
     */
    'transmission_modes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_by_name'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationMetadata
 */
export interface InterpretationMetadata {
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'analysis_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'patient_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'variant_hash'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationPubmed
 */
export interface InterpretationPubmed {
    /**
     * 
     * @type {string}
     * @memberof InterpretationPubmed
     */
    'citation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationPubmed
     */
    'citation_id'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationSomatic
 */
export interface InterpretationSomatic {
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'clinical_utility'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'interpretation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'locus_id'?: string;
    /**
     * 
     * @type {InterpretationMetadata}
     * @memberof InterpretationSomatic
     */
    'metadata'?: InterpretationMetadata;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'oncogenicity'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationSomatic
     */
    'oncogenicity_classification_criterias'?: Array<string>;
    /**
     * 
     * @type {Array<InterpretationPubmed>}
     * @memberof InterpretationSomatic
     */
    'pubmed'?: Array<InterpretationPubmed>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'sequencing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'tumoral_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_by_name'?: string;
}
/**
 * 
 * @export
 * @interface LeafContent
 */
export interface LeafContent {
    /**
     * 
     * @type {string}
     * @memberof LeafContent
     */
    'field'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof LeafContent
     */
    'value'?: Array<any>;
}
/**
 * Body of a list request with search criteria
 * @export
 * @interface ListBodyWithCriteria
 */
export interface ListBodyWithCriteria {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListBodyWithCriteria
     */
    'additional_fields'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithCriteria
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithCriteria
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithCriteria
     */
    'page_index'?: number;
    /**
     * 
     * @type {Array<SearchCriterion>}
     * @memberof ListBodyWithCriteria
     */
    'search_criteria'?: Array<SearchCriterion>;
    /**
     * 
     * @type {Array<SortBody>}
     * @memberof ListBodyWithCriteria
     */
    'sort'?: Array<SortBody>;
}
/**
 * Body of a list request
 * @export
 * @interface ListBodyWithSqon
 */
export interface ListBodyWithSqon {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListBodyWithSqon
     */
    'additional_fields'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithSqon
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithSqon
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithSqon
     */
    'page_index'?: number;
    /**
     * 
     * @type {Array<SortBody>}
     * @memberof ListBodyWithSqon
     */
    'sort'?: Array<SortBody>;
    /**
     * 
     * @type {Sqon}
     * @memberof ListBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * Occurrence represents an occurrence
 * @export
 * @interface Occurrence
 */
export interface Occurrence {
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'ad_ratio': number;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'chromosome': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Occurrence
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'exomiser_acmg_classification': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Occurrence
     */
    'exomiser_acmg_evidence': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'exomiser_gene_combined_score': number;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'exomiser_moi': string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'exomiser_variant_score': number;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'genotype_quality': number;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {boolean}
     * @memberof Occurrence
     */
    'has_interpretation': boolean;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'hgvsg': string;
    /**
     * 
     * @type {boolean}
     * @memberof Occurrence
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Occurrence
     */
    'is_mane_plus'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Occurrence
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'locus_id': string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'max_impact_score': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Occurrence
     */
    'omim_inheritance_code'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'pc_wgs'?: number;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'pf_wgs': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Occurrence
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'pn_wgs'?: number;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'seq_id': number;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'start': number;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'task_id': number;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'variant_class': string;
    /**
     * 
     * @type {VepImpact}
     * @memberof Occurrence
     */
    'vep_impact'?: VepImpact;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'zygosity': string;
}


/**
 * 
 * @export
 * @interface OmimGenePanel
 */
export interface OmimGenePanel {
    /**
     * 
     * @type {Array<string>}
     * @memberof OmimGenePanel
     */
    'inheritance_code'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OmimGenePanel
     */
    'omim_phenotype_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OmimGenePanel
     */
    'panel'?: string;
}
/**
 * 
 * @export
 * @interface PubmedCitation
 */
export interface PubmedCitation {
    /**
     * 
     * @type {string}
     * @memberof PubmedCitation
     */
    'id'?: string;
    /**
     * 
     * @type {PubmedCitationDetails}
     * @memberof PubmedCitation
     */
    'nlm'?: PubmedCitationDetails;
}
/**
 * 
 * @export
 * @interface PubmedCitationDetails
 */
export interface PubmedCitationDetails {
    /**
     * 
     * @type {string}
     * @memberof PubmedCitationDetails
     */
    'format'?: string;
}
/**
 * 
 * @export
 * @interface SearchCriterion
 */
export interface SearchCriterion {
    /**
     * 
     * @type {string}
     * @memberof SearchCriterion
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchCriterion
     */
    'operator'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof SearchCriterion
     */
    'value'?: Array<any>;
}
/**
 * Sequencing represents a sequencing
 * @export
 * @interface Sequencing
 */
export interface Sequencing {
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'affected_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'analysis_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'case_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'experimental_strategy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'family_role'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'part'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'patient_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'request_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'request_priority'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'sample_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'seq_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'sex'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'task_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'vcf_filepath'?: string;
}
/**
 * 
 * @export
 * @interface SortBody
 */
export interface SortBody {
    /**
     * 
     * @type {string}
     * @memberof SortBody
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortBody
     */
    'order'?: SortBodyOrderEnum;
}

export const SortBodyOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortBodyOrderEnum = typeof SortBodyOrderEnum[keyof typeof SortBodyOrderEnum];

/**
 * 
 * @export
 * @interface Sqon
 */
export interface Sqon {
    /**
     * 
     * @type {SqonContent}
     * @memberof Sqon
     */
    'content'?: SqonContent;
    /**
     * 
     * @type {string}
     * @memberof Sqon
     */
    'op'?: SqonOpEnum;
}

export const SqonOpEnum = {
    In: 'in',
    And: 'and',
    Or: 'or',
    Not: 'not',
    Between: 'between',
    GreaterThan: '>',
    LessThan: '<',
    GreaterThanOrEqualTo: '>=',
    LessThanOrEqualTo: '<=',
    NotIn: 'not-in',
    All: 'all'
} as const;

export type SqonOpEnum = typeof SqonOpEnum[keyof typeof SqonOpEnum];

/**
 * @type SqonContent
 * @export
 */
export type SqonContent = Array<Sqon> | LeafContent;

/**
 * Statistics represents statistics about a column
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * Max for numeric facet
     * @type {number}
     * @memberof Statistics
     */
    'max'?: number;
    /**
     * Min for numeric facet
     * @type {number}
     * @memberof Statistics
     */
    'min'?: number;
}
/**
 * 
 * @export
 * @interface StatisticsBodyWithSqon
 */
export interface StatisticsBodyWithSqon {
    /**
     * 
     * @type {string}
     * @memberof StatisticsBodyWithSqon
     */
    'field'?: string;
    /**
     * 
     * @type {Sqon}
     * @memberof StatisticsBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * 
 * @export
 * @interface Term
 */
export interface Term {
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'onset_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'term'?: string;
}
/**
 * 
 * @export
 * @interface Transcript
 */
export interface Transcript {
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Transcript
     */
    'consequences'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'dann_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'dna_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'exon_rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'exon_total'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Transcript
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transcript
     */
    'is_mane_plus'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transcript
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'lrt_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'lrt_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'phyloP17way_primate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'polyphen2_hvar_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'polyphen2_hvar_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'sift_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {VepImpact}
     * @memberof Transcript
     */
    'vep_impact'?: VepImpact;
}


/**
 * 
 * @export
 * @interface UserSet
 */
export interface UserSet {
    /**
     * 
     * @type {boolean}
     * @memberof UserSet
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSet
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface VariantCasesCount
 */
export interface VariantCasesCount {
    /**
     * 
     * @type {number}
     * @memberof VariantCasesCount
     */
    'count_interpretations': number;
    /**
     * 
     * @type {number}
     * @memberof VariantCasesCount
     */
    'count_interpreted_cases': number;
    /**
     * 
     * @type {number}
     * @memberof VariantCasesCount
     */
    'count_total_cases': number;
    /**
     * 
     * @type {number}
     * @memberof VariantCasesCount
     */
    'count_uninterpreted_cases': number;
}
/**
 * 
 * @export
 * @interface VariantCasesFilters
 */
export interface VariantCasesFilters {
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof VariantCasesFilters
     */
    'case_analysis': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof VariantCasesFilters
     */
    'classification': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof VariantCasesFilters
     */
    'performer_lab': Array<Aggregation>;
}
/**
 * 
 * @export
 * @interface VariantConsequence
 */
export interface VariantConsequence {
    /**
     * 
     * @type {string}
     * @memberof VariantConsequence
     */
    'biotype'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantConsequence
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantConsequence
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VariantConsequence
     */
    'is_picked'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VariantConsequence
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantConsequence
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantConsequence
     */
    'symbol'?: string;
    /**
     * 
     * @type {Array<Transcript>}
     * @memberof VariantConsequence
     */
    'transcripts'?: Array<Transcript>;
}
/**
 * 
 * @export
 * @interface VariantExpendedInterpretedCase
 */
export interface VariantExpendedInterpretedCase {
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantExpendedInterpretedCase
     */
    'classification_criterias': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantExpendedInterpretedCase
     */
    'gene_symbol': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantExpendedInterpretedCase
     */
    'inheritances': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantExpendedInterpretedCase
     */
    'interpretation': string;
    /**
     * 
     * @type {string}
     * @memberof VariantExpendedInterpretedCase
     */
    'interpreter_name': string;
    /**
     * 
     * @type {number}
     * @memberof VariantExpendedInterpretedCase
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantExpendedInterpretedCase
     */
    'patient_sex_code': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantExpendedInterpretedCase
     */
    'pubmed_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface VariantHeader
 */
export interface VariantHeader {
    /**
     * 
     * @type {string}
     * @memberof VariantHeader
     */
    'assembly_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantHeader
     */
    'hgvsg': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantHeader
     */
    'source'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VariantInterpretedCase
 */
export interface VariantInterpretedCase {
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'case_analysis_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'case_analysis_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCase
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'classification': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'condition_id': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'condition_name': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'interpretation_updated_on': string;
    /**
     * 
     * @type {Array<Term>}
     * @memberof VariantInterpretedCase
     */
    'observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCase
     */
    'seq_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'transcript_id': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'zygosity': string;
}
/**
 * 
 * @export
 * @interface VariantInterpretedCasesSearchResponse
 */
export interface VariantInterpretedCasesSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCasesSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<VariantInterpretedCase>}
     * @memberof VariantInterpretedCasesSearchResponse
     */
    'list': Array<VariantInterpretedCase>;
}
/**
 * 
 * @export
 * @interface VariantOverview
 */
export interface VariantOverview {
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'clinvar_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'dann_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'dna_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'exon_rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'exon_total'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {boolean}
     * @memberof VariantOverview
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VariantOverview
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'locus': string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'lrt_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'lrt_score'?: number;
    /**
     * 
     * @type {Array<OmimGenePanel>}
     * @memberof VariantOverview
     */
    'omim_conditions'?: Array<OmimGenePanel>;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pc_wgs'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pf_wgs': number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'phyloP17way_primate'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pn_wgs'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'polyphen2_hvar_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'polyphen2_hvar_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'sift_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {VepImpact}
     * @memberof VariantOverview
     */
    'vep_impact'?: VepImpact;
}


/**
 * 
 * @export
 * @interface VariantUninterpretedCase
 */
export interface VariantUninterpretedCase {
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'case_analysis_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'case_analysis_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCase
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'created_on': string;
    /**
     * 
     * @type {Array<Term>}
     * @memberof VariantUninterpretedCase
     */
    'observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'performer_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'performer_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'primary_condition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'primary_condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'updated_on': string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'zygosity': string;
}
/**
 * 
 * @export
 * @interface VariantUninterpretedCasesSearchResponse
 */
export interface VariantUninterpretedCasesSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCasesSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<VariantUninterpretedCase>}
     * @memberof VariantUninterpretedCasesSearchResponse
     */
    'list': Array<VariantUninterpretedCase>;
}
/**
 * TODO
 * @export
 * @enum {string}
 */

export const VepImpact = {
    MODIFIER: 'MODIFIER',
    LOW: 'LOW',
    MODERATE: 'MODERATE',
    HIGH: 'HIGH'
} as const;

export type VepImpact = typeof VepImpact[keyof typeof VepImpact];



/**
 * CasesApi - axios parameter creator
 * @export
 */
export const CasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCases: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('autocompleteCases', 'prefix', prefix)
            const localVarPath = `/cases/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {string} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntity: async (caseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntity', 'caseId', caseId)
            const localVarPath = `/cases/{case_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesFilters: async (filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('casesFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/cases/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCases: async (listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('searchCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/cases/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CasesApi - functional programming interface
 * @export
 */
export const CasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CasesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteCases(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.autocompleteCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {string} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntity(caseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntity(caseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesFilters(filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.casesFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCases(listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.searchCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CasesApi - factory interface
 * @export
 */
export const CasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CasesApiFp(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutocompleteResult>> {
            return localVarFp.autocompleteCases(prefix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {string} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntity(caseId: string, options?: RawAxiosRequestConfig): AxiosPromise<CaseEntity> {
            return localVarFp.caseEntity(caseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<CaseFilters> {
            return localVarFp.casesFilters(filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<CasesSearchResponse> {
            return localVarFp.searchCases(listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CasesApi - object-oriented interface
 * @export
 * @class CasesApi
 * @extends {BaseAPI}
 */
export class CasesApi extends BaseAPI {
    /**
     * Retrieve AutocompleteResult list of ids matching prefix
     * @summary Get AutocompleteResult list of matching prefix
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).autocompleteCases(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve CaseEntity by its ID
     * @summary Get CaseEntity case entity
     * @param {string} caseId Case ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public caseEntity(caseId: string, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntity(caseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve CaseFilters cases filters
     * @summary Get CaseFilters cases filters
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).casesFilters(filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search cases
     * @summary Search cases
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).searchCases(listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HpoApi - axios parameter creator
 * @export
 */
export const HpoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('hpoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/hpo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HpoApi - functional programming interface
 * @export
 */
export const HpoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HpoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hpoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HpoApi.hpoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HpoApi - factory interface
 * @export
 */
export const HpoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HpoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.hpoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HpoApi - object-oriented interface
 * @export
 * @class HpoApi
 * @extends {BaseAPI}
 */
export class HpoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HpoApi
     */
    public hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return HpoApiFp(this.configuration).hpoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InterpretationsApi - axios parameter creator
 * @export
 */
export const InterpretationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation: async (citationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'citationId' is not null or undefined
            assertParamExists('getPubmedCitation', 'citationId', citationId)
            const localVarPath = `/interpretations/pubmed/{citation_id}`
                .replace(`{${"citation_id"}}`, encodeURIComponent(String(citationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline: async (sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationGermline' is not null or undefined
            assertParamExists('postInterpretationGermline', 'interpretationGermline', interpretationGermline)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationGermline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic: async (sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationSomatic' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'interpretationSomatic', interpretationSomatic)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationSomatic, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/germline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/somatic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterpretationsApi - functional programming interface
 * @export
 */
export const InterpretationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InterpretationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationGermline(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationSomatic(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PubmedCitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPubmedCitation(citationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getPubmedCitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationGermline(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterpretationGermline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationGermline(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationSomatic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterpretationSomatic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationSomatic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InterpretationsApi - factory interface
 * @export
 */
export const InterpretationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InterpretationsApiFp(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.getInterpretationGermline(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.getInterpretationSomatic(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): AxiosPromise<PubmedCitation> {
            return localVarFp.getPubmedCitation(citationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline(options?: RawAxiosRequestConfig): AxiosPromise<Array<InterpretationGermline>> {
            return localVarFp.searchInterpretationGermline(options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic(options?: RawAxiosRequestConfig): AxiosPromise<Array<InterpretationSomatic>> {
            return localVarFp.searchInterpretationSomatic(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InterpretationsApi - object-oriented interface
 * @export
 * @class InterpretationsApi
 * @extends {BaseAPI}
 */
export class InterpretationsApi extends BaseAPI {
    /**
     * Get interpretation germline
     * @summary Get interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationGermline(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get interpretation somatic
     * @summary Get interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationSomatic(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pubmed citation by ID
     * @summary Get pubmed citation by ID
     * @param {string} citationId Citation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getPubmedCitation(citationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation germline
     * @summary Create or Update interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationGermline} interpretationGermline Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation somatic
     * @summary Create or Update interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation germline
     * @summary Search interpretation germline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public searchInterpretationGermline(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationGermline(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation somatic
     * @summary Search interpretation somatic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public searchInterpretationSomatic(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationSomatic(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MondoApi - axios parameter creator
 * @export
 */
export const MondoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('mondoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/mondo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MondoApi - functional programming interface
 * @export
 */
export const MondoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MondoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mondoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MondoApi.mondoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MondoApi - factory interface
 * @export
 */
export const MondoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MondoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.mondoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MondoApi - object-oriented interface
 * @export
 * @class MondoApi
 * @extends {BaseAPI}
 */
export class MondoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MondoApi
     */
    public mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return MondoApiFp(this.configuration).mondoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OccurrencesApi - axios parameter creator
 * @export
 */
export const OccurrencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aggregate germline occurrences for a given sequence ID
         * @summary Aggregate germline occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineOccurrences: async (seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('aggregateGermlineOccurrences', 'seqId', seqId)
            // verify required parameter 'aggregationBodyWithSqon' is not null or undefined
            assertParamExists('aggregateGermlineOccurrences', 'aggregationBodyWithSqon', aggregationBodyWithSqon)
            const localVarPath = `/occurrences/germline/{seq_id}/aggregate`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts germline occurrences for a given sequence ID
         * @summary Count germline occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineOccurrences: async (seqId: string, countBodyWithSqon: CountBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('countGermlineOccurrences', 'seqId', seqId)
            // verify required parameter 'countBodyWithSqon' is not null or undefined
            assertParamExists('countGermlineOccurrences', 'countBodyWithSqon', countBodyWithSqon)
            const localVarPath = `/occurrences/germline/{seq_id}/count`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ExpendedOccurrence data for a given locus ID
         * @summary Get a germline ExpendedOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpendedGermlineOccurrence: async (seqId: string, locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getExpendedGermlineOccurrence', 'seqId', seqId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getExpendedGermlineOccurrence', 'locusId', locusId)
            const localVarPath = `/occurrences/germline/{seq_id}/{locus_id}/expended`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List germline occurrences for a given sequence ID
         * @summary List germline occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineOccurrences: async (seqId: string, listBodyWithSqon: ListBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listGermlineOccurrences', 'seqId', seqId)
            // verify required parameter 'listBodyWithSqon' is not null or undefined
            assertParamExists('listGermlineOccurrences', 'listBodyWithSqon', listBodyWithSqon)
            const localVarPath = `/occurrences/germline/{seq_id}/list`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineOccurrences: async (seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('statisticsGermlineOccurrences', 'seqId', seqId)
            // verify required parameter 'statisticsBodyWithSqon' is not null or undefined
            assertParamExists('statisticsGermlineOccurrences', 'statisticsBodyWithSqon', statisticsBodyWithSqon)
            const localVarPath = `/occurrences/germline/{seq_id}/statistics`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticsBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OccurrencesApi - functional programming interface
 * @export
 */
export const OccurrencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OccurrencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Aggregate germline occurrences for a given sequence ID
         * @summary Aggregate germline occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateGermlineOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Aggregation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateGermlineOccurrences(seqId, aggregationBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.aggregateGermlineOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Counts germline occurrences for a given sequence ID
         * @summary Count germline occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countGermlineOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Count>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countGermlineOccurrences(seqId, countBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.countGermlineOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ExpendedOccurrence data for a given locus ID
         * @summary Get a germline ExpendedOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpendedGermlineOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpendedOccurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpendedGermlineOccurrence(seqId, locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.getExpendedGermlineOccurrence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List germline occurrences for a given sequence ID
         * @summary List germline occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGermlineOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Occurrence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGermlineOccurrences(seqId, listBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listGermlineOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsGermlineOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsGermlineOccurrences(seqId, statisticsBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.statisticsGermlineOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OccurrencesApi - factory interface
 * @export
 */
export const OccurrencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OccurrencesApiFp(configuration)
    return {
        /**
         * Aggregate germline occurrences for a given sequence ID
         * @summary Aggregate germline occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<Aggregation>> {
            return localVarFp.aggregateGermlineOccurrences(seqId, aggregationBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts germline occurrences for a given sequence ID
         * @summary Count germline occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Count> {
            return localVarFp.countGermlineOccurrences(seqId, countBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ExpendedOccurrence data for a given locus ID
         * @summary Get a germline ExpendedOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpendedGermlineOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExpendedOccurrence> {
            return localVarFp.getExpendedGermlineOccurrence(seqId, locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * List germline occurrences for a given sequence ID
         * @summary List germline occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<Occurrence>> {
            return localVarFp.listGermlineOccurrences(seqId, listBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Statistics> {
            return localVarFp.statisticsGermlineOccurrences(seqId, statisticsBodyWithSqon, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OccurrencesApi - object-oriented interface
 * @export
 * @class OccurrencesApi
 * @extends {BaseAPI}
 */
export class OccurrencesApi extends BaseAPI {
    /**
     * Aggregate germline occurrences for a given sequence ID
     * @summary Aggregate germline occurrences
     * @param {string} seqId Sequence ID
     * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public aggregateGermlineOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).aggregateGermlineOccurrences(seqId, aggregationBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts germline occurrences for a given sequence ID
     * @summary Count germline occurrences
     * @param {string} seqId Sequence ID
     * @param {CountBodyWithSqon} countBodyWithSqon Count Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public countGermlineOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).countGermlineOccurrences(seqId, countBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ExpendedOccurrence data for a given locus ID
     * @summary Get a germline ExpendedOccurrence
     * @param {string} seqId Sequence ID
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public getExpendedGermlineOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).getExpendedGermlineOccurrence(seqId, locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List germline occurrences for a given sequence ID
     * @summary List germline occurrences
     * @param {string} seqId Sequence ID
     * @param {ListBodyWithSqon} listBodyWithSqon List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public listGermlineOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listGermlineOccurrences(seqId, listBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return statistics about a field for a given sequence ID
     * @summary Statistics of germline occurrences
     * @param {string} seqId Sequence ID
     * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public statisticsGermlineOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).statisticsGermlineOccurrences(seqId, statisticsBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SequencingApi - axios parameter creator
 * @export
 */
export const SequencingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getSequencing', 'seqId', seqId)
            const localVarPath = `/sequencing/{seq_id}`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SequencingApi - functional programming interface
 * @export
 */
export const SequencingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SequencingApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSequencing(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequencing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSequencing(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SequencingApi.getSequencing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SequencingApi - factory interface
 * @export
 */
export const SequencingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SequencingApiFp(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<Sequencing> {
            return localVarFp.getSequencing(seqId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SequencingApi - object-oriented interface
 * @export
 * @class SequencingApi
 * @extends {BaseAPI}
 */
export class SequencingApi extends BaseAPI {
    /**
     * Retrieve Sequencing data for a given sequence ID
     * @summary Get a Sequencing
     * @param {string} seqId Sequence ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SequencingApi
     */
    public getSequencing(seqId: string, options?: RawAxiosRequestConfig) {
        return SequencingApiFp(this.configuration).getSequencing(seqId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Returns the current status of the API
     * @summary Get API status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusGet(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSetsApi - axios parameter creator
 * @export
 */
export const UserSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet: async (userSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSetId' is not null or undefined
            assertParamExists('getUserSet', 'userSetId', userSetId)
            const localVarPath = `/users/sets/{user_set_id}`
                .replace(`{${"user_set_id"}}`, encodeURIComponent(String(userSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSetsApi - functional programming interface
 * @export
 */
export const UserSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSet(userSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSet(userSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSetsApi.getUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserSetsApi - factory interface
 * @export
 */
export const UserSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSetsApiFp(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet(userSetId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSet> {
            return localVarFp.getUserSet(userSetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSetsApi - object-oriented interface
 * @export
 * @class UserSetsApi
 * @extends {BaseAPI}
 */
export class UserSetsApi extends BaseAPI {
    /**
     * Get user set
     * @summary Get user set by id
     * @param {string} userSetId UserSet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSetsApi
     */
    public getUserSet(userSetId: string, options?: RawAxiosRequestConfig) {
        return UserSetsApiFp(this.configuration).getUserSet(userSetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariantApi - axios parameter creator
 * @export
 */
export const VariantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve germline expended interpreted case for a given locus, sequencing and transcript
         * @summary Get expended germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpendedGermlineVariantInterpretedCase: async (locusId: string, seqId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getExpendedGermlineVariantInterpretedCase', 'locusId', locusId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getExpendedGermlineVariantInterpretedCase', 'seqId', seqId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getExpendedGermlineVariantInterpretedCase', 'transcriptId', transcriptId)
            const localVarPath = `/variants/germline/{locus_id}/cases/interpreted/{seq_id}/{transcript_id}`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesCount: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantCasesCount', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/cases/count`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesFilters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variants/germline/cases/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditions: async (locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConditions', 'locusId', locusId)
            // verify required parameter 'panelType' is not null or undefined
            assertParamExists('getGermlineVariantConditions', 'panelType', panelType)
            const localVarPath = `/variants/germline/{locus_id}/conditions/{panel_type}`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"panel_type"}}`, encodeURIComponent(String(panelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditionsClinvar: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConditionsClinvar', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/conditions/clinvar`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConsequences: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConsequences', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/consequences`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantHeader: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantHeader', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/header`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantInterpretedCases: async (locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantInterpretedCases', 'locusId', locusId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('getGermlineVariantInterpretedCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/variants/germline/{locus_id}/cases/interpreted`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantOverview: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantOverview', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/overview`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantUninterpretedCases: async (locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantUninterpretedCases', 'locusId', locusId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('getGermlineVariantUninterpretedCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/variants/germline/{locus_id}/cases/uninterpreted`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariantApi - functional programming interface
 * @export
 */
export const VariantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariantApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve germline expended interpreted case for a given locus, sequencing and transcript
         * @summary Get expended germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpendedGermlineVariantInterpretedCase(locusId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantExpendedInterpretedCase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpendedGermlineVariantInterpretedCase(locusId, seqId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getExpendedGermlineVariantInterpretedCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantCasesCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantCasesCount(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantCasesCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantCasesFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantCasesFilters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantCasesFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantCasesFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConditions(locusId, panelType, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConditions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClinvarRCV>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConditionsClinvar(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConditionsClinvar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariantConsequence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConsequences(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConsequences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantHeader(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantHeader']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantInterpretedCasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantInterpretedCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantOverview(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantUninterpretedCasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantUninterpretedCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariantApi - factory interface
 * @export
 */
export const VariantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariantApiFp(configuration)
    return {
        /**
         * Retrieve germline expended interpreted case for a given locus, sequencing and transcript
         * @summary Get expended germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpendedGermlineVariantInterpretedCase(locusId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantExpendedInterpretedCase> {
            return localVarFp.getExpendedGermlineVariantInterpretedCase(locusId, seqId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantCasesCount> {
            return localVarFp.getGermlineVariantCasesCount(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig): AxiosPromise<VariantCasesFilters> {
            return localVarFp.getGermlineVariantCasesFilters(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantCasesFilters> {
            return localVarFp.getGermlineVariantConditions(locusId, panelType, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClinvarRCV> {
            return localVarFp.getGermlineVariantConditionsClinvar(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariantConsequence>> {
            return localVarFp.getGermlineVariantConsequences(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantHeader> {
            return localVarFp.getGermlineVariantHeader(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<VariantInterpretedCasesSearchResponse> {
            return localVarFp.getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantOverview> {
            return localVarFp.getGermlineVariantOverview(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<VariantUninterpretedCasesSearchResponse> {
            return localVarFp.getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariantApi - object-oriented interface
 * @export
 * @class VariantApi
 * @extends {BaseAPI}
 */
export class VariantApi extends BaseAPI {
    /**
     * Retrieve germline expended interpreted case for a given locus, sequencing and transcript
     * @summary Get expended germline interpreted case for a given locus, sequencing and transcript
     * @param {string} locusId Locus ID
     * @param {string} seqId Seq ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getExpendedGermlineVariantInterpretedCase(locusId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getExpendedGermlineVariantInterpretedCase(locusId, seqId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve cases count for a given locus id
     * @summary Get germline cases count for a given locus
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantCasesCount(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve cases filters for germline variant entity
     * @summary Get cases filters for germline variant entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantCasesFilters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve conditions for germline variant entity for a specific gene panel
     * @summary Get conditions for germline variant entity for a specific gene panel
     * @param {string} locusId Locus ID
     * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
     * @param {string} [filter] Condition filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConditions(locusId, panelType, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ClinVar conditions for germline variant entity
     * @summary Get ClinVar conditions for germline variant entity
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConditionsClinvar(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Consequences for a given locus
     * @summary Get list of VariantConsequences for a germline variant
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConsequences(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Header data for a given locus
     * @summary Get a germline VariantHeader
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantHeader(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Germline Variant interpreted cases for a given locus
     * @summary Get list of interpreted Cases for a germline variant
     * @param {string} locusId Locus ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Overview data for a given locus
     * @summary Get a germline VariantOverview
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantOverview(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Germline Variant uninterpreted cases for a given locus
     * @summary Get list of uninterpreted Cases for a germline variant
     * @param {string} locusId Locus ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetGermlineVariantConditionsPanelTypeEnum = {
    Omim: 'omim',
    Hpo: 'hpo',
    Orphanet: 'orphanet'
} as const;
export type GetGermlineVariantConditionsPanelTypeEnum = typeof GetGermlineVariantConditionsPanelTypeEnum[keyof typeof GetGermlineVariantConditionsPanelTypeEnum];



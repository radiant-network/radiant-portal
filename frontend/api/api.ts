/* tslint:disable */
/* eslint-disable */
/**
 * Radiant API
 * This is the API for Radiant data platform.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Aggregation represents an aggregation result
 */
export interface Aggregation {
    /**
     * Count in the bucket
     */
    'count'?: number;
    /**
     * Bucket key
     */
    'key'?: string;
    /**
     * Label corresponding to the key
     */
    'label'?: string;
}
export interface AggregationBodyWithSqon {
    'field'?: string;
    'size'?: number;
    'sqon'?: Sqon;
}
/**
 * ApiError represents an error
 */
export interface ApiError {
    'detail'?: any;
    'message': string;
    'status': number;
}
export interface Assay {
    'aliquot'?: string;
    'capture_kit'?: string;
    'category_code'?: string;
    'created_on'?: string;
    'experiment_description'?: string;
    'experimental_strategy_code'?: string;
    'experimental_strategy_name'?: string;
    'histology_code'?: string;
    'is_paired_end': boolean;
    'performer_lab_code'?: string;
    'performer_lab_name'?: string;
    'platform_code'?: string;
    'read_length'?: number;
    'request_id'?: number;
    'run_alias'?: string;
    'run_date'?: string;
    'run_name'?: string;
    'sample_id'?: number;
    'sample_type_code'?: string;
    'seq_id'?: number;
    'status_code'?: string;
    'submitter_sample_id'?: string;
    'tissue_site'?: string;
    'updated_on'?: string;
}
export interface AutoCompleteGene {
    'highlight'?: Term;
    'source'?: Term;
}
export interface AutoCompleteTerm {
    'highlight'?: Term;
    'source'?: Term;
}
export interface AutocompleteResult {
    'type': string;
    'value': string;
}
/**
 * CNVGeneOverlap represents a gene overlap with a CNV
 */
export interface CNVGeneOverlap {
    'cytoband': Array<string>;
    'gene_id': string;
    'gene_length': number;
    'nb_exons': number;
    'nb_overlap_bases': number;
    'overlap_type': string;
    'overlapping_cnv_percent': number;
    'overlapping_gene_percent': number;
    'symbol': string;
}
/**
 * Assay to display in a Case
 */
export interface CaseAssay {
    'affected_status_code': string;
    'experimental_strategy_code': string;
    'has_variants': boolean;
    'histology_code'?: string;
    'patient_id': number;
    'relationship_to_proband': string;
    'request_id'?: number;
    'sample_id': number;
    'sample_submitter_id'?: string;
    'sample_type_code'?: string;
    'seq_id': number;
    'status_code': string;
    'updated_on': string;
}
/**
 * Data for Case Entity Page
 */
export interface CaseEntity {
    'assays': Array<CaseAssay>;
    'case_analysis_code'?: string;
    'case_analysis_name'?: string;
    'case_id': number;
    'case_type'?: string;
    'created_on': string;
    'members': Array<CasePatientClinicalInformation>;
    'note'?: string;
    'performer_lab_code'?: string;
    'performer_lab_name'?: string;
    'prescriber'?: string;
    'primary_condition_id'?: string;
    'primary_condition_name'?: string;
    'priority_code'?: string;
    'project_code'?: string;
    'project_name'?: string;
    'request_id'?: number;
    'requested_by_code'?: string;
    'requested_by_name'?: string;
    'status_code': string;
    'tasks': Array<CaseTask>;
    'updated_on': string;
}
export interface CaseFilters {
    'case_analysis': Array<Aggregation>;
    'performer_lab': Array<Aggregation>;
    'priority': Array<Aggregation>;
    'project': Array<Aggregation>;
    'requested_by': Array<Aggregation>;
    'status': Array<Aggregation>;
}
/**
 * Patient clinical information to display in Case Entity
 */
export interface CasePatientClinicalInformation {
    'affected_status_code': string;
    'date_of_birth'?: string;
    /**
     * TODO
     */
    'ethnicity_codes'?: Array<string>;
    'managing_organization_code'?: string;
    'managing_organization_name'?: string;
    'mrn'?: string;
    'non_observed_phenotypes'?: Array<Term>;
    'observed_phenotypes'?: Array<Term>;
    'patient_id': number;
    'relationship_to_proband': string;
    'sex_code': string;
}
/**
 * Line represented a case in case list
 */
export interface CaseResult {
    'case_analysis_code'?: string;
    'case_analysis_name'?: string;
    'case_id': number;
    'case_type'?: string;
    'created_on': string;
    'has_variants': boolean;
    'managing_organization_code'?: string;
    'managing_organization_name'?: string;
    'performer_lab_code'?: string;
    'performer_lab_name'?: string;
    'prescriber'?: string;
    'primary_condition_id'?: string;
    'primary_condition_name'?: string;
    'priority_code'?: string;
    'proband_id'?: number;
    'proband_mrn'?: string;
    'project_code'?: string;
    'project_name'?: string;
    'request_id'?: number;
    'requested_by_code'?: string;
    'requested_by_name'?: string;
    'status_code': string;
    'updated_on': string;
}
export interface CaseTask {
    'created_on': string;
    'id': number;
    'patients': Array<string>;
    'type_code': string;
    'type_name': string;
}
export interface CasesSearchResponse {
    'count': number;
    'list': Array<CaseResult>;
}
/**
 * ClinvarRCV represents a Reference ClinVar record - data aggregated by variant-condition pair
 */
export interface ClinvarRCV {
    'accession'?: string;
    'clinical_significance'?: Array<string>;
    'clinvar_id': string;
    'date_last_evaluated'?: string;
    'locus_id': string;
    'origins'?: Array<string>;
    'review_status'?: string;
    'review_status_stars'?: number;
    'submission_count'?: number;
    'traits'?: Array<string>;
    'version'?: number;
}
export interface ColumnPinningConfig {
    'left'?: Array<string>;
    'right'?: Array<string>;
}
/**
 * Count represents count result
 */
export interface Count {
    /**
     * Number of results
     */
    'count'?: number;
}
export interface CountBodyWithSqon {
    'sqon'?: Sqon;
}
export interface DocumentFilters {
    'data_type': Array<Aggregation>;
    'format': Array<Aggregation>;
    'performer_lab'?: Array<Aggregation>;
    'project'?: Array<Aggregation>;
    'relationship_to_proband': Array<Aggregation>;
}
export interface DocumentResult {
    'case_id': number;
    'created_on': string;
    'data_type_code': string;
    'document_id': number;
    'format_code': string;
    'hash'?: string;
    'name': string;
    'patient_id': number;
    'performer_lab_code'?: string;
    'performer_lab_name'?: string;
    'relationship_to_proband_code': string;
    'run_alias'?: string;
    'seq_id'?: number;
    'size': number;
    'submitter_sample_id'?: string;
    'task_id': number;
}
export interface DocumentsSearchResponse {
    'count': number;
    'list': Array<DocumentResult>;
}
export interface ExpandedGermlineSNVOccurrence {
    'aa_change'?: string;
    'ad_alt'?: number;
    'ad_total'?: number;
    /**
     * TODO
     */
    'af'?: number;
    'cadd_phred'?: number;
    'cadd_score'?: number;
    'case_id': number;
    'chromosome'?: string;
    'clinvar'?: Array<string>;
    'dann_score'?: number;
    'dna_change'?: string;
    'end'?: number;
    'exomiser_acmg_classification'?: string;
    'exomiser_acmg_classification_counts'?: { [key: string]: number; };
    'exomiser_acmg_evidence': Array<string>;
    'exomiser_gene_combined_score': number;
    'exon_rank'?: number;
    'exon_total'?: number;
    'father_calls'?: Array<number>;
    'fathmm_pred'?: string;
    'fathmm_score'?: number;
    'filter'?: string;
    'genotype_quality': number;
    'gnomad_loeuf'?: number;
    'gnomad_pli'?: number;
    'gnomad_v3_af': number;
    'hgvsg': string;
    'interpretation_classification'?: string;
    'interpretation_classification_counts'?: { [key: string]: number; };
    'is_canonical'?: boolean;
    'is_mane_plus'?: boolean;
    'is_mane_select'?: boolean;
    'locus': string;
    'locus_id': string;
    'mother_calls'?: Array<number>;
    'omim_conditions'?: Array<OmimGenePanel>;
    'parental_origin'?: string;
    'pc_wgs_affected'?: number;
    'pc_wgs_not_affected'?: number;
    'pf_wgs'?: number;
    'pf_wgs_affected'?: number;
    'pf_wgs_not_affected'?: number;
    'picked_consequences': Array<string>;
    'pn_wgs_affected'?: number;
    'pn_wgs_not_affected'?: number;
    'qd'?: number;
    'revel_score'?: number;
    'rsnumber'?: string;
    'sift_pred'?: string;
    'sift_score'?: number;
    'spliceai_ds'?: number;
    'spliceai_type'?: Array<string>;
    'start'?: number;
    'symbol'?: string;
    'transcript_id'?: string;
    'transmission'?: string;
    'vep_impact'?: VepImpact;
    'zygosity'?: string;
}


export interface Facet {
    'name'?: string;
    'values'?: Array<string>;
}
export interface FiltersBodyWithCriteria {
    'search_criteria'?: Array<SearchCriterion>;
}
export interface GenePanelCondition {
    'inheritance_code'?: Array<string>;
    'panel_id'?: string;
    'panel_name': string;
}
export interface GenePanelConditions {
    'conditions': { [key: string]: Array<GenePanelCondition>; };
    'count_hpo': number;
    'count_omim': number;
    'count_orphanet': number;
}
/**
 * GermlineCNVOccurrence represents a germline CNV occurrence
 */
export interface GermlineCNVOccurrence {
    'aliquot'?: string;
    'bc'?: number;
    'calls'?: Array<number>;
    'chromosome': string;
    'ciend'?: Array<number>;
    'cipos'?: Array<number>;
    'cn'?: number;
    'cnv_id': string;
    'cytoband'?: Array<string>;
    'end': number;
    'filter'?: string;
    'gnomad_sc'?: number;
    'gnomad_sf'?: number;
    'gnomad_sn'?: number;
    'length': number;
    'name': string;
    'nb_genes'?: number;
    'nb_snv'?: number;
    'pe'?: Array<number>;
    'quality'?: number;
    'reflen'?: number;
    'seq_id': number;
    'sm'?: number;
    'start': number;
    'svlen'?: number;
    'svtype'?: string;
    'symbol'?: Array<string>;
    'type': string;
}
/**
 * GermlineSNVOccurrence represents a germline SNV occurrence
 */
export interface GermlineSNVOccurrence {
    'aa_change'?: string;
    'ad_ratio': number;
    'chromosome': string;
    'clinvar'?: Array<string>;
    'exomiser_acmg_classification': string;
    'exomiser_acmg_evidence': Array<string>;
    'exomiser_gene_combined_score': number;
    'exomiser_moi': string;
    'exomiser_variant_score': number;
    'filter'?: string;
    'genotype_quality': number;
    'gnomad_v3_af': number;
    'has_interpretation': boolean;
    'hgvsg': string;
    'is_canonical'?: boolean;
    'is_mane_plus'?: boolean;
    'is_mane_select'?: boolean;
    'locus': string;
    'locus_id': string;
    'max_impact_score': number;
    'omim_inheritance_code'?: Array<string>;
    'pc_wgs'?: number;
    'pf_wgs': number;
    'picked_consequences': Array<string>;
    'pn_wgs'?: number;
    'rsnumber'?: string;
    'seq_id': number;
    'start': number;
    'symbol'?: string;
    'task_id': number;
    'transcript_id'?: string;
    'variant_class': string;
    'vep_impact'?: VepImpact;
    'zygosity': string;
}


export interface IGVTrackEnriched {
    'family_role'?: string;
    'format'?: string;
    'indexURL'?: string;
    'indexURLExpireAt'?: number;
    'name'?: string;
    'patient_id'?: number;
    'sex'?: string;
    'type'?: string;
    'url'?: string;
    'urlExpireAt'?: number;
}
export interface IGVTracks {
    'alignment'?: Array<IGVTrackEnriched>;
}
export interface InterpretationGermline {
    'classification'?: string;
    'classification_criterias'?: Array<string>;
    'condition'?: string;
    'created_at'?: string;
    'created_by'?: string;
    'created_by_name'?: string;
    'id'?: string;
    'interpretation'?: string;
    'locus_id'?: string;
    'metadata'?: InterpretationMetadata;
    'pubmed'?: Array<InterpretationPubmed>;
    'sequencing_id'?: string;
    'transcript_id'?: string;
    'transmission_modes'?: Array<string>;
    'updated_at'?: string;
    'updated_by'?: string;
    'updated_by_name'?: string;
}
export interface InterpretationMetadata {
    'analysis_id'?: string;
    'patient_id'?: string;
    'variant_hash'?: string;
}
export interface InterpretationPubmed {
    'citation'?: string;
    'citation_id'?: string;
}
export interface InterpretationSomatic {
    'clinical_utility'?: string;
    'created_at'?: string;
    'created_by'?: string;
    'created_by_name'?: string;
    'id'?: string;
    'interpretation'?: string;
    'locus_id'?: string;
    'metadata'?: InterpretationMetadata;
    'oncogenicity'?: string;
    'oncogenicity_classification_criterias'?: Array<string>;
    'pubmed'?: Array<InterpretationPubmed>;
    'sequencing_id'?: string;
    'transcript_id'?: string;
    'tumoral_type'?: string;
    'updated_at'?: string;
    'updated_by'?: string;
    'updated_by_name'?: string;
}
export interface LeafContent {
    'field'?: string;
    'value'?: Array<any>;
}
/**
 * Body of a list request with search criteria
 */
export interface ListBodyWithCriteria {
    'additional_fields'?: Array<string>;
    'limit'?: number;
    'offset'?: number;
    'page_index'?: number;
    'search_criteria'?: Array<SearchCriterion>;
    'sort'?: Array<SortBody>;
}
/**
 * Body of a list request
 */
export interface ListBodyWithSqon {
    'additional_fields'?: Array<string>;
    'limit'?: number;
    'offset'?: number;
    'page_index'?: number;
    'sort'?: Array<SortBody>;
    'sqon'?: Sqon;
}
export interface OmimGenePanel {
    'inheritance_code'?: Array<string>;
    'omim_phenotype_id'?: string;
    'panel'?: string;
}
export interface PaginationConfig {
    'pageSize'?: number;
}
export interface PubmedCitation {
    'id'?: string;
    'nlm'?: PubmedCitationDetails;
}
export interface PubmedCitationDetails {
    'format'?: string;
}
export interface SavedFilter {
    'created_on': string;
    'favorite': boolean;
    'id': string;
    'name': string;
    'queries': Array<Sqon>;
    'type': SavedFilterType;
    'updated_on': string;
    'user_id': string;
}


export interface SavedFilterCreationInput {
    'name': string;
    'queries': Array<Sqon>;
    'type': SavedFilterType;
}



export const SavedFilterType = {
    GERMLINE_SNV_OCCURRENCE: 'germline_snv_occurrence',
    GERMLINE_CNV_OCCURRENCE: 'germline_cnv_occurrence',
    SOMATIC_SNV_OCCURRENCE: 'somatic_snv_occurrence',
    SOMATIC_CNV_OCCURRENCE: 'somatic_cnv_occurrence',
    GERMLINE_SNV_VARIANT: 'germline_snv_variant',
    GERMLINE_CNV_VARIANT: 'germline_cnv_variant',
    SOMATIC_SNV_VARIANT: 'somatic_snv_variant',
    SOMATIC_CNV_VARIANT: 'somatic_cnv_variant'
} as const;

export type SavedFilterType = typeof SavedFilterType[keyof typeof SavedFilterType];


export interface SavedFilterUpdateInput {
    'favorite': boolean;
    'name': string;
    'queries': Array<Sqon>;
}
export interface SearchCriterion {
    'field'?: string;
    'operator'?: string;
    'value'?: Array<any>;
}
/**
 * Sequencing represents a sequencing
 */
export interface Sequencing {
    'affected_status'?: string;
    'analysis_type'?: string;
    'case_id'?: number;
    'created_at'?: string;
    'experimental_strategy'?: string;
    'family_role'?: string;
    'part'?: number;
    'patient_id'?: number;
    'request_id'?: number;
    'request_priority'?: string;
    'sample_id'?: number;
    'seq_id'?: number;
    'sex'?: string;
    'task_id'?: number;
    'updated_at'?: string;
    'vcf_filepath'?: string;
}
export interface SortBody {
    'field'?: string;
    'order'?: SortBodyOrderEnum;
}

export const SortBodyOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortBodyOrderEnum = typeof SortBodyOrderEnum[keyof typeof SortBodyOrderEnum];

export interface Sqon {
    'content'?: SqonContent;
    'id'?: string;
    'op'?: SqonOpEnum;
}

export const SqonOpEnum = {
    In: 'in',
    And: 'and',
    Or: 'or',
    Not: 'not',
    Between: 'between',
    GreaterThan: '>',
    LessThan: '<',
    GreaterThanOrEqualTo: '>=',
    LessThanOrEqualTo: '<=',
    NotIn: 'not-in',
    All: 'all'
} as const;

export type SqonOpEnum = typeof SqonOpEnum[keyof typeof SqonOpEnum];

/**
 * @type SqonContent
 */
export type SqonContent = Array<Sqon> | LeafContent;

/**
 * Statistics represents statistics about a column
 */
export interface Statistics {
    /**
     * Max for numeric facet
     */
    'max'?: number;
    /**
     * Min for numeric facet
     */
    'min'?: number;
    /**
     * To tell UI if it\'s an integer or a decimal
     */
    'type'?: string;
}
export interface StatisticsBodyWithSqon {
    'field'?: string;
    'sqon'?: Sqon;
}
export interface TableConfig {
    'columnOrder'?: Array<string>;
    'columnPinning'?: ColumnPinningConfig;
    'columnSizing'?: { [key: string]: number; };
    'columnVisibility'?: { [key: string]: boolean; };
    'pagination'?: PaginationConfig;
}
export interface Term {
    'id'?: string;
    'name'?: string;
    'onset_code'?: string;
    'term'?: string;
}
export interface Transcript {
    'aa_change'?: string;
    'cadd_phred'?: number;
    'cadd_score'?: number;
    'consequences'?: Array<string>;
    'dann_score'?: number;
    'dna_change'?: string;
    'exon_rank'?: number;
    'exon_total'?: number;
    'fathmm_pred'?: string;
    'fathmm_score'?: number;
    'is_canonical'?: boolean;
    'is_mane_plus'?: boolean;
    'is_mane_select'?: boolean;
    'lrt_pred'?: string;
    'lrt_score'?: number;
    'phyloP17way_primate'?: number;
    'polyphen2_hvar_pred'?: string;
    'polyphen2_hvar_score'?: number;
    'revel_score'?: number;
    'sift_pred'?: string;
    'sift_score'?: number;
    'transcript_id'?: string;
    'vep_impact'?: VepImpact;
}


export interface UserPreference {
    'table_display': { [key: string]: TableConfig; };
    'user_id': string;
}
export interface UserSet {
    'active'?: boolean;
    'id'?: string;
    'ids'?: Array<string>;
    'name'?: string;
    'type'?: string;
    'updated_at'?: string;
    'user_id'?: string;
}
export interface VariantCasesCount {
    'count_interpreted': number;
    'count_uninterpreted': number;
}
export interface VariantCasesFilters {
    'case_analysis': Array<Aggregation>;
    'classification': Array<Aggregation>;
    'performer_lab': Array<Aggregation>;
}
export interface VariantConsequence {
    'biotype'?: string;
    'gnomad_loeuf'?: number;
    'gnomad_pli'?: number;
    'is_picked'?: boolean;
    'spliceai_ds'?: number;
    'spliceai_type'?: Array<string>;
    'symbol'?: string;
    'transcripts'?: Array<Transcript>;
}
export interface VariantExpandedInterpretedCase {
    'classification_criterias': Array<string>;
    'gene_symbol': string;
    'inheritances': Array<string>;
    'interpretation': string;
    'interpreter_name': string;
    'patient_id': number;
    'patient_sex_code': string;
    'pubmed_ids': Array<string>;
}
export interface VariantHeader {
    'assembly_version'?: string;
    'hgvsg': string;
    'source'?: Array<string>;
}
export interface VariantInterpretedCase {
    'affected_status'?: string;
    'case_analysis_code'?: string;
    'case_analysis_name'?: string;
    'case_id': number;
    'classification': string;
    'condition_id': string;
    'condition_name': string;
    'interpretation_updated_on': string;
    'observed_phenotypes'?: Array<Term>;
    'patient_id': number;
    'performer_lab_code'?: string;
    'performer_lab_name'?: string;
    'relationship_to_proband'?: string;
    'seq_id': number;
    'status_code': string;
    'submitter_sample_id'?: string;
    'transcript_id': string;
    'zygosity': string;
}
export interface VariantInterpretedCasesSearchResponse {
    'count': number;
    'list': Array<VariantInterpretedCase>;
}
export interface VariantOverview {
    'aa_change'?: string;
    'cadd_phred'?: number;
    'cadd_score'?: number;
    'clinvar'?: Array<string>;
    'clinvar_name'?: string;
    'dann_score'?: number;
    'dna_change'?: string;
    'exomiser_acmg_classification_counts'?: { [key: string]: number; };
    'exon_rank'?: number;
    'exon_total'?: number;
    'fathmm_pred'?: string;
    'fathmm_score'?: number;
    'gnomad_loeuf'?: number;
    'gnomad_pli'?: number;
    'gnomad_v3_af': number;
    'interpretation_classification_counts'?: { [key: string]: number; };
    'is_canonical': boolean;
    'is_mane_plus': boolean;
    'is_mane_select': boolean;
    'locus': string;
    'lrt_pred'?: string;
    'lrt_score'?: number;
    'omim_conditions'?: Array<OmimGenePanel>;
    'pc_wgs'?: number;
    'pf_wgs': number;
    'phyloP17way_primate'?: number;
    'picked_consequences': Array<string>;
    'pn_wgs'?: number;
    'polyphen2_hvar_pred'?: string;
    'polyphen2_hvar_score'?: number;
    'revel_score'?: number;
    'rsnumber'?: string;
    'sift_pred'?: string;
    'sift_score'?: number;
    'spliceai_ds'?: number;
    'spliceai_type'?: Array<string>;
    'symbol'?: string;
    'transcript_id'?: string;
    'vep_impact'?: VepImpact;
}


export interface VariantUninterpretedCase {
    'affected_status'?: string;
    'case_analysis_code'?: string;
    'case_analysis_name'?: string;
    'case_id': number;
    'created_on': string;
    'exomiser_acmg_classification'?: string;
    'exomiser_acmg_evidence'?: Array<string>;
    'observed_phenotypes'?: Array<Term>;
    'patient_id': number;
    'performer_lab_code'?: string;
    'performer_lab_name'?: string;
    'primary_condition_id'?: string;
    'primary_condition_name'?: string;
    'relationship_to_proband'?: string;
    'seq_id': number;
    'status_code': string;
    'submitter_sample_id'?: string;
    'updated_on': string;
    'zygosity': string;
}
export interface VariantUninterpretedCasesSearchResponse {
    'count': number;
    'list': Array<VariantUninterpretedCase>;
}
/**
 * TODO
 */

export const VepImpact = {
    MODIFIER: 'MODIFIER',
    LOW: 'LOW',
    MODERATE: 'MODERATE',
    HIGH: 'HIGH'
} as const;

export type VepImpact = typeof VepImpact[keyof typeof VepImpact];



/**
 * AssaysApi - axios parameter creator
 */
export const AssaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Assay by seq_id
         * @summary Get Assay by seq_id
         * @param {string} seqId Seq ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssayBySeqId: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getAssayBySeqId', 'seqId', seqId)
            const localVarPath = `/assays/{seq_id}`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssaysApi - functional programming interface
 */
export const AssaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssaysApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Assay by seq_id
         * @summary Get Assay by seq_id
         * @param {string} seqId Seq ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssayBySeqId(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssayBySeqId(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssaysApi.getAssayBySeqId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssaysApi - factory interface
 */
export const AssaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssaysApiFp(configuration)
    return {
        /**
         * Get Assay by seq_id
         * @summary Get Assay by seq_id
         * @param {string} seqId Seq ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssayBySeqId(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<Assay> {
            return localVarFp.getAssayBySeqId(seqId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssaysApi - object-oriented interface
 */
export class AssaysApi extends BaseAPI {
    /**
     * Get Assay by seq_id
     * @summary Get Assay by seq_id
     * @param {string} seqId Seq ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAssayBySeqId(seqId: string, options?: RawAxiosRequestConfig) {
        return AssaysApiFp(this.configuration).getAssayBySeqId(seqId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CasesApi - axios parameter creator
 */
export const CasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCases: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('autocompleteCases', 'prefix', prefix)
            const localVarPath = `/cases/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {number} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntity: async (caseId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntity', 'caseId', caseId)
            const localVarPath = `/cases/{case_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve DocumentFilters documents filters for a specific case
         * @summary Get DocumentFilters documents filters for a specific case
         * @param {string} caseId Case ID
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsFilters: async (caseId: string, filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntityDocumentsFilters', 'caseId', caseId)
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('caseEntityDocumentsFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/cases/{case_id}/documents/filters`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for DocumentResult list for a case entity
         * @summary Search DocumentResult list for a case entity
         * @param {string} caseId Case ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsSearch: async (caseId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntityDocumentsSearch', 'caseId', caseId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('caseEntityDocumentsSearch', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/cases/{case_id}/documents/search`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesFilters: async (filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('casesFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/cases/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCases: async (listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('searchCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/cases/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CasesApi - functional programming interface
 */
export const CasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CasesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteCases(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.autocompleteCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {number} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntity(caseId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntity(caseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve DocumentFilters documents filters for a specific case
         * @summary Get DocumentFilters documents filters for a specific case
         * @param {string} caseId Case ID
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntityDocumentsFilters(caseId: string, filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntityDocumentsFilters(caseId, filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntityDocumentsFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for DocumentResult list for a case entity
         * @summary Search DocumentResult list for a case entity
         * @param {string} caseId Case ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntityDocumentsSearch(caseId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntityDocumentsSearch(caseId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntityDocumentsSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesFilters(filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.casesFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCases(listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.searchCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CasesApi - factory interface
 */
export const CasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CasesApiFp(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutocompleteResult>> {
            return localVarFp.autocompleteCases(prefix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {number} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntity(caseId: number, options?: RawAxiosRequestConfig): AxiosPromise<CaseEntity> {
            return localVarFp.caseEntity(caseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve DocumentFilters documents filters for a specific case
         * @summary Get DocumentFilters documents filters for a specific case
         * @param {string} caseId Case ID
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsFilters(caseId: string, filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFilters> {
            return localVarFp.caseEntityDocumentsFilters(caseId, filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for DocumentResult list for a case entity
         * @summary Search DocumentResult list for a case entity
         * @param {string} caseId Case ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsSearch(caseId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsSearchResponse> {
            return localVarFp.caseEntityDocumentsSearch(caseId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<CaseFilters> {
            return localVarFp.casesFilters(filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<CasesSearchResponse> {
            return localVarFp.searchCases(listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CasesApi - object-oriented interface
 */
export class CasesApi extends BaseAPI {
    /**
     * Retrieve AutocompleteResult list of ids matching prefix
     * @summary Get AutocompleteResult list of matching prefix
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).autocompleteCases(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve CaseEntity by its ID
     * @summary Get CaseEntity case entity
     * @param {number} caseId Case ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caseEntity(caseId: number, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntity(caseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve DocumentFilters documents filters for a specific case
     * @summary Get DocumentFilters documents filters for a specific case
     * @param {string} caseId Case ID
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caseEntityDocumentsFilters(caseId: string, filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntityDocumentsFilters(caseId, filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for DocumentResult list for a case entity
     * @summary Search DocumentResult list for a case entity
     * @param {string} caseId Case ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caseEntityDocumentsSearch(caseId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntityDocumentsSearch(caseId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve CaseFilters cases filters
     * @summary Get CaseFilters cases filters
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).casesFilters(filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search cases
     * @summary Search cases
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).searchCases(listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteDocuments: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('autocompleteDocuments', 'prefix', prefix)
            const localVarPath = `/documents/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve DocumentFilters documents filters
         * @summary Get DocumentFilters documents filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilters: async (filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('documentsFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/documents/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search documents
         * @summary Search documents
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments: async (listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('searchDocuments', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/documents/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteDocuments(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteDocuments(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.autocompleteDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve DocumentFilters documents filters
         * @summary Get DocumentFilters documents filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilters(filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search documents
         * @summary Search documents
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocuments(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDocuments(listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteDocuments(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutocompleteResult>> {
            return localVarFp.autocompleteDocuments(prefix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve DocumentFilters documents filters
         * @summary Get DocumentFilters documents filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFilters> {
            return localVarFp.documentsFilters(filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Search documents
         * @summary Search documents
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsSearchResponse> {
            return localVarFp.searchDocuments(listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Retrieve AutocompleteResult list of ids matching prefix
     * @summary Get AutocompleteResult list of matching prefix
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public autocompleteDocuments(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).autocompleteDocuments(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve DocumentFilters documents filters
     * @summary Get DocumentFilters documents filters
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentsFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilters(filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search documents
     * @summary Search documents
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchDocuments(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchDocuments(listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GenesApi - axios parameter creator
 */
export const GenesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteGene list of genes matching input string with highlighted
         * @summary Get AutoCompleteGene list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('geneAutoComplete', 'prefix', prefix)
            const localVarPath = `/genes/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenesApi - functional programming interface
 */
export const GenesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteGene list of genes matching input string with highlighted
         * @summary Get AutoCompleteGene list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteGene>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenesApi.geneAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GenesApi - factory interface
 */
export const GenesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenesApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteGene list of genes matching input string with highlighted
         * @summary Get AutoCompleteGene list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteGene>> {
            return localVarFp.geneAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenesApi - object-oriented interface
 */
export class GenesApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteGene list of genes matching input string with highlighted
     * @summary Get AutoCompleteGene list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public geneAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return GenesApiFp(this.configuration).geneAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HpoApi - axios parameter creator
 */
export const HpoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('hpoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/hpo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HpoApi - functional programming interface
 */
export const HpoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HpoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hpoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HpoApi.hpoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HpoApi - factory interface
 */
export const HpoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HpoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.hpoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HpoApi - object-oriented interface
 */
export class HpoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return HpoApiFp(this.configuration).hpoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IgvApi - axios parameter creator
 */
export const IgvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get IGV tracks for a sequencing experiment
         * @summary Get IGV
         * @param {string} seqId Sequencing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIGV: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getIGV', 'seqId', seqId)
            const localVarPath = `/igv/{seq_id}`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IgvApi - functional programming interface
 */
export const IgvApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IgvApiAxiosParamCreator(configuration)
    return {
        /**
         * Get IGV tracks for a sequencing experiment
         * @summary Get IGV
         * @param {string} seqId Sequencing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIGV(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IGVTracks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIGV(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IgvApi.getIGV']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IgvApi - factory interface
 */
export const IgvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IgvApiFp(configuration)
    return {
        /**
         * Get IGV tracks for a sequencing experiment
         * @summary Get IGV
         * @param {string} seqId Sequencing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIGV(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<IGVTracks> {
            return localVarFp.getIGV(seqId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IgvApi - object-oriented interface
 */
export class IgvApi extends BaseAPI {
    /**
     * Get IGV tracks for a sequencing experiment
     * @summary Get IGV
     * @param {string} seqId Sequencing ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIGV(seqId: string, options?: RawAxiosRequestConfig) {
        return IgvApiFp(this.configuration).getIGV(seqId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InterpretationsApi - axios parameter creator
 */
export const InterpretationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation: async (citationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'citationId' is not null or undefined
            assertParamExists('getPubmedCitation', 'citationId', citationId)
            const localVarPath = `/interpretations/pubmed/{citation_id}`
                .replace(`{${"citation_id"}}`, encodeURIComponent(String(citationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline: async (sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationGermline' is not null or undefined
            assertParamExists('postInterpretationGermline', 'interpretationGermline', interpretationGermline)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationGermline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic: async (sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationSomatic' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'interpretationSomatic', interpretationSomatic)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationSomatic, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/germline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/somatic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterpretationsApi - functional programming interface
 */
export const InterpretationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InterpretationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationGermline(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationSomatic(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PubmedCitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPubmedCitation(citationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getPubmedCitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationGermline(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterpretationGermline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationGermline(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationSomatic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterpretationSomatic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationSomatic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InterpretationsApi - factory interface
 */
export const InterpretationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InterpretationsApiFp(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.getInterpretationGermline(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.getInterpretationSomatic(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): AxiosPromise<PubmedCitation> {
            return localVarFp.getPubmedCitation(citationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline(options?: RawAxiosRequestConfig): AxiosPromise<Array<InterpretationGermline>> {
            return localVarFp.searchInterpretationGermline(options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic(options?: RawAxiosRequestConfig): AxiosPromise<Array<InterpretationSomatic>> {
            return localVarFp.searchInterpretationSomatic(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InterpretationsApi - object-oriented interface
 */
export class InterpretationsApi extends BaseAPI {
    /**
     * Get interpretation germline
     * @summary Get interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationGermline(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get interpretation somatic
     * @summary Get interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationSomatic(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pubmed citation by ID
     * @summary Get pubmed citation by ID
     * @param {string} citationId Citation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getPubmedCitation(citationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation germline
     * @summary Create or Update interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationGermline} interpretationGermline Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation somatic
     * @summary Create or Update interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation germline
     * @summary Search interpretation germline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchInterpretationGermline(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationGermline(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation somatic
     * @summary Search interpretation somatic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchInterpretationSomatic(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationSomatic(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MondoApi - axios parameter creator
 */
export const MondoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('mondoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/mondo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MondoApi - functional programming interface
 */
export const MondoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MondoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mondoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MondoApi.mondoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MondoApi - factory interface
 */
export const MondoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MondoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.mondoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MondoApi - object-oriented interface
 */
export class MondoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return MondoApiFp(this.configuration).mondoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OccurrencesApi - axios parameter creator
 */
export const OccurrencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aggregate germline CNV occurrences for a given sequence ID
         * @summary Aggregate germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineCNVOccurrences: async (seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('aggregateGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'aggregationBodyWithSqon' is not null or undefined
            assertParamExists('aggregateGermlineCNVOccurrences', 'aggregationBodyWithSqon', aggregationBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{seq_id}/aggregate`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Aggregate germline SNV occurrences for a given sequence ID
         * @summary Aggregate germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {boolean} [withDictionary] Whether to include all possible facet values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineSNVOccurrences: async (seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, withDictionary?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('aggregateGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'aggregationBodyWithSqon' is not null or undefined
            assertParamExists('aggregateGermlineSNVOccurrences', 'aggregationBodyWithSqon', aggregationBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/aggregate`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (withDictionary !== undefined) {
                localVarQueryParameter['with_dictionary'] = withDictionary;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts germline CNV occurrences for a given sequence ID
         * @summary Count germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineCNVOccurrences: async (seqId: string, countBodyWithSqon: CountBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('countGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'countBodyWithSqon' is not null or undefined
            assertParamExists('countGermlineCNVOccurrences', 'countBodyWithSqon', countBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{seq_id}/count`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts germline SNV occurrences for a given sequence ID
         * @summary Count germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineSNVOccurrences: async (seqId: string, countBodyWithSqon: CountBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('countGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'countBodyWithSqon' is not null or undefined
            assertParamExists('countGermlineSNVOccurrences', 'countBodyWithSqon', countBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/count`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
         * @summary Get a germline ExpandedGermlineSNVOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineSNVOccurrence: async (seqId: string, locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getExpandedGermlineSNVOccurrence', 'seqId', seqId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getExpandedGermlineSNVOccurrence', 'locusId', locusId)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/{locus_id}/expanded`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline SNV facets
         * @summary Get germline SNV facets dictionary
         * @param {Array<string>} [facets] One or more facets to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineSNVDictionary: async (facets?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/occurrences/germline/snv/dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (facets) {
                localVarQueryParameter['facets'] = facets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List genes overlapping a CNV with a given ID
         * @summary List genes overlapping a CNV with a given ID
         * @param {number} seqId Sequence ID
         * @param {string} cnvId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVGenesOverlap: async (seqId: number, cnvId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listGermlineCNVGenesOverlap', 'seqId', seqId)
            // verify required parameter 'cnvId' is not null or undefined
            assertParamExists('listGermlineCNVGenesOverlap', 'cnvId', cnvId)
            const localVarPath = `/occurrences/germline/cnv/{seq_id}/{cnv_id}/genes_overlap`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"cnv_id"}}`, encodeURIComponent(String(cnvId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List germline CNV occurrences for a given sequence ID
         * @summary List germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVOccurrences: async (seqId: string, listBodyWithSqon: ListBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'listBodyWithSqon' is not null or undefined
            assertParamExists('listGermlineCNVOccurrences', 'listBodyWithSqon', listBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{seq_id}/list`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List germline SNV occurrences for a given sequence ID
         * @summary List germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineSNVOccurrences: async (seqId: string, listBodyWithSqon: ListBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'listBodyWithSqon' is not null or undefined
            assertParamExists('listGermlineSNVOccurrences', 'listBodyWithSqon', listBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/list`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineCNVOccurrences: async (seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('statisticsGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'statisticsBodyWithSqon' is not null or undefined
            assertParamExists('statisticsGermlineCNVOccurrences', 'statisticsBodyWithSqon', statisticsBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{seq_id}/statistics`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticsBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineSNVOccurrences: async (seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('statisticsGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'statisticsBodyWithSqon' is not null or undefined
            assertParamExists('statisticsGermlineSNVOccurrences', 'statisticsBodyWithSqon', statisticsBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{seq_id}/statistics`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticsBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OccurrencesApi - functional programming interface
 */
export const OccurrencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OccurrencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Aggregate germline CNV occurrences for a given sequence ID
         * @summary Aggregate germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateGermlineCNVOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Aggregation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateGermlineCNVOccurrences(seqId, aggregationBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.aggregateGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Aggregate germline SNV occurrences for a given sequence ID
         * @summary Aggregate germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {boolean} [withDictionary] Whether to include all possible facet values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateGermlineSNVOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, withDictionary?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Aggregation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateGermlineSNVOccurrences(seqId, aggregationBodyWithSqon, withDictionary, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.aggregateGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Counts germline CNV occurrences for a given sequence ID
         * @summary Count germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countGermlineCNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Count>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countGermlineCNVOccurrences(seqId, countBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.countGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Counts germline SNV occurrences for a given sequence ID
         * @summary Count germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countGermlineSNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Count>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countGermlineSNVOccurrences(seqId, countBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.countGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
         * @summary Get a germline ExpandedGermlineSNVOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpandedGermlineSNVOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandedGermlineSNVOccurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpandedGermlineSNVOccurrence(seqId, locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.getExpandedGermlineSNVOccurrence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline SNV facets
         * @summary Get germline SNV facets dictionary
         * @param {Array<string>} [facets] One or more facets to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineSNVDictionary(facets?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Facet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineSNVDictionary(facets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.getGermlineSNVDictionary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List genes overlapping a CNV with a given ID
         * @summary List genes overlapping a CNV with a given ID
         * @param {number} seqId Sequence ID
         * @param {string} cnvId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGermlineCNVGenesOverlap(seqId: number, cnvId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CNVGeneOverlap>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGermlineCNVGenesOverlap(seqId, cnvId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listGermlineCNVGenesOverlap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List germline CNV occurrences for a given sequence ID
         * @summary List germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGermlineCNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GermlineCNVOccurrence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGermlineCNVOccurrences(seqId, listBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List germline SNV occurrences for a given sequence ID
         * @summary List germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGermlineSNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GermlineSNVOccurrence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGermlineSNVOccurrences(seqId, listBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsGermlineCNVOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsGermlineCNVOccurrences(seqId, statisticsBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.statisticsGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsGermlineSNVOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsGermlineSNVOccurrences(seqId, statisticsBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.statisticsGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OccurrencesApi - factory interface
 */
export const OccurrencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OccurrencesApiFp(configuration)
    return {
        /**
         * Aggregate germline CNV occurrences for a given sequence ID
         * @summary Aggregate germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineCNVOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<Aggregation>> {
            return localVarFp.aggregateGermlineCNVOccurrences(seqId, aggregationBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Aggregate germline SNV occurrences for a given sequence ID
         * @summary Aggregate germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {boolean} [withDictionary] Whether to include all possible facet values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineSNVOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, withDictionary?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Aggregation>> {
            return localVarFp.aggregateGermlineSNVOccurrences(seqId, aggregationBodyWithSqon, withDictionary, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts germline CNV occurrences for a given sequence ID
         * @summary Count germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineCNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Count> {
            return localVarFp.countGermlineCNVOccurrences(seqId, countBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts germline SNV occurrences for a given sequence ID
         * @summary Count germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineSNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Count> {
            return localVarFp.countGermlineSNVOccurrences(seqId, countBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
         * @summary Get a germline ExpandedGermlineSNVOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineSNVOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExpandedGermlineSNVOccurrence> {
            return localVarFp.getExpandedGermlineSNVOccurrence(seqId, locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline SNV facets
         * @summary Get germline SNV facets dictionary
         * @param {Array<string>} [facets] One or more facets to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineSNVDictionary(facets?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Facet>> {
            return localVarFp.getGermlineSNVDictionary(facets, options).then((request) => request(axios, basePath));
        },
        /**
         * List genes overlapping a CNV with a given ID
         * @summary List genes overlapping a CNV with a given ID
         * @param {number} seqId Sequence ID
         * @param {string} cnvId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVGenesOverlap(seqId: number, cnvId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CNVGeneOverlap>> {
            return localVarFp.listGermlineCNVGenesOverlap(seqId, cnvId, options).then((request) => request(axios, basePath));
        },
        /**
         * List germline CNV occurrences for a given sequence ID
         * @summary List germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<GermlineCNVOccurrence>> {
            return localVarFp.listGermlineCNVOccurrences(seqId, listBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * List germline SNV occurrences for a given sequence ID
         * @summary List germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineSNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<GermlineSNVOccurrence>> {
            return localVarFp.listGermlineSNVOccurrences(seqId, listBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline CNV occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineCNVOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Statistics> {
            return localVarFp.statisticsGermlineCNVOccurrences(seqId, statisticsBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline SNV occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineSNVOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Statistics> {
            return localVarFp.statisticsGermlineSNVOccurrences(seqId, statisticsBodyWithSqon, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OccurrencesApi - object-oriented interface
 */
export class OccurrencesApi extends BaseAPI {
    /**
     * Aggregate germline CNV occurrences for a given sequence ID
     * @summary Aggregate germline CNV occurrences
     * @param {string} seqId Sequence ID
     * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public aggregateGermlineCNVOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).aggregateGermlineCNVOccurrences(seqId, aggregationBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Aggregate germline SNV occurrences for a given sequence ID
     * @summary Aggregate germline SNV occurrences
     * @param {string} seqId Sequence ID
     * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
     * @param {boolean} [withDictionary] Whether to include all possible facet values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public aggregateGermlineSNVOccurrences(seqId: string, aggregationBodyWithSqon: AggregationBodyWithSqon, withDictionary?: boolean, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).aggregateGermlineSNVOccurrences(seqId, aggregationBodyWithSqon, withDictionary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts germline CNV occurrences for a given sequence ID
     * @summary Count germline CNV occurrences
     * @param {string} seqId Sequence ID
     * @param {CountBodyWithSqon} countBodyWithSqon Count Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countGermlineCNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).countGermlineCNVOccurrences(seqId, countBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts germline SNV occurrences for a given sequence ID
     * @summary Count germline SNV occurrences
     * @param {string} seqId Sequence ID
     * @param {CountBodyWithSqon} countBodyWithSqon Count Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countGermlineSNVOccurrences(seqId: string, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).countGermlineSNVOccurrences(seqId, countBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
     * @summary Get a germline ExpandedGermlineSNVOccurrence
     * @param {string} seqId Sequence ID
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getExpandedGermlineSNVOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).getExpandedGermlineSNVOccurrence(seqId, locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline SNV facets
     * @summary Get germline SNV facets dictionary
     * @param {Array<string>} [facets] One or more facets to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineSNVDictionary(facets?: Array<string>, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).getGermlineSNVDictionary(facets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List genes overlapping a CNV with a given ID
     * @summary List genes overlapping a CNV with a given ID
     * @param {number} seqId Sequence ID
     * @param {string} cnvId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listGermlineCNVGenesOverlap(seqId: number, cnvId: string, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listGermlineCNVGenesOverlap(seqId, cnvId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List germline CNV occurrences for a given sequence ID
     * @summary List germline CNV occurrences
     * @param {string} seqId Sequence ID
     * @param {ListBodyWithSqon} listBodyWithSqon List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listGermlineCNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listGermlineCNVOccurrences(seqId, listBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List germline SNV occurrences for a given sequence ID
     * @summary List germline SNV occurrences
     * @param {string} seqId Sequence ID
     * @param {ListBodyWithSqon} listBodyWithSqon List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listGermlineSNVOccurrences(seqId: string, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listGermlineSNVOccurrences(seqId, listBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return statistics about a field for a given sequence ID
     * @summary Statistics of germline CNV occurrences
     * @param {string} seqId Sequence ID
     * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public statisticsGermlineCNVOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).statisticsGermlineCNVOccurrences(seqId, statisticsBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return statistics about a field for a given sequence ID
     * @summary Statistics of germline SNV occurrences
     * @param {string} seqId Sequence ID
     * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public statisticsGermlineSNVOccurrences(seqId: string, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).statisticsGermlineSNVOccurrences(seqId, statisticsBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SavedFiltersApi - axios parameter creator
 */
export const SavedFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a saved filter
         * @summary Delete a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedFilter: async (savedFilterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedFilterId' is not null or undefined
            assertParamExists('deleteSavedFilter', 'savedFilterId', savedFilterId)
            const localVarPath = `/users/saved_filters/{saved_filter_id}`
                .replace(`{${"saved_filter_id"}}`, encodeURIComponent(String(savedFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get saved filter by id
         * @summary Get saved filter by id
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilterById: async (savedFilterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedFilterId' is not null or undefined
            assertParamExists('getSavedFilterById', 'savedFilterId', savedFilterId)
            const localVarPath = `/users/saved_filters/{saved_filter_id}`
                .replace(`{${"saved_filter_id"}}`, encodeURIComponent(String(savedFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user saved filters
         * @summary Get user saved filters
         * @param {string} [type] Saved Filter Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilters: async (type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/saved_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new saved filter
         * @summary Create a new saved filter
         * @param {SavedFilterCreationInput} savedFilterCreationInput New Saved Filter to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSavedFilter: async (savedFilterCreationInput: SavedFilterCreationInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedFilterCreationInput' is not null or undefined
            assertParamExists('postSavedFilter', 'savedFilterCreationInput', savedFilterCreationInput)
            const localVarPath = `/users/saved_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedFilterCreationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a saved filter
         * @summary Update a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {SavedFilterUpdateInput} savedFilterUpdateInput Saved Filter to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSavedFilter: async (savedFilterId: string, savedFilterUpdateInput: SavedFilterUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedFilterId' is not null or undefined
            assertParamExists('putSavedFilter', 'savedFilterId', savedFilterId)
            // verify required parameter 'savedFilterUpdateInput' is not null or undefined
            assertParamExists('putSavedFilter', 'savedFilterUpdateInput', savedFilterUpdateInput)
            const localVarPath = `/users/saved_filters/{saved_filter_id}`
                .replace(`{${"saved_filter_id"}}`, encodeURIComponent(String(savedFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedFilterUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedFiltersApi - functional programming interface
 */
export const SavedFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a saved filter
         * @summary Delete a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedFilter(savedFilterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedFilter(savedFilterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.deleteSavedFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get saved filter by id
         * @summary Get saved filter by id
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedFilterById(savedFilterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedFilterById(savedFilterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.getSavedFilterById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user saved filters
         * @summary Get user saved filters
         * @param {string} [type] Saved Filter Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedFilters(type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedFilter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedFilters(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.getSavedFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new saved filter
         * @summary Create a new saved filter
         * @param {SavedFilterCreationInput} savedFilterCreationInput New Saved Filter to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSavedFilter(savedFilterCreationInput: SavedFilterCreationInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSavedFilter(savedFilterCreationInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.postSavedFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a saved filter
         * @summary Update a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {SavedFilterUpdateInput} savedFilterUpdateInput Saved Filter to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSavedFilter(savedFilterId: string, savedFilterUpdateInput: SavedFilterUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSavedFilter(savedFilterId, savedFilterUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.putSavedFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SavedFiltersApi - factory interface
 */
export const SavedFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedFiltersApiFp(configuration)
    return {
        /**
         * Delete a saved filter
         * @summary Delete a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedFilter(savedFilterId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSavedFilter(savedFilterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get saved filter by id
         * @summary Get saved filter by id
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilterById(savedFilterId: string, options?: RawAxiosRequestConfig): AxiosPromise<SavedFilter> {
            return localVarFp.getSavedFilterById(savedFilterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user saved filters
         * @summary Get user saved filters
         * @param {string} [type] Saved Filter Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilters(type?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SavedFilter>> {
            return localVarFp.getSavedFilters(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new saved filter
         * @summary Create a new saved filter
         * @param {SavedFilterCreationInput} savedFilterCreationInput New Saved Filter to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSavedFilter(savedFilterCreationInput: SavedFilterCreationInput, options?: RawAxiosRequestConfig): AxiosPromise<SavedFilter> {
            return localVarFp.postSavedFilter(savedFilterCreationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a saved filter
         * @summary Update a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {SavedFilterUpdateInput} savedFilterUpdateInput Saved Filter to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSavedFilter(savedFilterId: string, savedFilterUpdateInput: SavedFilterUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<SavedFilter> {
            return localVarFp.putSavedFilter(savedFilterId, savedFilterUpdateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SavedFiltersApi - object-oriented interface
 */
export class SavedFiltersApi extends BaseAPI {
    /**
     * Delete a saved filter
     * @summary Delete a saved filter
     * @param {string} savedFilterId Saved Filter ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSavedFilter(savedFilterId: string, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).deleteSavedFilter(savedFilterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get saved filter by id
     * @summary Get saved filter by id
     * @param {string} savedFilterId Saved Filter ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSavedFilterById(savedFilterId: string, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).getSavedFilterById(savedFilterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user saved filters
     * @summary Get user saved filters
     * @param {string} [type] Saved Filter Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSavedFilters(type?: string, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).getSavedFilters(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new saved filter
     * @summary Create a new saved filter
     * @param {SavedFilterCreationInput} savedFilterCreationInput New Saved Filter to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSavedFilter(savedFilterCreationInput: SavedFilterCreationInput, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).postSavedFilter(savedFilterCreationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a saved filter
     * @summary Update a saved filter
     * @param {string} savedFilterId Saved Filter ID
     * @param {SavedFilterUpdateInput} savedFilterUpdateInput Saved Filter to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putSavedFilter(savedFilterId: string, savedFilterUpdateInput: SavedFilterUpdateInput, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).putSavedFilter(savedFilterId, savedFilterUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SequencingApi - axios parameter creator
 */
export const SequencingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getSequencing', 'seqId', seqId)
            const localVarPath = `/sequencing/{seq_id}`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SequencingApi - functional programming interface
 */
export const SequencingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SequencingApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSequencing(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequencing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSequencing(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SequencingApi.getSequencing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SequencingApi - factory interface
 */
export const SequencingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SequencingApiFp(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<Sequencing> {
            return localVarFp.getSequencing(seqId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SequencingApi - object-oriented interface
 */
export class SequencingApi extends BaseAPI {
    /**
     * Retrieve Sequencing data for a given sequence ID
     * @summary Get a Sequencing
     * @param {string} seqId Sequence ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSequencing(seqId: string, options?: RawAxiosRequestConfig) {
        return SequencingApiFp(this.configuration).getSequencing(seqId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 */
export class StatusApi extends BaseAPI {
    /**
     * Returns the current status of the API
     * @summary Get API status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public statusGet(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPreferencesApi - axios parameter creator
 */
export const UserPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user preferences
         * @summary Get user preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update user preference
         * @summary Create or update user preference
         * @param {UserPreference} userPreference User Preference to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserPreferences: async (userPreference: UserPreference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPreference' is not null or undefined
            assertParamExists('postUserPreferences', 'userPreference', userPreference)
            const localVarPath = `/users/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPreference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPreferencesApi - functional programming interface
 */
export const UserPreferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPreferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user preferences
         * @summary Get user preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPreferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPreferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPreferencesApi.getUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update user preference
         * @summary Create or update user preference
         * @param {UserPreference} userPreference User Preference to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserPreferences(userPreference: UserPreference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserPreferences(userPreference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPreferencesApi.postUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserPreferencesApi - factory interface
 */
export const UserPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPreferencesApiFp(configuration)
    return {
        /**
         * Get user preferences
         * @summary Get user preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences(options?: RawAxiosRequestConfig): AxiosPromise<UserPreference> {
            return localVarFp.getUserPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update user preference
         * @summary Create or update user preference
         * @param {UserPreference} userPreference User Preference to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserPreferences(userPreference: UserPreference, options?: RawAxiosRequestConfig): AxiosPromise<UserPreference> {
            return localVarFp.postUserPreferences(userPreference, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPreferencesApi - object-oriented interface
 */
export class UserPreferencesApi extends BaseAPI {
    /**
     * Get user preferences
     * @summary Get user preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserPreferences(options?: RawAxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).getUserPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update user preference
     * @summary Create or update user preference
     * @param {UserPreference} userPreference User Preference to create or update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUserPreferences(userPreference: UserPreference, options?: RawAxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).postUserPreferences(userPreference, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSetsApi - axios parameter creator
 */
export const UserSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet: async (userSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSetId' is not null or undefined
            assertParamExists('getUserSet', 'userSetId', userSetId)
            const localVarPath = `/users/sets/{user_set_id}`
                .replace(`{${"user_set_id"}}`, encodeURIComponent(String(userSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSetsApi - functional programming interface
 */
export const UserSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSet(userSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSet(userSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSetsApi.getUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserSetsApi - factory interface
 */
export const UserSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSetsApiFp(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet(userSetId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSet> {
            return localVarFp.getUserSet(userSetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSetsApi - object-oriented interface
 */
export class UserSetsApi extends BaseAPI {
    /**
     * Get user set
     * @summary Get user set by id
     * @param {string} userSetId UserSet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserSet(userSetId: string, options?: RawAxiosRequestConfig) {
        return UserSetsApiFp(this.configuration).getUserSet(userSetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariantApi - axios parameter creator
 */
export const VariantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
         * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineVariantInterpretedCase: async (locusId: string, seqId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'locusId', locusId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'seqId', seqId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'transcriptId', transcriptId)
            const localVarPath = `/variants/germline/{locus_id}/cases/interpreted/{seq_id}/{transcript_id}`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesCount: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantCasesCount', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/cases/count`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesFilters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variants/germline/cases/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditions: async (locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConditions', 'locusId', locusId)
            // verify required parameter 'panelType' is not null or undefined
            assertParamExists('getGermlineVariantConditions', 'panelType', panelType)
            const localVarPath = `/variants/germline/{locus_id}/conditions/{panel_type}`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"panel_type"}}`, encodeURIComponent(String(panelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditionsClinvar: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConditionsClinvar', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/conditions/clinvar`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConsequences: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConsequences', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/consequences`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantHeader: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantHeader', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/header`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantInterpretedCases: async (locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantInterpretedCases', 'locusId', locusId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('getGermlineVariantInterpretedCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/variants/germline/{locus_id}/cases/interpreted`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantOverview: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantOverview', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/overview`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantUninterpretedCases: async (locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantUninterpretedCases', 'locusId', locusId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('getGermlineVariantUninterpretedCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/variants/germline/{locus_id}/cases/uninterpreted`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariantApi - functional programming interface
 */
export const VariantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariantApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
         * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpandedGermlineVariantInterpretedCase(locusId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantExpandedInterpretedCase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpandedGermlineVariantInterpretedCase(locusId, seqId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getExpandedGermlineVariantInterpretedCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantCasesCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantCasesCount(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantCasesCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantCasesFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantCasesFilters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantCasesFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenePanelConditions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConditions(locusId, panelType, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConditions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClinvarRCV>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConditionsClinvar(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConditionsClinvar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariantConsequence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConsequences(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConsequences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantHeader(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantHeader']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantInterpretedCasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantInterpretedCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantOverview(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantUninterpretedCasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantUninterpretedCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariantApi - factory interface
 */
export const VariantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariantApiFp(configuration)
    return {
        /**
         * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
         * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineVariantInterpretedCase(locusId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantExpandedInterpretedCase> {
            return localVarFp.getExpandedGermlineVariantInterpretedCase(locusId, seqId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantCasesCount> {
            return localVarFp.getGermlineVariantCasesCount(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig): AxiosPromise<VariantCasesFilters> {
            return localVarFp.getGermlineVariantCasesFilters(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<GenePanelConditions> {
            return localVarFp.getGermlineVariantConditions(locusId, panelType, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClinvarRCV>> {
            return localVarFp.getGermlineVariantConditionsClinvar(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariantConsequence>> {
            return localVarFp.getGermlineVariantConsequences(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantHeader> {
            return localVarFp.getGermlineVariantHeader(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<VariantInterpretedCasesSearchResponse> {
            return localVarFp.getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantOverview> {
            return localVarFp.getGermlineVariantOverview(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<VariantUninterpretedCasesSearchResponse> {
            return localVarFp.getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariantApi - object-oriented interface
 */
export class VariantApi extends BaseAPI {
    /**
     * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
     * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
     * @param {string} locusId Locus ID
     * @param {string} seqId Seq ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getExpandedGermlineVariantInterpretedCase(locusId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getExpandedGermlineVariantInterpretedCase(locusId, seqId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve cases count for a given locus id
     * @summary Get germline cases count for a given locus
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantCasesCount(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve cases filters for germline variant entity
     * @summary Get cases filters for germline variant entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantCasesFilters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve conditions for germline variant entity for a specific gene panel
     * @summary Get conditions for germline variant entity for a specific gene panel
     * @param {string} locusId Locus ID
     * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
     * @param {string} [filter] Condition filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConditions(locusId, panelType, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ClinVar conditions for germline variant entity
     * @summary Get ClinVar conditions for germline variant entity
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConditionsClinvar(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Consequences for a given locus
     * @summary Get list of VariantConsequences for a germline variant
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConsequences(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Header data for a given locus
     * @summary Get a germline VariantHeader
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantHeader(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Germline Variant interpreted cases for a given locus
     * @summary Get list of interpreted Cases for a germline variant
     * @param {string} locusId Locus ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Overview data for a given locus
     * @summary Get a germline VariantOverview
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantOverview(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Germline Variant uninterpreted cases for a given locus
     * @summary Get list of uninterpreted Cases for a germline variant
     * @param {string} locusId Locus ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetGermlineVariantConditionsPanelTypeEnum = {
    Omim: 'omim',
    Hpo: 'hpo',
    Orphanet: 'orphanet'
} as const;
export type GetGermlineVariantConditionsPanelTypeEnum = typeof GetGermlineVariantConditionsPanelTypeEnum[keyof typeof GetGermlineVariantConditionsPanelTypeEnum];



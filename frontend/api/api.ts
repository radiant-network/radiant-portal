/* tslint:disable */
/* eslint-disable */
/**
 * Radiant API
 * This is the API for Radiant data platform.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Aggregation represents an aggregation result
 * @export
 * @interface Aggregation
 */
export interface Aggregation {
    /**
     * Count in the bucket
     * @type {number}
     * @memberof Aggregation
     */
    'count'?: number;
    /**
     * Bucket key
     * @type {string}
     * @memberof Aggregation
     */
    'key'?: string;
    /**
     * Label corresponding to the key
     * @type {string}
     * @memberof Aggregation
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface AggregationBodyWithSqon
 */
export interface AggregationBodyWithSqon {
    /**
     * 
     * @type {string}
     * @memberof AggregationBodyWithSqon
     */
    'field'?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregationBodyWithSqon
     */
    'size'?: number;
    /**
     * 
     * @type {Sqon}
     * @memberof AggregationBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * ApiError represents an error
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {any}
     * @memberof ApiError
     */
    'detail'?: any;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ApiError
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface AutoCompleteGene
 */
export interface AutoCompleteGene {
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteGene
     */
    'highlight'?: Term;
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteGene
     */
    'source'?: Term;
}
/**
 * 
 * @export
 * @interface AutoCompleteTerm
 */
export interface AutoCompleteTerm {
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteTerm
     */
    'highlight'?: Term;
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteTerm
     */
    'source'?: Term;
}
/**
 * 
 * @export
 * @interface AutocompleteResult
 */
export interface AutocompleteResult {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface BatchMessage
 */
export interface BatchMessage {
    /**
     * 
     * @type {string}
     * @memberof BatchMessage
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMessage
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMessage
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface BatchReport
 */
export interface BatchReport {
    /**
     * 
     * @type {Array<BatchMessage>}
     * @memberof BatchReport
     */
    'error'?: Array<BatchMessage>;
    /**
     * 
     * @type {Array<BatchMessage>}
     * @memberof BatchReport
     */
    'info'?: Array<BatchMessage>;
    /**
     * 
     * @type {Array<BatchMessage>}
     * @memberof BatchReport
     */
    'warn'?: Array<BatchMessage>;
}
/**
 * 
 * @export
 * @interface BatchSummary
 */
export interface BatchSummary {
    /**
     * 
     * @type {number}
     * @memberof BatchSummary
     */
    'created'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchSummary
     */
    'errors'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchSummary
     */
    'skipped'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchSummary
     */
    'updated'?: number;
}
/**
 * CNVGeneOverlap represents a gene overlap with a CNV
 * @export
 * @interface CNVGeneOverlap
 */
export interface CNVGeneOverlap {
    /**
     * 
     * @type {Array<string>}
     * @memberof CNVGeneOverlap
     */
    'cytoband': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CNVGeneOverlap
     */
    'gene_id': string;
    /**
     * 
     * @type {number}
     * @memberof CNVGeneOverlap
     */
    'gene_length': number;
    /**
     * 
     * @type {number}
     * @memberof CNVGeneOverlap
     */
    'nb_exons': number;
    /**
     * 
     * @type {number}
     * @memberof CNVGeneOverlap
     */
    'nb_overlap_bases': number;
    /**
     * 
     * @type {string}
     * @memberof CNVGeneOverlap
     */
    'overlap_type': string;
    /**
     * 
     * @type {number}
     * @memberof CNVGeneOverlap
     */
    'overlapping_cnv_percent': number;
    /**
     * 
     * @type {number}
     * @memberof CNVGeneOverlap
     */
    'overlapping_gene_percent': number;
    /**
     * 
     * @type {string}
     * @memberof CNVGeneOverlap
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface CaseBatch
 */
export interface CaseBatch {
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'analysis_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'category_code': CaseBatchCategoryCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'diagnostic_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'ordering_organization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'ordering_physician'?: string;
    /**
     * 
     * @type {Array<CasePatientBatch>}
     * @memberof CaseBatch
     */
    'patients': Array<CasePatientBatch>;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'primary_condition_code_system'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'primary_condition_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'priority_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'project_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'resolution_status_code'?: string;
    /**
     * 
     * @type {Array<CaseSequencingExperimentBatch>}
     * @memberof CaseBatch
     */
    'sequencing_experiments': Array<CaseSequencingExperimentBatch>;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'submitter_case_id'?: string;
    /**
     * 
     * @type {Array<CaseTaskBatch>}
     * @memberof CaseBatch
     */
    'tasks': Array<CaseTaskBatch>;
    /**
     * 
     * @type {string}
     * @memberof CaseBatch
     */
    'type': CaseBatchTypeEnum;
}

export const CaseBatchCategoryCodeEnum = {
    Prenatal: 'prenatal',
    Postnatal: 'postnatal'
} as const;

export type CaseBatchCategoryCodeEnum = typeof CaseBatchCategoryCodeEnum[keyof typeof CaseBatchCategoryCodeEnum];
export const CaseBatchTypeEnum = {
    Germline: 'germline',
    Somatic: 'somatic'
} as const;

export type CaseBatchTypeEnum = typeof CaseBatchTypeEnum[keyof typeof CaseBatchTypeEnum];

/**
 * Data for Case Entity Page
 * @export
 * @interface CaseEntity
 */
export interface CaseEntity {
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'analysis_catalog_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'analysis_catalog_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'case_category_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'case_category_name': string;
    /**
     * 
     * @type {number}
     * @memberof CaseEntity
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'case_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'diagnosis_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'diagnosis_lab_name'?: string;
    /**
     * 
     * @type {Array<CasePatientClinicalInformation>}
     * @memberof CaseEntity
     */
    'members': Array<CasePatientClinicalInformation>;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'ordering_organization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'ordering_organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'panel_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'panel_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'prescriber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'primary_condition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'primary_condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'priority_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'project_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'project_name'?: string;
    /**
     * 
     * @type {Array<CaseSequencingExperiment>}
     * @memberof CaseEntity
     */
    'sequencing_experiments': Array<CaseSequencingExperiment>;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'status_code': string;
    /**
     * 
     * @type {Array<CaseTask>}
     * @memberof CaseEntity
     */
    'tasks': Array<CaseTask>;
    /**
     * 
     * @type {string}
     * @memberof CaseEntity
     */
    'updated_on': string;
}
/**
 * 
 * @export
 * @interface CaseFilters
 */
export interface CaseFilters {
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'analysis_catalog_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'case_category_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'case_type_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'diagnosis_lab_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'life_status_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'ordering_organization_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'panel_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'priority_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'project_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'resolution_status_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof CaseFilters
     */
    'status_code': Array<Aggregation>;
}
/**
 * 
 * @export
 * @interface CasePatientBatch
 */
export interface CasePatientBatch {
    /**
     * 
     * @type {string}
     * @memberof CasePatientBatch
     */
    'affected_status_code': CasePatientBatchAffectedStatusCodeEnum;
    /**
     * 
     * @type {Array<FamilyHistoryBatch>}
     * @memberof CasePatientBatch
     */
    'family_history'?: Array<FamilyHistoryBatch>;
    /**
     * 
     * @type {Array<ObservationCategoricalBatch>}
     * @memberof CasePatientBatch
     */
    'observations_categorical'?: Array<ObservationCategoricalBatch>;
    /**
     * 
     * @type {Array<ObservationTextBatch>}
     * @memberof CasePatientBatch
     */
    'observations_text'?: Array<ObservationTextBatch>;
    /**
     * 
     * @type {string}
     * @memberof CasePatientBatch
     */
    'patient_organization_code': string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientBatch
     */
    'relation_to_proband_code': CasePatientBatchRelationToProbandCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof CasePatientBatch
     */
    'submitter_patient_id': string;
}

export const CasePatientBatchAffectedStatusCodeEnum = {
    Affected: 'affected',
    Unaffected: 'unaffected',
    Unknown: 'unknown'
} as const;

export type CasePatientBatchAffectedStatusCodeEnum = typeof CasePatientBatchAffectedStatusCodeEnum[keyof typeof CasePatientBatchAffectedStatusCodeEnum];
export const CasePatientBatchRelationToProbandCodeEnum = {
    Mother: 'mother',
    Father: 'father',
    Brother: 'brother',
    Sister: 'sister',
    Sibling: 'sibling',
    Proband: 'proband'
} as const;

export type CasePatientBatchRelationToProbandCodeEnum = typeof CasePatientBatchRelationToProbandCodeEnum[keyof typeof CasePatientBatchRelationToProbandCodeEnum];

/**
 * Patient clinical information to display in Case Entity
 * @export
 * @interface CasePatientClinicalInformation
 */
export interface CasePatientClinicalInformation {
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'affected_status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'date_of_birth'?: string;
    /**
     * TODO
     * @type {Array<string>}
     * @memberof CasePatientClinicalInformation
     */
    'ethnicity_codes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'jhn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'life_status_code': string;
    /**
     * 
     * @type {Array<Term>}
     * @memberof CasePatientClinicalInformation
     */
    'non_observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {Array<Term>}
     * @memberof CasePatientClinicalInformation
     */
    'observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'organization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'organization_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CasePatientClinicalInformation
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'relationship_to_proband': string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'sex_code': string;
    /**
     * 
     * @type {string}
     * @memberof CasePatientClinicalInformation
     */
    'submitter_patient_id'?: string;
}
/**
 * Line represented a case in case list
 * @export
 * @interface CaseResult
 */
export interface CaseResult {
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'analysis_catalog_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'analysis_catalog_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'case_category_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseResult
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'case_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'diagnosis_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'diagnosis_lab_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CaseResult
     */
    'has_variants': boolean;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'ordering_organization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'ordering_organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'organization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'panel_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'panel_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'prescriber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'primary_condition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'primary_condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'priority_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'proband_first_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseResult
     */
    'proband_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'proband_jhn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'proband_last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'proband_life_status_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'project_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'project_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'resolution_status_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'submitter_proband_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseResult
     */
    'updated_on': string;
}
/**
 * Sequencing experiment to display in a Case
 * @export
 * @interface CaseSequencingExperiment
 */
export interface CaseSequencingExperiment {
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperiment
     */
    'affected_status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperiment
     */
    'experimental_strategy_code': string;
    /**
     * 
     * @type {boolean}
     * @memberof CaseSequencingExperiment
     */
    'has_variants': boolean;
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperiment
     */
    'histology_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseSequencingExperiment
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperiment
     */
    'relationship_to_proband': string;
    /**
     * 
     * @type {number}
     * @memberof CaseSequencingExperiment
     */
    'sample_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperiment
     */
    'sample_submitter_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperiment
     */
    'sample_type_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaseSequencingExperiment
     */
    'seq_id': number;
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperiment
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperiment
     */
    'updated_on': string;
}
/**
 * 
 * @export
 * @interface CaseSequencingExperimentBatch
 */
export interface CaseSequencingExperimentBatch {
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperimentBatch
     */
    'aliquot': string;
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperimentBatch
     */
    'sample_organization_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseSequencingExperimentBatch
     */
    'submitter_sample_id': string;
}
/**
 * 
 * @export
 * @interface CaseTask
 */
export interface CaseTask {
    /**
     * 
     * @type {string}
     * @memberof CaseTask
     */
    'created_on': string;
    /**
     * 
     * @type {number}
     * @memberof CaseTask
     */
    'id': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CaseTask
     */
    'patients': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CaseTask
     */
    'type_code': string;
    /**
     * 
     * @type {string}
     * @memberof CaseTask
     */
    'type_name': string;
}
/**
 * 
 * @export
 * @interface CaseTaskBatch
 */
export interface CaseTaskBatch {
    /**
     * 
     * @type {string}
     * @memberof CaseTaskBatch
     */
    'aliquot'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseTaskBatch
     */
    'genome_build'?: string;
    /**
     * 
     * @type {Array<InputDocumentBatch>}
     * @memberof CaseTaskBatch
     */
    'input_documents'?: Array<InputDocumentBatch>;
    /**
     * 
     * @type {Array<OutputDocumentBatch>}
     * @memberof CaseTaskBatch
     */
    'output_documents': Array<OutputDocumentBatch>;
    /**
     * 
     * @type {string}
     * @memberof CaseTaskBatch
     */
    'pipeline_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaseTaskBatch
     */
    'pipeline_version': string;
    /**
     * 
     * @type {string}
     * @memberof CaseTaskBatch
     */
    'type_code': string;
}
/**
 * 
 * @export
 * @interface CasesSearchResponse
 */
export interface CasesSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof CasesSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<CaseResult>}
     * @memberof CasesSearchResponse
     */
    'list': Array<CaseResult>;
}
/**
 * ClinvarRCV represents a Reference ClinVar record - data aggregated by variant-condition pair
 * @export
 * @interface ClinvarRCV
 */
export interface ClinvarRCV {
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'accession'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClinvarRCV
     */
    'clinical_significance'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'clinvar_id': string;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'date_last_evaluated'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'locus_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClinvarRCV
     */
    'origins'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClinvarRCV
     */
    'review_status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClinvarRCV
     */
    'review_status_stars'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClinvarRCV
     */
    'submission_count'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClinvarRCV
     */
    'traits'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ClinvarRCV
     */
    'version'?: number;
}
/**
 * Count represents count result
 * @export
 * @interface Count
 */
export interface Count {
    /**
     * Number of results
     * @type {number}
     * @memberof Count
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface CountBodyWithSqon
 */
export interface CountBodyWithSqon {
    /**
     * 
     * @type {Sqon}
     * @memberof CountBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * CreateBatchResponse represents the response returned when creating a new batch
 * @export
 * @interface CreateBatchResponse
 */
export interface CreateBatchResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateBatchResponse
     */
    'batch_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchResponse
     */
    'created_on'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBatchResponse
     */
    'dry_run'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchResponse
     */
    'username'?: string;
}
/**
 * CreateCaseBatchBody represents the body required to create a case batch
 * @export
 * @interface CreateCaseBatchBody
 */
export interface CreateCaseBatchBody {
    /**
     * 
     * @type {Array<CaseBatch>}
     * @memberof CreateCaseBatchBody
     */
    'cases': Array<CaseBatch>;
}
/**
 * CreatePatientBatchBody represents the body required to create a patient batch
 * @export
 * @interface CreatePatientBatchBody
 */
export interface CreatePatientBatchBody {
    /**
     * 
     * @type {Array<PatientBatch>}
     * @memberof CreatePatientBatchBody
     */
    'patients': Array<PatientBatch>;
}
/**
 * CreateSampleBatchBody represents the body required to create a sample batch
 * @export
 * @interface CreateSampleBatchBody
 */
export interface CreateSampleBatchBody {
    /**
     * 
     * @type {Array<SampleBatch>}
     * @memberof CreateSampleBatchBody
     */
    'samples': Array<SampleBatch>;
}
/**
 * CreateSequencingExperimentBatchBody represents the body required to create a sequencing experiment batch
 * @export
 * @interface CreateSequencingExperimentBatchBody
 */
export interface CreateSequencingExperimentBatchBody {
    /**
     * 
     * @type {Array<SequencingExperimentBatch>}
     * @memberof CreateSequencingExperimentBatchBody
     */
    'sequencing_experiments': Array<SequencingExperimentBatch>;
}
/**
 * 
 * @export
 * @interface DocumentFilters
 */
export interface DocumentFilters {
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'data_type_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'diagnosis_lab_code'?: Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'format_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'project_code'?: Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof DocumentFilters
     */
    'relationship_to_proband_code': Array<Aggregation>;
}
/**
 * 
 * @export
 * @interface DocumentResult
 */
export interface DocumentResult {
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'data_type_code': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'diagnosis_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'diagnosis_lab_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'document_id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'format_code': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'relationship_to_proband_code': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'run_alias'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'seq_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResult
     */
    'submitter_sample_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentResult
     */
    'task_id': number;
}
/**
 * 
 * @export
 * @interface DocumentsSearchResponse
 */
export interface DocumentsSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof DocumentsSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<DocumentResult>}
     * @memberof DocumentsSearchResponse
     */
    'list': Array<DocumentResult>;
}
/**
 * 
 * @export
 * @interface ExpandedGermlineSNVOccurrence
 */
export interface ExpandedGermlineSNVOccurrence {
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'ad_alt'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'ad_total'?: number;
    /**
     * TODO
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'af'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'chromosome'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'dann_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'dna_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'end'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'ensembl_gene_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exomiser_acmg_classification'?: string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exomiser_acmg_classification_counts'?: { [key: string]: number; };
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exomiser_acmg_evidence': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exomiser_gene_combined_score': number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exon_rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'exon_total'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'father_calls'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'genotype_quality': number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'hgvsg': string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'interpretation_classification'?: string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'interpretation_classification_counts'?: { [key: string]: number; };
    /**
     * 
     * @type {boolean}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'is_mane_plus'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'locus': string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'locus_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'lrt_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'lrt_score'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'mother_calls'?: Array<number>;
    /**
     * 
     * @type {Array<OmimGenePanel>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'omim_conditions'?: Array<OmimGenePanel>;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'parental_origin'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pc_wgs_affected'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pc_wgs_not_affected'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pf_wgs'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pf_wgs_affected'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pf_wgs_not_affected'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pn_wgs_affected'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'pn_wgs_not_affected'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'polyphen2_hvar_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'polyphen2_hvar_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'qd'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'sift_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'start'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'transmission'?: string;
    /**
     * 
     * @type {VepImpact}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'vep_impact'?: VepImpact;
    /**
     * 
     * @type {string}
     * @memberof ExpandedGermlineSNVOccurrence
     */
    'zygosity'?: string;
}


/**
 * 
 * @export
 * @interface Facet
 */
export interface Facet {
    /**
     * 
     * @type {string}
     * @memberof Facet
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Facet
     */
    'values'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FamilyHistoryBatch
 */
export interface FamilyHistoryBatch {
    /**
     * 
     * @type {string}
     * @memberof FamilyHistoryBatch
     */
    'condition': string;
    /**
     * 
     * @type {string}
     * @memberof FamilyHistoryBatch
     */
    'family_member_code': string;
}
/**
 * 
 * @export
 * @interface FiltersBodyWithCriteria
 */
export interface FiltersBodyWithCriteria {
    /**
     * 
     * @type {Array<SearchCriterion>}
     * @memberof FiltersBodyWithCriteria
     */
    'search_criteria'?: Array<SearchCriterion>;
}
/**
 * 
 * @export
 * @interface GenePanelCondition
 */
export interface GenePanelCondition {
    /**
     * 
     * @type {Array<string>}
     * @memberof GenePanelCondition
     */
    'inheritance_code'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GenePanelCondition
     */
    'panel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenePanelCondition
     */
    'panel_name': string;
}
/**
 * 
 * @export
 * @interface GenePanelConditions
 */
export interface GenePanelConditions {
    /**
     * 
     * @type {{ [key: string]: Array<GenePanelCondition>; }}
     * @memberof GenePanelConditions
     */
    'conditions': { [key: string]: Array<GenePanelCondition>; };
    /**
     * 
     * @type {number}
     * @memberof GenePanelConditions
     */
    'count_hpo': number;
    /**
     * 
     * @type {number}
     * @memberof GenePanelConditions
     */
    'count_omim': number;
    /**
     * 
     * @type {number}
     * @memberof GenePanelConditions
     */
    'count_orphanet': number;
}
/**
 * 
 * @export
 * @interface GeneResult
 */
export interface GeneResult {
    /**
     * 
     * @type {string}
     * @memberof GeneResult
     */
    'ensembl_gene_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeneResult
     */
    'symbol'?: string;
}
/**
 * 
 * @export
 * @interface GeneSearchBody
 */
export interface GeneSearchBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof GeneSearchBody
     */
    'inputs'?: Array<string>;
}
/**
 * GermlineCNVOccurrence represents a germline CNV occurrence
 * @export
 * @interface GermlineCNVOccurrence
 */
export interface GermlineCNVOccurrence {
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'aliquot'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'bc'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof GermlineCNVOccurrence
     */
    'calls'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'chromosome': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof GermlineCNVOccurrence
     */
    'ciend'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof GermlineCNVOccurrence
     */
    'cipos'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'cn'?: number;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'cnv_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineCNVOccurrence
     */
    'cytoband'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'end': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'gnomad_sc'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'gnomad_sf'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'gnomad_sn'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'length': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'nb_genes'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'nb_snv'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof GermlineCNVOccurrence
     */
    'pe'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'quality'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'reflen'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'seq_id': number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'sm'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof GermlineCNVOccurrence
     */
    'svlen'?: number;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'svtype'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineCNVOccurrence
     */
    'symbol'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GermlineCNVOccurrence
     */
    'type': string;
}
/**
 * GermlineSNVOccurrence represents a germline SNV occurrence
 * @export
 * @interface GermlineSNVOccurrence
 */
export interface GermlineSNVOccurrence {
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'ad_ratio': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'chromosome': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineSNVOccurrence
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_acmg_classification': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_acmg_evidence': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_gene_combined_score': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_moi': string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'exomiser_variant_score': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'genotype_quality': number;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {boolean}
     * @memberof GermlineSNVOccurrence
     */
    'has_interpretation': boolean;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'hgvsg': string;
    /**
     * 
     * @type {boolean}
     * @memberof GermlineSNVOccurrence
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GermlineSNVOccurrence
     */
    'is_mane_plus'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GermlineSNVOccurrence
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'locus': string;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'locus_id': string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'max_impact_score': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineSNVOccurrence
     */
    'omim_inheritance_code'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'pc_wgs'?: number;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'pf_wgs': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GermlineSNVOccurrence
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'pn_wgs'?: number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'seq_id': number;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'start': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof GermlineSNVOccurrence
     */
    'task_id': number;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'variant_class': string;
    /**
     * 
     * @type {VepImpact}
     * @memberof GermlineSNVOccurrence
     */
    'vep_impact'?: VepImpact;
    /**
     * 
     * @type {string}
     * @memberof GermlineSNVOccurrence
     */
    'zygosity': string;
}


/**
 * GetBatchResponse represents the response returned when retrieving a batch
 * @export
 * @interface GetBatchResponse
 */
export interface GetBatchResponse {
    /**
     * 
     * @type {string}
     * @memberof GetBatchResponse
     */
    'batch_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBatchResponse
     */
    'created_on'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetBatchResponse
     */
    'dry_run'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetBatchResponse
     */
    'finished_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBatchResponse
     */
    'id'?: string;
    /**
     * 
     * @type {BatchReport}
     * @memberof GetBatchResponse
     */
    'report'?: BatchReport;
    /**
     * 
     * @type {string}
     * @memberof GetBatchResponse
     */
    'started_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBatchResponse
     */
    'status'?: string;
    /**
     * 
     * @type {BatchSummary}
     * @memberof GetBatchResponse
     */
    'summary'?: BatchSummary;
    /**
     * 
     * @type {string}
     * @memberof GetBatchResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface IGVTrackEnriched
 */
export interface IGVTrackEnriched {
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'family_role'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'format'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'indexURL'?: string;
    /**
     * 
     * @type {number}
     * @memberof IGVTrackEnriched
     */
    'indexURLExpireAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof IGVTrackEnriched
     */
    'patient_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'sex'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGVTrackEnriched
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof IGVTrackEnriched
     */
    'urlExpireAt'?: number;
}
/**
 * 
 * @export
 * @interface IGVTracks
 */
export interface IGVTracks {
    /**
     * 
     * @type {Array<IGVTrackEnriched>}
     * @memberof IGVTracks
     */
    'alignment'?: Array<IGVTrackEnriched>;
}
/**
 * 
 * @export
 * @interface InputDocumentBatch
 */
export interface InputDocumentBatch {
    /**
     * 
     * @type {string}
     * @memberof InputDocumentBatch
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface InterpretationGermline
 */
export interface InterpretationGermline {
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'case_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'classification'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationGermline
     */
    'classification_criterias'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'condition'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'interpretation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'locus_id'?: string;
    /**
     * 
     * @type {InterpretationMetadata}
     * @memberof InterpretationGermline
     */
    'metadata'?: InterpretationMetadata;
    /**
     * 
     * @type {Array<InterpretationPubmed>}
     * @memberof InterpretationGermline
     */
    'pubmed'?: Array<InterpretationPubmed>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'sequencing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationGermline
     */
    'transmission_modes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_by_name'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationMetadata
 */
export interface InterpretationMetadata {
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'analysis_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'patient_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'variant_hash'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationPubmed
 */
export interface InterpretationPubmed {
    /**
     * 
     * @type {string}
     * @memberof InterpretationPubmed
     */
    'citation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationPubmed
     */
    'citation_id'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationSomatic
 */
export interface InterpretationSomatic {
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'case_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'clinical_utility'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'interpretation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'locus_id'?: string;
    /**
     * 
     * @type {InterpretationMetadata}
     * @memberof InterpretationSomatic
     */
    'metadata'?: InterpretationMetadata;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'oncogenicity'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationSomatic
     */
    'oncogenicity_classification_criterias'?: Array<string>;
    /**
     * 
     * @type {Array<InterpretationPubmed>}
     * @memberof InterpretationSomatic
     */
    'pubmed'?: Array<InterpretationPubmed>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'sequencing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'tumoral_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_by_name'?: string;
}
/**
 * 
 * @export
 * @interface LeafContent
 */
export interface LeafContent {
    /**
     * 
     * @type {string}
     * @memberof LeafContent
     */
    'field'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof LeafContent
     */
    'value'?: Array<any>;
}
/**
 * Body of a list request with search criteria
 * @export
 * @interface ListBodyWithCriteria
 */
export interface ListBodyWithCriteria {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListBodyWithCriteria
     */
    'additional_fields'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithCriteria
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithCriteria
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithCriteria
     */
    'page_index'?: number;
    /**
     * 
     * @type {Array<SearchCriterion>}
     * @memberof ListBodyWithCriteria
     */
    'search_criteria'?: Array<SearchCriterion>;
    /**
     * 
     * @type {Array<SortBody>}
     * @memberof ListBodyWithCriteria
     */
    'sort'?: Array<SortBody>;
}
/**
 * Body of a list request
 * @export
 * @interface ListBodyWithSqon
 */
export interface ListBodyWithSqon {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListBodyWithSqon
     */
    'additional_fields'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithSqon
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithSqon
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBodyWithSqon
     */
    'page_index'?: number;
    /**
     * 
     * @type {Array<SortBody>}
     * @memberof ListBodyWithSqon
     */
    'sort'?: Array<SortBody>;
    /**
     * 
     * @type {Sqon}
     * @memberof ListBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * 
 * @export
 * @interface ObservationCategoricalBatch
 */
export interface ObservationCategoricalBatch {
    /**
     * 
     * @type {string}
     * @memberof ObservationCategoricalBatch
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ObservationCategoricalBatch
     */
    'interpretation_code'?: ObservationCategoricalBatchInterpretationCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof ObservationCategoricalBatch
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObservationCategoricalBatch
     */
    'onset_code': string;
    /**
     * 
     * @type {string}
     * @memberof ObservationCategoricalBatch
     */
    'system': string;
    /**
     * 
     * @type {string}
     * @memberof ObservationCategoricalBatch
     */
    'value': string;
}

export const ObservationCategoricalBatchInterpretationCodeEnum = {
    Positive: 'positive',
    Negative: 'negative'
} as const;

export type ObservationCategoricalBatchInterpretationCodeEnum = typeof ObservationCategoricalBatchInterpretationCodeEnum[keyof typeof ObservationCategoricalBatchInterpretationCodeEnum];

/**
 * 
 * @export
 * @interface ObservationTextBatch
 */
export interface ObservationTextBatch {
    /**
     * 
     * @type {string}
     * @memberof ObservationTextBatch
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ObservationTextBatch
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface OmimGenePanel
 */
export interface OmimGenePanel {
    /**
     * 
     * @type {Array<string>}
     * @memberof OmimGenePanel
     */
    'inheritance_code'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OmimGenePanel
     */
    'omim_phenotype_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OmimGenePanel
     */
    'panel'?: string;
}
/**
 * 
 * @export
 * @interface OutputDocumentBatch
 */
export interface OutputDocumentBatch {
    /**
     * 
     * @type {string}
     * @memberof OutputDocumentBatch
     */
    'data_category_code': string;
    /**
     * 
     * @type {string}
     * @memberof OutputDocumentBatch
     */
    'data_type_code': string;
    /**
     * 
     * @type {string}
     * @memberof OutputDocumentBatch
     */
    'format_code': string;
    /**
     * 
     * @type {string}
     * @memberof OutputDocumentBatch
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutputDocumentBatch
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OutputDocumentBatch
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof OutputDocumentBatch
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface PatientBatch
 */
export interface PatientBatch {
    /**
     * 
     * @type {string}
     * @memberof PatientBatch
     */
    'date_of_birth': string;
    /**
     * 
     * @type {string}
     * @memberof PatientBatch
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatientBatch
     */
    'jhn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatientBatch
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatientBatch
     */
    'life_status_code': PatientBatchLifeStatusCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatientBatch
     */
    'patient_organization_code': string;
    /**
     * 
     * @type {string}
     * @memberof PatientBatch
     */
    'sex_code': PatientBatchSexCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatientBatch
     */
    'submitter_patient_id': string;
    /**
     * 
     * @type {string}
     * @memberof PatientBatch
     */
    'submitter_patient_id_type': string;
}

export const PatientBatchLifeStatusCodeEnum = {
    Alive: 'alive',
    Deceased: 'deceased',
    Unknown: 'unknown'
} as const;

export type PatientBatchLifeStatusCodeEnum = typeof PatientBatchLifeStatusCodeEnum[keyof typeof PatientBatchLifeStatusCodeEnum];
export const PatientBatchSexCodeEnum = {
    Male: 'male',
    Female: 'female',
    Unknown: 'unknown'
} as const;

export type PatientBatchSexCodeEnum = typeof PatientBatchSexCodeEnum[keyof typeof PatientBatchSexCodeEnum];

/**
 * 
 * @export
 * @interface PubmedCitation
 */
export interface PubmedCitation {
    /**
     * 
     * @type {string}
     * @memberof PubmedCitation
     */
    'id'?: string;
    /**
     * 
     * @type {PubmedCitationDetails}
     * @memberof PubmedCitation
     */
    'nlm'?: PubmedCitationDetails;
}
/**
 * 
 * @export
 * @interface PubmedCitationDetails
 */
export interface PubmedCitationDetails {
    /**
     * 
     * @type {string}
     * @memberof PubmedCitationDetails
     */
    'format'?: string;
}
/**
 * 
 * @export
 * @interface SampleBatch
 */
export interface SampleBatch {
    /**
     * 
     * @type {string}
     * @memberof SampleBatch
     */
    'histology_code': SampleBatchHistologyCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof SampleBatch
     */
    'patient_organization_code': string;
    /**
     * 
     * @type {string}
     * @memberof SampleBatch
     */
    'sample_organization_code': string;
    /**
     * 
     * @type {string}
     * @memberof SampleBatch
     */
    'submitter_parent_sample_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SampleBatch
     */
    'submitter_patient_id': string;
    /**
     * 
     * @type {string}
     * @memberof SampleBatch
     */
    'submitter_sample_id': string;
    /**
     * 
     * @type {string}
     * @memberof SampleBatch
     */
    'tissue_site'?: string;
    /**
     * 
     * @type {string}
     * @memberof SampleBatch
     */
    'type_code': string;
}

export const SampleBatchHistologyCodeEnum = {
    Tumoral: 'tumoral',
    Normal: 'normal'
} as const;

export type SampleBatchHistologyCodeEnum = typeof SampleBatchHistologyCodeEnum[keyof typeof SampleBatchHistologyCodeEnum];

/**
 * 
 * @export
 * @interface SavedFilter
 */
export interface SavedFilter {
    /**
     * 
     * @type {string}
     * @memberof SavedFilter
     */
    'created_on': string;
    /**
     * 
     * @type {boolean}
     * @memberof SavedFilter
     */
    'favorite': boolean;
    /**
     * 
     * @type {string}
     * @memberof SavedFilter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SavedFilter
     */
    'name': string;
    /**
     * 
     * @type {Array<Sqon>}
     * @memberof SavedFilter
     */
    'queries': Array<Sqon>;
    /**
     * 
     * @type {SavedFilterType}
     * @memberof SavedFilter
     */
    'type': SavedFilterType;
    /**
     * 
     * @type {string}
     * @memberof SavedFilter
     */
    'updated_on': string;
    /**
     * 
     * @type {string}
     * @memberof SavedFilter
     */
    'user_id': string;
}


/**
 * 
 * @export
 * @interface SavedFilterCreationInput
 */
export interface SavedFilterCreationInput {
    /**
     * 
     * @type {string}
     * @memberof SavedFilterCreationInput
     */
    'name': string;
    /**
     * 
     * @type {Array<Sqon>}
     * @memberof SavedFilterCreationInput
     */
    'queries': Array<Sqon>;
    /**
     * 
     * @type {SavedFilterType}
     * @memberof SavedFilterCreationInput
     */
    'type': SavedFilterType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SavedFilterType = {
    GERMLINE_SNV_OCCURRENCE: 'germline_snv_occurrence',
    GERMLINE_CNV_OCCURRENCE: 'germline_cnv_occurrence',
    SOMATIC_SNV_OCCURRENCE: 'somatic_snv_occurrence',
    SOMATIC_CNV_OCCURRENCE: 'somatic_cnv_occurrence',
    GERMLINE_SNV_VARIANT: 'germline_snv_variant',
    GERMLINE_CNV_VARIANT: 'germline_cnv_variant',
    SOMATIC_SNV_VARIANT: 'somatic_snv_variant',
    SOMATIC_CNV_VARIANT: 'somatic_cnv_variant'
} as const;

export type SavedFilterType = typeof SavedFilterType[keyof typeof SavedFilterType];


/**
 * 
 * @export
 * @interface SavedFilterUpdateInput
 */
export interface SavedFilterUpdateInput {
    /**
     * 
     * @type {boolean}
     * @memberof SavedFilterUpdateInput
     */
    'favorite': boolean;
    /**
     * 
     * @type {string}
     * @memberof SavedFilterUpdateInput
     */
    'name': string;
    /**
     * 
     * @type {Array<Sqon>}
     * @memberof SavedFilterUpdateInput
     */
    'queries': Array<Sqon>;
}
/**
 * 
 * @export
 * @interface SearchCriterion
 */
export interface SearchCriterion {
    /**
     * 
     * @type {string}
     * @memberof SearchCriterion
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchCriterion
     */
    'operator'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof SearchCriterion
     */
    'value'?: Array<any>;
}
/**
 * Sequencing represents a sequencing
 * @export
 * @interface Sequencing
 */
export interface Sequencing {
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'affected_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'analysis_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'experimental_strategy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'family_role'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'part'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'patient_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'request_priority'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'sample_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'seq_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'sex'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'task_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'vcf_filepath'?: string;
}
/**
 * 
 * @export
 * @interface SequencingExperimentBatch
 */
export interface SequencingExperimentBatch {
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'aliquot': string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'capture_kit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'experimental_strategy_code': SequencingExperimentBatchExperimentalStrategyCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'platform_code': string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'run_alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'run_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'run_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'sample_organization_code': string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'sequencing_lab_code': string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'sequencing_read_technology_code': SequencingExperimentBatchSequencingReadTechnologyCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'status_code': SequencingExperimentBatchStatusCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentBatch
     */
    'submitter_sample_id': string;
}

export const SequencingExperimentBatchExperimentalStrategyCodeEnum = {
    Wgs: 'wgs',
    Wxs: 'wxs',
    Rnaseq: 'rnaseq',
    TargetedDna: 'targeted_dna'
} as const;

export type SequencingExperimentBatchExperimentalStrategyCodeEnum = typeof SequencingExperimentBatchExperimentalStrategyCodeEnum[keyof typeof SequencingExperimentBatchExperimentalStrategyCodeEnum];
export const SequencingExperimentBatchSequencingReadTechnologyCodeEnum = {
    ShortRead: 'short_read',
    LongRead: 'long_read'
} as const;

export type SequencingExperimentBatchSequencingReadTechnologyCodeEnum = typeof SequencingExperimentBatchSequencingReadTechnologyCodeEnum[keyof typeof SequencingExperimentBatchSequencingReadTechnologyCodeEnum];
export const SequencingExperimentBatchStatusCodeEnum = {
    Unknown: 'unknown',
    Draft: 'draft',
    Revoke: 'revoke',
    Completed: 'completed',
    Incomplete: 'incomplete',
    Submitted: 'submitted',
    InProgress: 'in_progress'
} as const;

export type SequencingExperimentBatchStatusCodeEnum = typeof SequencingExperimentBatchStatusCodeEnum[keyof typeof SequencingExperimentBatchStatusCodeEnum];

/**
 * 
 * @export
 * @interface SequencingExperimentDetail
 */
export interface SequencingExperimentDetail {
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'aliquot'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'capture_kit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'created_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'experimental_strategy_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'experimental_strategy_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'histology_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof SequencingExperimentDetail
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'platform_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'run_alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'run_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'run_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof SequencingExperimentDetail
     */
    'sample_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'sample_type_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof SequencingExperimentDetail
     */
    'seq_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'sequencing_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'sequencing_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'sequencing_read_technology_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'sequencing_read_technology_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'status_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'submitter_sample_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'tissue_site'?: string;
    /**
     * 
     * @type {string}
     * @memberof SequencingExperimentDetail
     */
    'updated_on'?: string;
}
/**
 * 
 * @export
 * @interface SortBody
 */
export interface SortBody {
    /**
     * 
     * @type {string}
     * @memberof SortBody
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortBody
     */
    'order'?: SortBodyOrderEnum;
}

export const SortBodyOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortBodyOrderEnum = typeof SortBodyOrderEnum[keyof typeof SortBodyOrderEnum];

/**
 * 
 * @export
 * @interface Sqon
 */
export interface Sqon {
    /**
     * 
     * @type {SqonContent}
     * @memberof Sqon
     */
    'content'?: SqonContent;
    /**
     * 
     * @type {string}
     * @memberof Sqon
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sqon
     */
    'op'?: SqonOpEnum;
}

export const SqonOpEnum = {
    In: 'in',
    And: 'and',
    Or: 'or',
    Not: 'not',
    Between: 'between',
    GreaterThan: '>',
    LessThan: '<',
    GreaterThanOrEqualTo: '>=',
    LessThanOrEqualTo: '<=',
    NotIn: 'not-in',
    All: 'all'
} as const;

export type SqonOpEnum = typeof SqonOpEnum[keyof typeof SqonOpEnum];

/**
 * @type SqonContent
 * @export
 */
export type SqonContent = Array<Sqon> | LeafContent;

/**
 * Statistics represents statistics about a column
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * Max for numeric facet
     * @type {number}
     * @memberof Statistics
     */
    'max'?: number;
    /**
     * Min for numeric facet
     * @type {number}
     * @memberof Statistics
     */
    'min'?: number;
    /**
     * To tell UI if it\'s an integer or a decimal
     * @type {string}
     * @memberof Statistics
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface StatisticsBodyWithSqon
 */
export interface StatisticsBodyWithSqon {
    /**
     * 
     * @type {string}
     * @memberof StatisticsBodyWithSqon
     */
    'field'?: string;
    /**
     * 
     * @type {Sqon}
     * @memberof StatisticsBodyWithSqon
     */
    'sqon'?: Sqon;
}
/**
 * 
 * @export
 * @interface Term
 */
export interface Term {
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'onset_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'term'?: string;
}
/**
 * 
 * @export
 * @interface Transcript
 */
export interface Transcript {
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Transcript
     */
    'consequences'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'dann_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'dna_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'exon_rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'exon_total'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Transcript
     */
    'is_canonical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transcript
     */
    'is_mane_plus'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transcript
     */
    'is_mane_select'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'lrt_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'lrt_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'phyloP17way_primate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'polyphen2_hvar_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'polyphen2_hvar_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transcript
     */
    'sift_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcript
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {VepImpact}
     * @memberof Transcript
     */
    'vep_impact'?: VepImpact;
}


/**
 * 
 * @export
 * @interface UserPreference
 */
export interface UserPreference {
    /**
     * 
     * @type {object}
     * @memberof UserPreference
     */
    'content': object;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface UserSet
 */
export interface UserSet {
    /**
     * 
     * @type {boolean}
     * @memberof UserSet
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSet
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface UtilsPreSignedURL
 */
export interface UtilsPreSignedURL {
    /**
     * 
     * @type {number}
     * @memberof UtilsPreSignedURL
     */
    'expires_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof UtilsPreSignedURL
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface VariantCasesCount
 */
export interface VariantCasesCount {
    /**
     * 
     * @type {number}
     * @memberof VariantCasesCount
     */
    'count_interpreted': number;
    /**
     * 
     * @type {number}
     * @memberof VariantCasesCount
     */
    'count_uninterpreted': number;
}
/**
 * 
 * @export
 * @interface VariantCasesFilters
 */
export interface VariantCasesFilters {
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof VariantCasesFilters
     */
    'analysis_catalog_code': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof VariantCasesFilters
     */
    'classification': Array<Aggregation>;
    /**
     * 
     * @type {Array<Aggregation>}
     * @memberof VariantCasesFilters
     */
    'diagnosis_lab_code': Array<Aggregation>;
}
/**
 * 
 * @export
 * @interface VariantConsequence
 */
export interface VariantConsequence {
    /**
     * 
     * @type {string}
     * @memberof VariantConsequence
     */
    'biotype'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantConsequence
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantConsequence
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VariantConsequence
     */
    'is_picked'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VariantConsequence
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantConsequence
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantConsequence
     */
    'symbol'?: string;
    /**
     * 
     * @type {Array<Transcript>}
     * @memberof VariantConsequence
     */
    'transcripts'?: Array<Transcript>;
}
/**
 * 
 * @export
 * @interface VariantExpandedInterpretedCase
 */
export interface VariantExpandedInterpretedCase {
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantExpandedInterpretedCase
     */
    'classification_criterias': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantExpandedInterpretedCase
     */
    'gene_symbol': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantExpandedInterpretedCase
     */
    'inheritances': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantExpandedInterpretedCase
     */
    'interpretation': string;
    /**
     * 
     * @type {string}
     * @memberof VariantExpandedInterpretedCase
     */
    'interpreter_name': string;
    /**
     * 
     * @type {number}
     * @memberof VariantExpandedInterpretedCase
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantExpandedInterpretedCase
     */
    'patient_sex_code': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantExpandedInterpretedCase
     */
    'pubmed_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface VariantHeader
 */
export interface VariantHeader {
    /**
     * 
     * @type {string}
     * @memberof VariantHeader
     */
    'assembly_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantHeader
     */
    'hgvsg': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantHeader
     */
    'source'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VariantInterpretedCase
 */
export interface VariantInterpretedCase {
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'affected_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'analysis_catalog_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'analysis_catalog_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCase
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'classification': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'condition_id': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'condition_name': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'diagnosis_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'diagnosis_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'interpretation_updated_on': string;
    /**
     * 
     * @type {Array<Term>}
     * @memberof VariantInterpretedCase
     */
    'observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCase
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'relationship_to_proband'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCase
     */
    'seq_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'submitter_sample_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'transcript_id': string;
    /**
     * 
     * @type {string}
     * @memberof VariantInterpretedCase
     */
    'zygosity': string;
}
/**
 * 
 * @export
 * @interface VariantInterpretedCasesSearchResponse
 */
export interface VariantInterpretedCasesSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof VariantInterpretedCasesSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<VariantInterpretedCase>}
     * @memberof VariantInterpretedCasesSearchResponse
     */
    'list': Array<VariantInterpretedCase>;
}
/**
 * 
 * @export
 * @interface VariantOverview
 */
export interface VariantOverview {
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'clinvar_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'dann_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'dna_change'?: string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof VariantOverview
     */
    'exomiser_acmg_classification_counts'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'exon_rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'exon_total'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof VariantOverview
     */
    'interpretation_classification_counts'?: { [key: string]: number; };
    /**
     * 
     * @type {boolean}
     * @memberof VariantOverview
     */
    'is_canonical': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VariantOverview
     */
    'is_mane_plus': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VariantOverview
     */
    'is_mane_select': boolean;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'locus': string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'lrt_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'lrt_score'?: number;
    /**
     * 
     * @type {Array<OmimGenePanel>}
     * @memberof VariantOverview
     */
    'omim_conditions'?: Array<OmimGenePanel>;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pc_wgs'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pf_wgs': number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'phyloP17way_primate'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pn_wgs'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'polyphen2_hvar_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'polyphen2_hvar_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'sift_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {VepImpact}
     * @memberof VariantOverview
     */
    'vep_impact'?: VepImpact;
}


/**
 * 
 * @export
 * @interface VariantUninterpretedCase
 */
export interface VariantUninterpretedCase {
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'affected_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'analysis_catalog_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'analysis_catalog_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCase
     */
    'case_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'diagnosis_lab_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'diagnosis_lab_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'exomiser_acmg_classification'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantUninterpretedCase
     */
    'exomiser_acmg_evidence'?: Array<string>;
    /**
     * 
     * @type {Array<Term>}
     * @memberof VariantUninterpretedCase
     */
    'observed_phenotypes'?: Array<Term>;
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCase
     */
    'patient_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'primary_condition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'primary_condition_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'relationship_to_proband'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCase
     */
    'seq_id': number;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'status_code': string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'submitter_sample_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'updated_on': string;
    /**
     * 
     * @type {string}
     * @memberof VariantUninterpretedCase
     */
    'zygosity': string;
}
/**
 * 
 * @export
 * @interface VariantUninterpretedCasesSearchResponse
 */
export interface VariantUninterpretedCasesSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof VariantUninterpretedCasesSearchResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<VariantUninterpretedCase>}
     * @memberof VariantUninterpretedCasesSearchResponse
     */
    'list': Array<VariantUninterpretedCase>;
}
/**
 * TODO
 * @export
 * @enum {string}
 */

export const VepImpact = {
    MODIFIER: 'MODIFIER',
    LOW: 'LOW',
    MODERATE: 'MODERATE',
    HIGH: 'HIGH'
} as const;

export type VepImpact = typeof VepImpact[keyof typeof VepImpact];



/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a batch by ID
         * @summary Retrieve a batch by ID
         * @param {string} batchId Batch ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch: async (batchId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatch', 'batchId', batchId)
            const localVarPath = `/batches/{batchId}`
                .replace(`{${"batchId"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a batch by ID
         * @summary Retrieve a batch by ID
         * @param {string} batchId Batch ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatch(batchId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatch(batchId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.getBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Retrieve a batch by ID
         * @summary Retrieve a batch by ID
         * @param {string} batchId Batch ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch(batchId: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<GetBatchResponse> {
            return localVarFp.getBatch(batchId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Retrieve a batch by ID
     * @summary Retrieve a batch by ID
     * @param {string} batchId Batch ID
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatch(batchId: string, body?: object, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatch(batchId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CasesApi - axios parameter creator
 * @export
 */
export const CasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCases: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('autocompleteCases', 'prefix', prefix)
            const localVarPath = `/cases/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {number} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntity: async (caseId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntity', 'caseId', caseId)
            const localVarPath = `/cases/{case_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve DocumentFilters documents filters for a specific case
         * @summary Get DocumentFilters documents filters for a specific case
         * @param {number} caseId Case ID
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsFilters: async (caseId: number, filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntityDocumentsFilters', 'caseId', caseId)
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('caseEntityDocumentsFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/cases/{case_id}/documents/filters`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for DocumentResult list for a case entity
         * @summary Search DocumentResult list for a case entity
         * @param {number} caseId Case ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsSearch: async (caseId: number, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('caseEntityDocumentsSearch', 'caseId', caseId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('caseEntityDocumentsSearch', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/cases/{case_id}/documents/search`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesFilters: async (filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('casesFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/cases/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new case batch
         * @summary Create a new case batch
         * @param {CreateCaseBatchBody} createCaseBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCaseBatch: async (createCaseBatchBody: CreateCaseBatchBody, dryRun?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCaseBatchBody' is not null or undefined
            assertParamExists('postCaseBatch', 'createCaseBatchBody', createCaseBatchBody)
            const localVarPath = `/cases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCaseBatchBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCases: async (listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('searchCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/cases/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CasesApi - functional programming interface
 * @export
 */
export const CasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CasesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteCases(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.autocompleteCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {number} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntity(caseId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntity(caseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve DocumentFilters documents filters for a specific case
         * @summary Get DocumentFilters documents filters for a specific case
         * @param {number} caseId Case ID
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntityDocumentsFilters(caseId: number, filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntityDocumentsFilters(caseId, filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntityDocumentsFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for DocumentResult list for a case entity
         * @summary Search DocumentResult list for a case entity
         * @param {number} caseId Case ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseEntityDocumentsSearch(caseId: number, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseEntityDocumentsSearch(caseId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.caseEntityDocumentsSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesFilters(filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.casesFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new case batch
         * @summary Create a new case batch
         * @param {CreateCaseBatchBody} createCaseBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCaseBatch(createCaseBatchBody: CreateCaseBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCaseBatch(createCaseBatchBody, dryRun, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.postCaseBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCases(listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CasesApi.searchCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CasesApi - factory interface
 * @export
 */
export const CasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CasesApiFp(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutocompleteResult>> {
            return localVarFp.autocompleteCases(prefix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve CaseEntity by its ID
         * @summary Get CaseEntity case entity
         * @param {number} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntity(caseId: number, options?: RawAxiosRequestConfig): AxiosPromise<CaseEntity> {
            return localVarFp.caseEntity(caseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve DocumentFilters documents filters for a specific case
         * @summary Get DocumentFilters documents filters for a specific case
         * @param {number} caseId Case ID
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsFilters(caseId: number, filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFilters> {
            return localVarFp.caseEntityDocumentsFilters(caseId, filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for DocumentResult list for a case entity
         * @summary Search DocumentResult list for a case entity
         * @param {number} caseId Case ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseEntityDocumentsSearch(caseId: number, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsSearchResponse> {
            return localVarFp.caseEntityDocumentsSearch(caseId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve CaseFilters cases filters
         * @summary Get CaseFilters cases filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<CaseFilters> {
            return localVarFp.casesFilters(filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new case batch
         * @summary Create a new case batch
         * @param {CreateCaseBatchBody} createCaseBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCaseBatch(createCaseBatchBody: CreateCaseBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CreateBatchResponse> {
            return localVarFp.postCaseBatch(createCaseBatchBody, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Search cases
         * @summary Search cases
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<CasesSearchResponse> {
            return localVarFp.searchCases(listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CasesApi - object-oriented interface
 * @export
 * @class CasesApi
 * @extends {BaseAPI}
 */
export class CasesApi extends BaseAPI {
    /**
     * Retrieve AutocompleteResult list of ids matching prefix
     * @summary Get AutocompleteResult list of matching prefix
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public autocompleteCases(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).autocompleteCases(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve CaseEntity by its ID
     * @summary Get CaseEntity case entity
     * @param {number} caseId Case ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public caseEntity(caseId: number, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntity(caseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve DocumentFilters documents filters for a specific case
     * @summary Get DocumentFilters documents filters for a specific case
     * @param {number} caseId Case ID
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public caseEntityDocumentsFilters(caseId: number, filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntityDocumentsFilters(caseId, filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for DocumentResult list for a case entity
     * @summary Search DocumentResult list for a case entity
     * @param {number} caseId Case ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public caseEntityDocumentsSearch(caseId: number, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).caseEntityDocumentsSearch(caseId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve CaseFilters cases filters
     * @summary Get CaseFilters cases filters
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public casesFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).casesFilters(filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new case batch
     * @summary Create a new case batch
     * @param {CreateCaseBatchBody} createCaseBatchBody Create Body
     * @param {boolean} [dryRun] Dry Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public postCaseBatch(createCaseBatchBody: CreateCaseBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).postCaseBatch(createCaseBatchBody, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search cases
     * @summary Search cases
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    public searchCases(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return CasesApiFp(this.configuration).searchCases(listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteDocuments: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('autocompleteDocuments', 'prefix', prefix)
            const localVarPath = `/documents/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve DocumentFilters documents filters
         * @summary Get DocumentFilters documents filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilters: async (filtersBodyWithCriteria: FiltersBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filtersBodyWithCriteria' is not null or undefined
            assertParamExists('documentsFilters', 'filtersBodyWithCriteria', filtersBodyWithCriteria)
            const localVarPath = `/documents/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filtersBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a pre-signed S3 download URL for a document
         * @summary Get pre-signed S3 download URL for a document
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentDownloadUrl: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentDownloadUrl', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/download_url`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search documents
         * @summary Search documents
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments: async (listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('searchDocuments', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/documents/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteDocuments(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteDocuments(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.autocompleteDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve DocumentFilters documents filters
         * @summary Get DocumentFilters documents filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilters(filtersBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a pre-signed S3 download URL for a document
         * @summary Get pre-signed S3 download URL for a document
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentDownloadUrl(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsPreSignedURL>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentDownloadUrl(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.getDocumentDownloadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search documents
         * @summary Search documents
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocuments(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDocuments(listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Retrieve AutocompleteResult list of ids matching prefix
         * @summary Get AutocompleteResult list of matching prefix
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteDocuments(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutocompleteResult>> {
            return localVarFp.autocompleteDocuments(prefix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve DocumentFilters documents filters
         * @summary Get DocumentFilters documents filters
         * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFilters> {
            return localVarFp.documentsFilters(filtersBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a pre-signed S3 download URL for a document
         * @summary Get pre-signed S3 download URL for a document
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentDownloadUrl(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<UtilsPreSignedURL> {
            return localVarFp.getDocumentDownloadUrl(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search documents
         * @summary Search documents
         * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsSearchResponse> {
            return localVarFp.searchDocuments(listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Retrieve AutocompleteResult list of ids matching prefix
     * @summary Get AutocompleteResult list of matching prefix
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public autocompleteDocuments(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).autocompleteDocuments(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve DocumentFilters documents filters
     * @summary Get DocumentFilters documents filters
     * @param {FiltersBodyWithCriteria} filtersBodyWithCriteria Filters Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilters(filtersBodyWithCriteria: FiltersBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilters(filtersBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a pre-signed S3 download URL for a document
     * @summary Get pre-signed S3 download URL for a document
     * @param {string} documentId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public getDocumentDownloadUrl(documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).getDocumentDownloadUrl(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search documents
     * @summary Search documents
     * @param {ListBodyWithCriteria} listBodyWithCriteria List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public searchDocuments(listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchDocuments(listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GenesApi - axios parameter creator
 * @export
 */
export const GenesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteGene list of genes matching input string with highlighted
         * @summary Get AutoCompleteGene list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('geneAutoComplete', 'prefix', prefix)
            const localVarPath = `/genes/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve GeneResult list of genes matching input strings
         * @summary Post search GeneResult list of matching input strings
         * @param {GeneSearchBody} geneSearchBody Search Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneSearch: async (geneSearchBody: GeneSearchBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'geneSearchBody' is not null or undefined
            assertParamExists('geneSearch', 'geneSearchBody', geneSearchBody)
            const localVarPath = `/genes/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geneSearchBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenesApi - functional programming interface
 * @export
 */
export const GenesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteGene list of genes matching input string with highlighted
         * @summary Get AutoCompleteGene list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteGene>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenesApi.geneAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve GeneResult list of genes matching input strings
         * @summary Post search GeneResult list of matching input strings
         * @param {GeneSearchBody} geneSearchBody Search Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneSearch(geneSearchBody: GeneSearchBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneSearch(geneSearchBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenesApi.geneSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GenesApi - factory interface
 * @export
 */
export const GenesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenesApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteGene list of genes matching input string with highlighted
         * @summary Get AutoCompleteGene list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteGene>> {
            return localVarFp.geneAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve GeneResult list of genes matching input strings
         * @summary Post search GeneResult list of matching input strings
         * @param {GeneSearchBody} geneSearchBody Search Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneSearch(geneSearchBody: GeneSearchBody, options?: RawAxiosRequestConfig): AxiosPromise<Array<GeneResult>> {
            return localVarFp.geneSearch(geneSearchBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenesApi - object-oriented interface
 * @export
 * @class GenesApi
 * @extends {BaseAPI}
 */
export class GenesApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteGene list of genes matching input string with highlighted
     * @summary Get AutoCompleteGene list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenesApi
     */
    public geneAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return GenesApiFp(this.configuration).geneAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve GeneResult list of genes matching input strings
     * @summary Post search GeneResult list of matching input strings
     * @param {GeneSearchBody} geneSearchBody Search Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenesApi
     */
    public geneSearch(geneSearchBody: GeneSearchBody, options?: RawAxiosRequestConfig) {
        return GenesApiFp(this.configuration).geneSearch(geneSearchBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HpoApi - axios parameter creator
 * @export
 */
export const HpoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('hpoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/hpo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HpoApi - functional programming interface
 * @export
 */
export const HpoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HpoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hpoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HpoApi.hpoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HpoApi - factory interface
 * @export
 */
export const HpoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HpoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.hpoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HpoApi - object-oriented interface
 * @export
 * @class HpoApi
 * @extends {BaseAPI}
 */
export class HpoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HpoApi
     */
    public hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return HpoApiFp(this.configuration).hpoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IgvApi - axios parameter creator
 * @export
 */
export const IgvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get IGV tracks for a case
         * @summary Get IGV
         * @param {string} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIGV: async (caseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('getIGV', 'caseId', caseId)
            const localVarPath = `/igv/{case_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IgvApi - functional programming interface
 * @export
 */
export const IgvApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IgvApiAxiosParamCreator(configuration)
    return {
        /**
         * Get IGV tracks for a case
         * @summary Get IGV
         * @param {string} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIGV(caseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IGVTracks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIGV(caseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IgvApi.getIGV']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IgvApi - factory interface
 * @export
 */
export const IgvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IgvApiFp(configuration)
    return {
        /**
         * Get IGV tracks for a case
         * @summary Get IGV
         * @param {string} caseId Case ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIGV(caseId: string, options?: RawAxiosRequestConfig): AxiosPromise<IGVTracks> {
            return localVarFp.getIGV(caseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IgvApi - object-oriented interface
 * @export
 * @class IgvApi
 * @extends {BaseAPI}
 */
export class IgvApi extends BaseAPI {
    /**
     * Get IGV tracks for a case
     * @summary Get IGV
     * @param {string} caseId Case ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IgvApi
     */
    public getIGV(caseId: string, options?: RawAxiosRequestConfig) {
        return IgvApiFp(this.configuration).getIGV(caseId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InterpretationsApi - axios parameter creator
 * @export
 */
export const InterpretationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline: async (caseId: string, sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'caseId', caseId)
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/v2/germline/{case_id}/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getInterpretationGermlineDeprecated: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationGermlineDeprecated', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationGermlineDeprecated', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationGermlineDeprecated', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic: async (caseId: string, sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'caseId', caseId)
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/v2/somatic/{case_id}/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getInterpretationSomaticDeprecated: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationSomaticDeprecated', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationSomaticDeprecated', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationSomaticDeprecated', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation: async (citationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'citationId' is not null or undefined
            assertParamExists('getPubmedCitation', 'citationId', citationId)
            const localVarPath = `/interpretations/pubmed/{citation_id}`
                .replace(`{${"citation_id"}}`, encodeURIComponent(String(citationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline: async (caseId: string, sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'caseId', caseId)
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationGermline' is not null or undefined
            assertParamExists('postInterpretationGermline', 'interpretationGermline', interpretationGermline)
            const localVarPath = `/interpretations/v2/germline/{case_id}/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationGermline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        postInterpretationGermlineDeprecated: async (sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationGermlineDeprecated', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationGermlineDeprecated', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationGermlineDeprecated', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationGermline' is not null or undefined
            assertParamExists('postInterpretationGermlineDeprecated', 'interpretationGermline', interpretationGermline)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationGermline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic: async (caseId: string, sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'caseId', caseId)
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationSomatic' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'interpretationSomatic', interpretationSomatic)
            const localVarPath = `/interpretations/v2/somatic/{case_id}/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationSomatic, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        postInterpretationSomaticDeprecated: async (sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationSomaticDeprecated', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationSomaticDeprecated', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationSomaticDeprecated', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationSomatic' is not null or undefined
            assertParamExists('postInterpretationSomaticDeprecated', 'interpretationSomatic', interpretationSomatic)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationSomatic, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/germline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/somatic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterpretationsApi - functional programming interface
 * @export
 */
export const InterpretationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InterpretationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationGermline(caseId: string, sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationGermline(caseId, sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getInterpretationGermlineDeprecated(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationGermlineDeprecated(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationGermlineDeprecated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationSomatic(caseId: string, sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationSomatic(caseId, sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getInterpretationSomaticDeprecated(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationSomaticDeprecated(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationSomaticDeprecated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PubmedCitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPubmedCitation(citationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getPubmedCitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationGermline(caseId: string, sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationGermline(caseId, sequencingId, locusId, transcriptId, interpretationGermline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async postInterpretationGermlineDeprecated(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationGermlineDeprecated(sequencingId, locusId, transcriptId, interpretationGermline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationGermlineDeprecated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationSomatic(caseId: string, sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationSomatic(caseId, sequencingId, locusId, transcriptId, interpretationSomatic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async postInterpretationSomaticDeprecated(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationSomaticDeprecated(sequencingId, locusId, transcriptId, interpretationSomatic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationSomaticDeprecated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationGermline(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterpretationGermline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationGermline(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationSomatic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterpretationSomatic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationSomatic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InterpretationsApi - factory interface
 * @export
 */
export const InterpretationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InterpretationsApiFp(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline(caseId: string, sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.getInterpretationGermline(caseId, sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getInterpretationGermlineDeprecated(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.getInterpretationGermlineDeprecated(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic(caseId: string, sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.getInterpretationSomatic(caseId, sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getInterpretationSomaticDeprecated(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.getInterpretationSomaticDeprecated(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): AxiosPromise<PubmedCitation> {
            return localVarFp.getPubmedCitation(citationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline(caseId: string, sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.postInterpretationGermline(caseId, sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        postInterpretationGermlineDeprecated(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.postInterpretationGermlineDeprecated(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} caseId Case ID
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic(caseId: string, sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.postInterpretationSomatic(caseId, sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        postInterpretationSomaticDeprecated(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.postInterpretationSomaticDeprecated(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline(options?: RawAxiosRequestConfig): AxiosPromise<Array<InterpretationGermline>> {
            return localVarFp.searchInterpretationGermline(options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic(options?: RawAxiosRequestConfig): AxiosPromise<Array<InterpretationSomatic>> {
            return localVarFp.searchInterpretationSomatic(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InterpretationsApi - object-oriented interface
 * @export
 * @class InterpretationsApi
 * @extends {BaseAPI}
 */
export class InterpretationsApi extends BaseAPI {
    /**
     * Get interpretation germline
     * @summary Get interpretation germline
     * @param {string} caseId Case ID
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationGermline(caseId: string, sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationGermline(caseId, sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get interpretation germline
     * @summary Get interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationGermlineDeprecated(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationGermlineDeprecated(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get interpretation somatic
     * @summary Get interpretation somatic
     * @param {string} caseId Case ID
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationSomatic(caseId: string, sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationSomatic(caseId, sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get interpretation somatic
     * @summary Get interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationSomaticDeprecated(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationSomaticDeprecated(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pubmed citation by ID
     * @summary Get pubmed citation by ID
     * @param {string} citationId Citation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getPubmedCitation(citationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation germline
     * @summary Create or Update interpretation germline
     * @param {string} caseId Case ID
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationGermline} interpretationGermline Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationGermline(caseId: string, sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationGermline(caseId, sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation germline
     * @summary Create or Update interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationGermline} interpretationGermline Interpretation Body
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationGermlineDeprecated(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationGermlineDeprecated(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation somatic
     * @summary Create or Update interpretation somatic
     * @param {string} caseId Case ID
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationSomatic(caseId: string, sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationSomatic(caseId, sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation somatic
     * @summary Create or Update interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationSomaticDeprecated(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationSomaticDeprecated(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation germline
     * @summary Search interpretation germline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public searchInterpretationGermline(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationGermline(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation somatic
     * @summary Search interpretation somatic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public searchInterpretationSomatic(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationSomatic(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MondoApi - axios parameter creator
 * @export
 */
export const MondoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('mondoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/mondo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MondoApi - functional programming interface
 * @export
 */
export const MondoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MondoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mondoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MondoApi.mondoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MondoApi - factory interface
 * @export
 */
export const MondoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MondoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.mondoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MondoApi - object-oriented interface
 * @export
 * @class MondoApi
 * @extends {BaseAPI}
 */
export class MondoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MondoApi
     */
    public mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return MondoApiFp(this.configuration).mondoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OccurrencesApi - axios parameter creator
 * @export
 */
export const OccurrencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aggregate germline CNV occurrences for a given sequence ID
         * @summary Aggregate germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineCNVOccurrences: async (caseId: number, seqId: number, aggregationBodyWithSqon: AggregationBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('aggregateGermlineCNVOccurrences', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('aggregateGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'aggregationBodyWithSqon' is not null or undefined
            assertParamExists('aggregateGermlineCNVOccurrences', 'aggregationBodyWithSqon', aggregationBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{case_id}/{seq_id}/aggregate`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Aggregate germline SNV occurrences for a given sequence ID
         * @summary Aggregate germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {boolean} [withDictionary] Whether to include all possible facet values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineSNVOccurrences: async (caseId: number, seqId: number, aggregationBodyWithSqon: AggregationBodyWithSqon, withDictionary?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('aggregateGermlineSNVOccurrences', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('aggregateGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'aggregationBodyWithSqon' is not null or undefined
            assertParamExists('aggregateGermlineSNVOccurrences', 'aggregationBodyWithSqon', aggregationBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{case_id}/{seq_id}/aggregate`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (withDictionary !== undefined) {
                localVarQueryParameter['with_dictionary'] = withDictionary;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts germline CNV occurrences for a given sequence ID
         * @summary Count germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineCNVOccurrences: async (caseId: number, seqId: number, countBodyWithSqon: CountBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('countGermlineCNVOccurrences', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('countGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'countBodyWithSqon' is not null or undefined
            assertParamExists('countGermlineCNVOccurrences', 'countBodyWithSqon', countBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{case_id}/{seq_id}/count`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts germline SNV occurrences for a given sequence ID
         * @summary Count germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineSNVOccurrences: async (caseId: number, seqId: number, countBodyWithSqon: CountBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('countGermlineSNVOccurrences', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('countGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'countBodyWithSqon' is not null or undefined
            assertParamExists('countGermlineSNVOccurrences', 'countBodyWithSqon', countBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{case_id}/{seq_id}/count`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
         * @summary Get a germline ExpandedGermlineSNVOccurrence
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineSNVOccurrence: async (caseId: number, seqId: number, locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('getExpandedGermlineSNVOccurrence', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getExpandedGermlineSNVOccurrence', 'seqId', seqId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getExpandedGermlineSNVOccurrence', 'locusId', locusId)
            const localVarPath = `/occurrences/germline/snv/{case_id}/{seq_id}/{locus_id}/expanded`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline SNV facets
         * @summary Get germline SNV facets dictionary
         * @param {Array<string>} [facets] One or more facets to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineSNVDictionary: async (facets?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/occurrences/germline/snv/dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (facets) {
                localVarQueryParameter['facets'] = facets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List genes overlapping a CNV with a given ID
         * @summary List genes overlapping a CNV with a given ID
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {string} cnvId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVGenesOverlap: async (caseId: number, seqId: number, cnvId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('listGermlineCNVGenesOverlap', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listGermlineCNVGenesOverlap', 'seqId', seqId)
            // verify required parameter 'cnvId' is not null or undefined
            assertParamExists('listGermlineCNVGenesOverlap', 'cnvId', cnvId)
            const localVarPath = `/occurrences/germline/cnv/{case_id}/{seq_id}/{cnv_id}/genes_overlap`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"cnv_id"}}`, encodeURIComponent(String(cnvId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List germline CNV occurrences for a given sequence ID
         * @summary List germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVOccurrences: async (caseId: number, seqId: number, listBodyWithSqon: ListBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('listGermlineCNVOccurrences', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'listBodyWithSqon' is not null or undefined
            assertParamExists('listGermlineCNVOccurrences', 'listBodyWithSqon', listBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{case_id}/{seq_id}/list`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List germline SNV occurrences for a given sequence ID
         * @summary List germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineSNVOccurrences: async (caseId: number, seqId: number, listBodyWithSqon: ListBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('listGermlineSNVOccurrences', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'listBodyWithSqon' is not null or undefined
            assertParamExists('listGermlineSNVOccurrences', 'listBodyWithSqon', listBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{case_id}/{seq_id}/list`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineCNVOccurrences: async (caseId: number, seqId: number, statisticsBodyWithSqon: StatisticsBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('statisticsGermlineCNVOccurrences', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('statisticsGermlineCNVOccurrences', 'seqId', seqId)
            // verify required parameter 'statisticsBodyWithSqon' is not null or undefined
            assertParamExists('statisticsGermlineCNVOccurrences', 'statisticsBodyWithSqon', statisticsBodyWithSqon)
            const localVarPath = `/occurrences/germline/cnv/{case_id}/{seq_id}/statistics`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticsBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineSNVOccurrences: async (caseId: number, seqId: number, statisticsBodyWithSqon: StatisticsBodyWithSqon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('statisticsGermlineSNVOccurrences', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('statisticsGermlineSNVOccurrences', 'seqId', seqId)
            // verify required parameter 'statisticsBodyWithSqon' is not null or undefined
            assertParamExists('statisticsGermlineSNVOccurrences', 'statisticsBodyWithSqon', statisticsBodyWithSqon)
            const localVarPath = `/occurrences/germline/snv/{case_id}/{seq_id}/statistics`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticsBodyWithSqon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OccurrencesApi - functional programming interface
 * @export
 */
export const OccurrencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OccurrencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Aggregate germline CNV occurrences for a given sequence ID
         * @summary Aggregate germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateGermlineCNVOccurrences(caseId: number, seqId: number, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Aggregation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateGermlineCNVOccurrences(caseId, seqId, aggregationBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.aggregateGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Aggregate germline SNV occurrences for a given sequence ID
         * @summary Aggregate germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {boolean} [withDictionary] Whether to include all possible facet values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateGermlineSNVOccurrences(caseId: number, seqId: number, aggregationBodyWithSqon: AggregationBodyWithSqon, withDictionary?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Aggregation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateGermlineSNVOccurrences(caseId, seqId, aggregationBodyWithSqon, withDictionary, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.aggregateGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Counts germline CNV occurrences for a given sequence ID
         * @summary Count germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countGermlineCNVOccurrences(caseId: number, seqId: number, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Count>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countGermlineCNVOccurrences(caseId, seqId, countBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.countGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Counts germline SNV occurrences for a given sequence ID
         * @summary Count germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countGermlineSNVOccurrences(caseId: number, seqId: number, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Count>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countGermlineSNVOccurrences(caseId, seqId, countBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.countGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
         * @summary Get a germline ExpandedGermlineSNVOccurrence
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpandedGermlineSNVOccurrence(caseId: number, seqId: number, locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandedGermlineSNVOccurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpandedGermlineSNVOccurrence(caseId, seqId, locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.getExpandedGermlineSNVOccurrence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline SNV facets
         * @summary Get germline SNV facets dictionary
         * @param {Array<string>} [facets] One or more facets to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineSNVDictionary(facets?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Facet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineSNVDictionary(facets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.getGermlineSNVDictionary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List genes overlapping a CNV with a given ID
         * @summary List genes overlapping a CNV with a given ID
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {string} cnvId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGermlineCNVGenesOverlap(caseId: number, seqId: number, cnvId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CNVGeneOverlap>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGermlineCNVGenesOverlap(caseId, seqId, cnvId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listGermlineCNVGenesOverlap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List germline CNV occurrences for a given sequence ID
         * @summary List germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGermlineCNVOccurrences(caseId: number, seqId: number, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GermlineCNVOccurrence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGermlineCNVOccurrences(caseId, seqId, listBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List germline SNV occurrences for a given sequence ID
         * @summary List germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGermlineSNVOccurrences(caseId: number, seqId: number, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GermlineSNVOccurrence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGermlineSNVOccurrences(caseId, seqId, listBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsGermlineCNVOccurrences(caseId: number, seqId: number, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsGermlineCNVOccurrences(caseId, seqId, statisticsBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.statisticsGermlineCNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsGermlineSNVOccurrences(caseId: number, seqId: number, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsGermlineSNVOccurrences(caseId, seqId, statisticsBodyWithSqon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.statisticsGermlineSNVOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OccurrencesApi - factory interface
 * @export
 */
export const OccurrencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OccurrencesApiFp(configuration)
    return {
        /**
         * Aggregate germline CNV occurrences for a given sequence ID
         * @summary Aggregate germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineCNVOccurrences(caseId: number, seqId: number, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<Aggregation>> {
            return localVarFp.aggregateGermlineCNVOccurrences(caseId, seqId, aggregationBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Aggregate germline SNV occurrences for a given sequence ID
         * @summary Aggregate germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
         * @param {boolean} [withDictionary] Whether to include all possible facet values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateGermlineSNVOccurrences(caseId: number, seqId: number, aggregationBodyWithSqon: AggregationBodyWithSqon, withDictionary?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Aggregation>> {
            return localVarFp.aggregateGermlineSNVOccurrences(caseId, seqId, aggregationBodyWithSqon, withDictionary, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts germline CNV occurrences for a given sequence ID
         * @summary Count germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineCNVOccurrences(caseId: number, seqId: number, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Count> {
            return localVarFp.countGermlineCNVOccurrences(caseId, seqId, countBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts germline SNV occurrences for a given sequence ID
         * @summary Count germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {CountBodyWithSqon} countBodyWithSqon Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGermlineSNVOccurrences(caseId: number, seqId: number, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Count> {
            return localVarFp.countGermlineSNVOccurrences(caseId, seqId, countBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
         * @summary Get a germline ExpandedGermlineSNVOccurrence
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineSNVOccurrence(caseId: number, seqId: number, locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExpandedGermlineSNVOccurrence> {
            return localVarFp.getExpandedGermlineSNVOccurrence(caseId, seqId, locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline SNV facets
         * @summary Get germline SNV facets dictionary
         * @param {Array<string>} [facets] One or more facets to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineSNVDictionary(facets?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Facet>> {
            return localVarFp.getGermlineSNVDictionary(facets, options).then((request) => request(axios, basePath));
        },
        /**
         * List genes overlapping a CNV with a given ID
         * @summary List genes overlapping a CNV with a given ID
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {string} cnvId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVGenesOverlap(caseId: number, seqId: number, cnvId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CNVGeneOverlap>> {
            return localVarFp.listGermlineCNVGenesOverlap(caseId, seqId, cnvId, options).then((request) => request(axios, basePath));
        },
        /**
         * List germline CNV occurrences for a given sequence ID
         * @summary List germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineCNVOccurrences(caseId: number, seqId: number, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<GermlineCNVOccurrence>> {
            return localVarFp.listGermlineCNVOccurrences(caseId, seqId, listBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * List germline SNV occurrences for a given sequence ID
         * @summary List germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {ListBodyWithSqon} listBodyWithSqon List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGermlineSNVOccurrences(caseId: number, seqId: number, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Array<GermlineSNVOccurrence>> {
            return localVarFp.listGermlineSNVOccurrences(caseId, seqId, listBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline CNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineCNVOccurrences(caseId: number, seqId: number, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Statistics> {
            return localVarFp.statisticsGermlineCNVOccurrences(caseId, seqId, statisticsBodyWithSqon, options).then((request) => request(axios, basePath));
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of germline SNV occurrences
         * @param {number} caseId Case ID
         * @param {number} seqId Sequence ID
         * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsGermlineSNVOccurrences(caseId: number, seqId: number, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig): AxiosPromise<Statistics> {
            return localVarFp.statisticsGermlineSNVOccurrences(caseId, seqId, statisticsBodyWithSqon, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OccurrencesApi - object-oriented interface
 * @export
 * @class OccurrencesApi
 * @extends {BaseAPI}
 */
export class OccurrencesApi extends BaseAPI {
    /**
     * Aggregate germline CNV occurrences for a given sequence ID
     * @summary Aggregate germline CNV occurrences
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public aggregateGermlineCNVOccurrences(caseId: number, seqId: number, aggregationBodyWithSqon: AggregationBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).aggregateGermlineCNVOccurrences(caseId, seqId, aggregationBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Aggregate germline SNV occurrences for a given sequence ID
     * @summary Aggregate germline SNV occurrences
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {AggregationBodyWithSqon} aggregationBodyWithSqon Aggregation Body
     * @param {boolean} [withDictionary] Whether to include all possible facet values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public aggregateGermlineSNVOccurrences(caseId: number, seqId: number, aggregationBodyWithSqon: AggregationBodyWithSqon, withDictionary?: boolean, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).aggregateGermlineSNVOccurrences(caseId, seqId, aggregationBodyWithSqon, withDictionary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts germline CNV occurrences for a given sequence ID
     * @summary Count germline CNV occurrences
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {CountBodyWithSqon} countBodyWithSqon Count Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public countGermlineCNVOccurrences(caseId: number, seqId: number, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).countGermlineCNVOccurrences(caseId, seqId, countBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts germline SNV occurrences for a given sequence ID
     * @summary Count germline SNV occurrences
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {CountBodyWithSqon} countBodyWithSqon Count Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public countGermlineSNVOccurrences(caseId: number, seqId: number, countBodyWithSqon: CountBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).countGermlineSNVOccurrences(caseId, seqId, countBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ExpandedGermlineSNVOccurrence data for a given locus ID
     * @summary Get a germline ExpandedGermlineSNVOccurrence
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public getExpandedGermlineSNVOccurrence(caseId: number, seqId: number, locusId: string, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).getExpandedGermlineSNVOccurrence(caseId, seqId, locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline SNV facets
     * @summary Get germline SNV facets dictionary
     * @param {Array<string>} [facets] One or more facets to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public getGermlineSNVDictionary(facets?: Array<string>, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).getGermlineSNVDictionary(facets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List genes overlapping a CNV with a given ID
     * @summary List genes overlapping a CNV with a given ID
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {string} cnvId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public listGermlineCNVGenesOverlap(caseId: number, seqId: number, cnvId: string, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listGermlineCNVGenesOverlap(caseId, seqId, cnvId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List germline CNV occurrences for a given sequence ID
     * @summary List germline CNV occurrences
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {ListBodyWithSqon} listBodyWithSqon List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public listGermlineCNVOccurrences(caseId: number, seqId: number, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listGermlineCNVOccurrences(caseId, seqId, listBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List germline SNV occurrences for a given sequence ID
     * @summary List germline SNV occurrences
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {ListBodyWithSqon} listBodyWithSqon List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public listGermlineSNVOccurrences(caseId: number, seqId: number, listBodyWithSqon: ListBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listGermlineSNVOccurrences(caseId, seqId, listBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return statistics about a field for a given sequence ID
     * @summary Statistics of germline CNV occurrences
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public statisticsGermlineCNVOccurrences(caseId: number, seqId: number, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).statisticsGermlineCNVOccurrences(caseId, seqId, statisticsBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return statistics about a field for a given sequence ID
     * @summary Statistics of germline SNV occurrences
     * @param {number} caseId Case ID
     * @param {number} seqId Sequence ID
     * @param {StatisticsBodyWithSqon} statisticsBodyWithSqon Statistics Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public statisticsGermlineSNVOccurrences(caseId: number, seqId: number, statisticsBodyWithSqon: StatisticsBodyWithSqon, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).statisticsGermlineSNVOccurrences(caseId, seqId, statisticsBodyWithSqon, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PatientsApi - axios parameter creator
 * @export
 */
export const PatientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new patient batch
         * @summary Create a new patient batch
         * @param {CreatePatientBatchBody} createPatientBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPatientBatch: async (createPatientBatchBody: CreatePatientBatchBody, dryRun?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPatientBatchBody' is not null or undefined
            assertParamExists('postPatientBatch', 'createPatientBatchBody', createPatientBatchBody)
            const localVarPath = `/patients/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPatientBatchBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatientsApi - functional programming interface
 * @export
 */
export const PatientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PatientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new patient batch
         * @summary Create a new patient batch
         * @param {CreatePatientBatchBody} createPatientBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPatientBatch(createPatientBatchBody: CreatePatientBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPatientBatch(createPatientBatchBody, dryRun, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientsApi.postPatientBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PatientsApi - factory interface
 * @export
 */
export const PatientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PatientsApiFp(configuration)
    return {
        /**
         * Create a new patient batch
         * @summary Create a new patient batch
         * @param {CreatePatientBatchBody} createPatientBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPatientBatch(createPatientBatchBody: CreatePatientBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CreateBatchResponse> {
            return localVarFp.postPatientBatch(createPatientBatchBody, dryRun, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PatientsApi - object-oriented interface
 * @export
 * @class PatientsApi
 * @extends {BaseAPI}
 */
export class PatientsApi extends BaseAPI {
    /**
     * Create a new patient batch
     * @summary Create a new patient batch
     * @param {CreatePatientBatchBody} createPatientBatchBody Create Body
     * @param {boolean} [dryRun] Dry Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatientsApi
     */
    public postPatientBatch(createPatientBatchBody: CreatePatientBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig) {
        return PatientsApiFp(this.configuration).postPatientBatch(createPatientBatchBody, dryRun, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SamplesApi - axios parameter creator
 * @export
 */
export const SamplesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new sample batch
         * @summary Create a new sample batch
         * @param {CreateSampleBatchBody} createSampleBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSampleBatch: async (createSampleBatchBody: CreateSampleBatchBody, dryRun?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSampleBatchBody' is not null or undefined
            assertParamExists('postSampleBatch', 'createSampleBatchBody', createSampleBatchBody)
            const localVarPath = `/samples/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSampleBatchBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SamplesApi - functional programming interface
 * @export
 */
export const SamplesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SamplesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new sample batch
         * @summary Create a new sample batch
         * @param {CreateSampleBatchBody} createSampleBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSampleBatch(createSampleBatchBody: CreateSampleBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSampleBatch(createSampleBatchBody, dryRun, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SamplesApi.postSampleBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SamplesApi - factory interface
 * @export
 */
export const SamplesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SamplesApiFp(configuration)
    return {
        /**
         * Create a new sample batch
         * @summary Create a new sample batch
         * @param {CreateSampleBatchBody} createSampleBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSampleBatch(createSampleBatchBody: CreateSampleBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CreateBatchResponse> {
            return localVarFp.postSampleBatch(createSampleBatchBody, dryRun, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SamplesApi - object-oriented interface
 * @export
 * @class SamplesApi
 * @extends {BaseAPI}
 */
export class SamplesApi extends BaseAPI {
    /**
     * Create a new sample batch
     * @summary Create a new sample batch
     * @param {CreateSampleBatchBody} createSampleBatchBody Create Body
     * @param {boolean} [dryRun] Dry Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SamplesApi
     */
    public postSampleBatch(createSampleBatchBody: CreateSampleBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig) {
        return SamplesApiFp(this.configuration).postSampleBatch(createSampleBatchBody, dryRun, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SavedFiltersApi - axios parameter creator
 * @export
 */
export const SavedFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a saved filter
         * @summary Delete a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedFilter: async (savedFilterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedFilterId' is not null or undefined
            assertParamExists('deleteSavedFilter', 'savedFilterId', savedFilterId)
            const localVarPath = `/users/saved_filters/{saved_filter_id}`
                .replace(`{${"saved_filter_id"}}`, encodeURIComponent(String(savedFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get saved filter by id
         * @summary Get saved filter by id
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilterById: async (savedFilterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedFilterId' is not null or undefined
            assertParamExists('getSavedFilterById', 'savedFilterId', savedFilterId)
            const localVarPath = `/users/saved_filters/{saved_filter_id}`
                .replace(`{${"saved_filter_id"}}`, encodeURIComponent(String(savedFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user saved filters
         * @summary Get user saved filters
         * @param {string} [type] Saved Filter Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilters: async (type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/saved_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new saved filter
         * @summary Create a new saved filter
         * @param {SavedFilterCreationInput} savedFilterCreationInput New Saved Filter to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSavedFilter: async (savedFilterCreationInput: SavedFilterCreationInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedFilterCreationInput' is not null or undefined
            assertParamExists('postSavedFilter', 'savedFilterCreationInput', savedFilterCreationInput)
            const localVarPath = `/users/saved_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedFilterCreationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a saved filter
         * @summary Update a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {SavedFilterUpdateInput} savedFilterUpdateInput Saved Filter to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSavedFilter: async (savedFilterId: string, savedFilterUpdateInput: SavedFilterUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedFilterId' is not null or undefined
            assertParamExists('putSavedFilter', 'savedFilterId', savedFilterId)
            // verify required parameter 'savedFilterUpdateInput' is not null or undefined
            assertParamExists('putSavedFilter', 'savedFilterUpdateInput', savedFilterUpdateInput)
            const localVarPath = `/users/saved_filters/{saved_filter_id}`
                .replace(`{${"saved_filter_id"}}`, encodeURIComponent(String(savedFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedFilterUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedFiltersApi - functional programming interface
 * @export
 */
export const SavedFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a saved filter
         * @summary Delete a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedFilter(savedFilterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedFilter(savedFilterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.deleteSavedFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get saved filter by id
         * @summary Get saved filter by id
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedFilterById(savedFilterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedFilterById(savedFilterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.getSavedFilterById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user saved filters
         * @summary Get user saved filters
         * @param {string} [type] Saved Filter Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedFilters(type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedFilter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedFilters(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.getSavedFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new saved filter
         * @summary Create a new saved filter
         * @param {SavedFilterCreationInput} savedFilterCreationInput New Saved Filter to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSavedFilter(savedFilterCreationInput: SavedFilterCreationInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSavedFilter(savedFilterCreationInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.postSavedFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a saved filter
         * @summary Update a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {SavedFilterUpdateInput} savedFilterUpdateInput Saved Filter to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSavedFilter(savedFilterId: string, savedFilterUpdateInput: SavedFilterUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSavedFilter(savedFilterId, savedFilterUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedFiltersApi.putSavedFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SavedFiltersApi - factory interface
 * @export
 */
export const SavedFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedFiltersApiFp(configuration)
    return {
        /**
         * Delete a saved filter
         * @summary Delete a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedFilter(savedFilterId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSavedFilter(savedFilterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get saved filter by id
         * @summary Get saved filter by id
         * @param {string} savedFilterId Saved Filter ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilterById(savedFilterId: string, options?: RawAxiosRequestConfig): AxiosPromise<SavedFilter> {
            return localVarFp.getSavedFilterById(savedFilterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user saved filters
         * @summary Get user saved filters
         * @param {string} [type] Saved Filter Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedFilters(type?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SavedFilter>> {
            return localVarFp.getSavedFilters(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new saved filter
         * @summary Create a new saved filter
         * @param {SavedFilterCreationInput} savedFilterCreationInput New Saved Filter to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSavedFilter(savedFilterCreationInput: SavedFilterCreationInput, options?: RawAxiosRequestConfig): AxiosPromise<SavedFilter> {
            return localVarFp.postSavedFilter(savedFilterCreationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a saved filter
         * @summary Update a saved filter
         * @param {string} savedFilterId Saved Filter ID
         * @param {SavedFilterUpdateInput} savedFilterUpdateInput Saved Filter to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSavedFilter(savedFilterId: string, savedFilterUpdateInput: SavedFilterUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<SavedFilter> {
            return localVarFp.putSavedFilter(savedFilterId, savedFilterUpdateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SavedFiltersApi - object-oriented interface
 * @export
 * @class SavedFiltersApi
 * @extends {BaseAPI}
 */
export class SavedFiltersApi extends BaseAPI {
    /**
     * Delete a saved filter
     * @summary Delete a saved filter
     * @param {string} savedFilterId Saved Filter ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedFiltersApi
     */
    public deleteSavedFilter(savedFilterId: string, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).deleteSavedFilter(savedFilterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get saved filter by id
     * @summary Get saved filter by id
     * @param {string} savedFilterId Saved Filter ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedFiltersApi
     */
    public getSavedFilterById(savedFilterId: string, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).getSavedFilterById(savedFilterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user saved filters
     * @summary Get user saved filters
     * @param {string} [type] Saved Filter Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedFiltersApi
     */
    public getSavedFilters(type?: string, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).getSavedFilters(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new saved filter
     * @summary Create a new saved filter
     * @param {SavedFilterCreationInput} savedFilterCreationInput New Saved Filter to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedFiltersApi
     */
    public postSavedFilter(savedFilterCreationInput: SavedFilterCreationInput, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).postSavedFilter(savedFilterCreationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a saved filter
     * @summary Update a saved filter
     * @param {string} savedFilterId Saved Filter ID
     * @param {SavedFilterUpdateInput} savedFilterUpdateInput Saved Filter to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedFiltersApi
     */
    public putSavedFilter(savedFilterId: string, savedFilterUpdateInput: SavedFilterUpdateInput, options?: RawAxiosRequestConfig) {
        return SavedFiltersApiFp(this.configuration).putSavedFilter(savedFilterId, savedFilterUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SequencingApi - axios parameter creator
 * @export
 */
export const SequencingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getSequencing', 'seqId', seqId)
            const localVarPath = `/sequencing/{seq_id}`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SequencingExperimentDetail by id
         * @summary Get SequencingExperimentDetail by id
         * @param {string} seqId Seq ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencingExperimentDetailById: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getSequencingExperimentDetailById', 'seqId', seqId)
            const localVarPath = `/sequencing/{seq_id}/details`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new sequencing experiment batch
         * @summary Create a new sequencing experiment batch
         * @param {CreateSequencingExperimentBatchBody} createSequencingExperimentBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSequencingExperimentBatch: async (createSequencingExperimentBatchBody: CreateSequencingExperimentBatchBody, dryRun?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSequencingExperimentBatchBody' is not null or undefined
            assertParamExists('postSequencingExperimentBatch', 'createSequencingExperimentBatchBody', createSequencingExperimentBatchBody)
            const localVarPath = `/sequencing/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSequencingExperimentBatchBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SequencingApi - functional programming interface
 * @export
 */
export const SequencingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SequencingApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSequencing(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequencing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSequencing(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SequencingApi.getSequencing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SequencingExperimentDetail by id
         * @summary Get SequencingExperimentDetail by id
         * @param {string} seqId Seq ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSequencingExperimentDetailById(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SequencingExperimentDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSequencingExperimentDetailById(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SequencingApi.getSequencingExperimentDetailById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new sequencing experiment batch
         * @summary Create a new sequencing experiment batch
         * @param {CreateSequencingExperimentBatchBody} createSequencingExperimentBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSequencingExperimentBatch(createSequencingExperimentBatchBody: CreateSequencingExperimentBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSequencingExperimentBatch(createSequencingExperimentBatchBody, dryRun, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SequencingApi.postSequencingExperimentBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SequencingApi - factory interface
 * @export
 */
export const SequencingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SequencingApiFp(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<Sequencing> {
            return localVarFp.getSequencing(seqId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SequencingExperimentDetail by id
         * @summary Get SequencingExperimentDetail by id
         * @param {string} seqId Seq ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencingExperimentDetailById(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<SequencingExperimentDetail> {
            return localVarFp.getSequencingExperimentDetailById(seqId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new sequencing experiment batch
         * @summary Create a new sequencing experiment batch
         * @param {CreateSequencingExperimentBatchBody} createSequencingExperimentBatchBody Create Body
         * @param {boolean} [dryRun] Dry Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSequencingExperimentBatch(createSequencingExperimentBatchBody: CreateSequencingExperimentBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CreateBatchResponse> {
            return localVarFp.postSequencingExperimentBatch(createSequencingExperimentBatchBody, dryRun, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SequencingApi - object-oriented interface
 * @export
 * @class SequencingApi
 * @extends {BaseAPI}
 */
export class SequencingApi extends BaseAPI {
    /**
     * Retrieve Sequencing data for a given sequence ID
     * @summary Get a Sequencing
     * @param {string} seqId Sequence ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SequencingApi
     */
    public getSequencing(seqId: string, options?: RawAxiosRequestConfig) {
        return SequencingApiFp(this.configuration).getSequencing(seqId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SequencingExperimentDetail by id
     * @summary Get SequencingExperimentDetail by id
     * @param {string} seqId Seq ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SequencingApi
     */
    public getSequencingExperimentDetailById(seqId: string, options?: RawAxiosRequestConfig) {
        return SequencingApiFp(this.configuration).getSequencingExperimentDetailById(seqId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new sequencing experiment batch
     * @summary Create a new sequencing experiment batch
     * @param {CreateSequencingExperimentBatchBody} createSequencingExperimentBatchBody Create Body
     * @param {boolean} [dryRun] Dry Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SequencingApi
     */
    public postSequencingExperimentBatch(createSequencingExperimentBatchBody: CreateSequencingExperimentBatchBody, dryRun?: boolean, options?: RawAxiosRequestConfig) {
        return SequencingApiFp(this.configuration).postSequencingExperimentBatch(createSequencingExperimentBatchBody, dryRun, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Returns the current status of the API
     * @summary Get API status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusGet(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPreferencesApi - axios parameter creator
 * @export
 */
export const UserPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user preferences
         * @summary Get user preferences
         * @param {string} key Preference key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getUserPreferences', 'key', key)
            const localVarPath = `/users/preferences/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update user preference
         * @summary Create or update user preference
         * @param {string} key Preference key
         * @param {UserPreference} userPreference User Preference to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserPreferences: async (key: string, userPreference: UserPreference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('postUserPreferences', 'key', key)
            // verify required parameter 'userPreference' is not null or undefined
            assertParamExists('postUserPreferences', 'userPreference', userPreference)
            const localVarPath = `/users/preferences/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPreference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPreferencesApi - functional programming interface
 * @export
 */
export const UserPreferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPreferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user preferences
         * @summary Get user preferences
         * @param {string} key Preference key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPreferences(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPreferences(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPreferencesApi.getUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update user preference
         * @summary Create or update user preference
         * @param {string} key Preference key
         * @param {UserPreference} userPreference User Preference to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserPreferences(key: string, userPreference: UserPreference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserPreferences(key, userPreference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPreferencesApi.postUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserPreferencesApi - factory interface
 * @export
 */
export const UserPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPreferencesApiFp(configuration)
    return {
        /**
         * Get user preferences
         * @summary Get user preferences
         * @param {string} key Preference key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences(key: string, options?: RawAxiosRequestConfig): AxiosPromise<UserPreference> {
            return localVarFp.getUserPreferences(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update user preference
         * @summary Create or update user preference
         * @param {string} key Preference key
         * @param {UserPreference} userPreference User Preference to create or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserPreferences(key: string, userPreference: UserPreference, options?: RawAxiosRequestConfig): AxiosPromise<UserPreference> {
            return localVarFp.postUserPreferences(key, userPreference, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPreferencesApi - object-oriented interface
 * @export
 * @class UserPreferencesApi
 * @extends {BaseAPI}
 */
export class UserPreferencesApi extends BaseAPI {
    /**
     * Get user preferences
     * @summary Get user preferences
     * @param {string} key Preference key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferencesApi
     */
    public getUserPreferences(key: string, options?: RawAxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).getUserPreferences(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update user preference
     * @summary Create or update user preference
     * @param {string} key Preference key
     * @param {UserPreference} userPreference User Preference to create or update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferencesApi
     */
    public postUserPreferences(key: string, userPreference: UserPreference, options?: RawAxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).postUserPreferences(key, userPreference, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSetsApi - axios parameter creator
 * @export
 */
export const UserSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet: async (userSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSetId' is not null or undefined
            assertParamExists('getUserSet', 'userSetId', userSetId)
            const localVarPath = `/users/sets/{user_set_id}`
                .replace(`{${"user_set_id"}}`, encodeURIComponent(String(userSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSetsApi - functional programming interface
 * @export
 */
export const UserSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSet(userSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSet(userSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSetsApi.getUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserSetsApi - factory interface
 * @export
 */
export const UserSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSetsApiFp(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet(userSetId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSet> {
            return localVarFp.getUserSet(userSetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSetsApi - object-oriented interface
 * @export
 * @class UserSetsApi
 * @extends {BaseAPI}
 */
export class UserSetsApi extends BaseAPI {
    /**
     * Get user set
     * @summary Get user set by id
     * @param {string} userSetId UserSet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSetsApi
     */
    public getUserSet(userSetId: string, options?: RawAxiosRequestConfig) {
        return UserSetsApiFp(this.configuration).getUserSet(userSetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariantApi - axios parameter creator
 * @export
 */
export const VariantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
         * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} caseId Case ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineVariantInterpretedCase: async (locusId: string, caseId: string, seqId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'locusId', locusId)
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'caseId', caseId)
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'seqId', seqId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getExpandedGermlineVariantInterpretedCase', 'transcriptId', transcriptId)
            const localVarPath = `/variants/germline/{locus_id}/cases/interpreted/{case_id}/{seq_id}/{transcript_id}`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesCount: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantCasesCount', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/cases/count`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesFilters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variants/germline/cases/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditions: async (locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConditions', 'locusId', locusId)
            // verify required parameter 'panelType' is not null or undefined
            assertParamExists('getGermlineVariantConditions', 'panelType', panelType)
            const localVarPath = `/variants/germline/{locus_id}/conditions/{panel_type}`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"panel_type"}}`, encodeURIComponent(String(panelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditionsClinvar: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConditionsClinvar', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/conditions/clinvar`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConsequences: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantConsequences', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/consequences`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantHeader: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantHeader', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/header`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantInterpretedCases: async (locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantInterpretedCases', 'locusId', locusId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('getGermlineVariantInterpretedCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/variants/germline/{locus_id}/cases/interpreted`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantOverview: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantOverview', 'locusId', locusId)
            const localVarPath = `/variants/germline/{locus_id}/overview`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantUninterpretedCases: async (locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getGermlineVariantUninterpretedCases', 'locusId', locusId)
            // verify required parameter 'listBodyWithCriteria' is not null or undefined
            assertParamExists('getGermlineVariantUninterpretedCases', 'listBodyWithCriteria', listBodyWithCriteria)
            const localVarPath = `/variants/germline/{locus_id}/cases/uninterpreted`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBodyWithCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariantApi - functional programming interface
 * @export
 */
export const VariantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariantApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
         * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} caseId Case ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpandedGermlineVariantInterpretedCase(locusId: string, caseId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantExpandedInterpretedCase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpandedGermlineVariantInterpretedCase(locusId, caseId, seqId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getExpandedGermlineVariantInterpretedCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantCasesCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantCasesCount(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantCasesCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantCasesFilters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantCasesFilters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantCasesFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenePanelConditions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConditions(locusId, panelType, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConditions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClinvarRCV>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConditionsClinvar(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConditionsClinvar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariantConsequence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantConsequences(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantConsequences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantHeader(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantHeader']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantInterpretedCasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantInterpretedCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantOverview(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantUninterpretedCasesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getGermlineVariantUninterpretedCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariantApi - factory interface
 * @export
 */
export const VariantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariantApiFp(configuration)
    return {
        /**
         * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
         * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
         * @param {string} locusId Locus ID
         * @param {string} caseId Case ID
         * @param {string} seqId Seq ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpandedGermlineVariantInterpretedCase(locusId: string, caseId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantExpandedInterpretedCase> {
            return localVarFp.getExpandedGermlineVariantInterpretedCase(locusId, caseId, seqId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve cases count for a given locus id
         * @summary Get germline cases count for a given locus
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantCasesCount> {
            return localVarFp.getGermlineVariantCasesCount(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve cases filters for germline variant entity
         * @summary Get cases filters for germline variant entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig): AxiosPromise<VariantCasesFilters> {
            return localVarFp.getGermlineVariantCasesFilters(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve conditions for germline variant entity for a specific gene panel
         * @summary Get conditions for germline variant entity for a specific gene panel
         * @param {string} locusId Locus ID
         * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
         * @param {string} [filter] Condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<GenePanelConditions> {
            return localVarFp.getGermlineVariantConditions(locusId, panelType, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ClinVar conditions for germline variant entity
         * @summary Get ClinVar conditions for germline variant entity
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClinvarRCV>> {
            return localVarFp.getGermlineVariantConditionsClinvar(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Consequences for a given locus
         * @summary Get list of VariantConsequences for a germline variant
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariantConsequence>> {
            return localVarFp.getGermlineVariantConsequences(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Header data for a given locus
         * @summary Get a germline VariantHeader
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantHeader> {
            return localVarFp.getGermlineVariantHeader(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Germline Variant interpreted cases for a given locus
         * @summary Get list of interpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<VariantInterpretedCasesSearchResponse> {
            return localVarFp.getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve germline Variant Overview data for a given locus
         * @summary Get a germline VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantOverview> {
            return localVarFp.getGermlineVariantOverview(locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Germline Variant uninterpreted cases for a given locus
         * @summary Get list of uninterpreted Cases for a germline variant
         * @param {string} locusId Locus ID
         * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig): AxiosPromise<VariantUninterpretedCasesSearchResponse> {
            return localVarFp.getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariantApi - object-oriented interface
 * @export
 * @class VariantApi
 * @extends {BaseAPI}
 */
export class VariantApi extends BaseAPI {
    /**
     * Retrieve germline expanded interpreted case for a given locus, sequencing and transcript
     * @summary Get expanded germline interpreted case for a given locus, sequencing and transcript
     * @param {string} locusId Locus ID
     * @param {string} caseId Case ID
     * @param {string} seqId Seq ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getExpandedGermlineVariantInterpretedCase(locusId: string, caseId: string, seqId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getExpandedGermlineVariantInterpretedCase(locusId, caseId, seqId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve cases count for a given locus id
     * @summary Get germline cases count for a given locus
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantCasesCount(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantCasesCount(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve cases filters for germline variant entity
     * @summary Get cases filters for germline variant entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantCasesFilters(options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantCasesFilters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve conditions for germline variant entity for a specific gene panel
     * @summary Get conditions for germline variant entity for a specific gene panel
     * @param {string} locusId Locus ID
     * @param {GetGermlineVariantConditionsPanelTypeEnum} panelType Gene panel type
     * @param {string} [filter] Condition filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantConditions(locusId: string, panelType: GetGermlineVariantConditionsPanelTypeEnum, filter?: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConditions(locusId, panelType, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ClinVar conditions for germline variant entity
     * @summary Get ClinVar conditions for germline variant entity
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantConditionsClinvar(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConditionsClinvar(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Consequences for a given locus
     * @summary Get list of VariantConsequences for a germline variant
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantConsequences(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantConsequences(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Header data for a given locus
     * @summary Get a germline VariantHeader
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantHeader(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantHeader(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Germline Variant interpreted cases for a given locus
     * @summary Get list of interpreted Cases for a germline variant
     * @param {string} locusId Locus ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantInterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantInterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve germline Variant Overview data for a given locus
     * @summary Get a germline VariantOverview
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantOverview(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantOverview(locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Germline Variant uninterpreted cases for a given locus
     * @summary Get list of uninterpreted Cases for a germline variant
     * @param {string} locusId Locus ID
     * @param {ListBodyWithCriteria} listBodyWithCriteria Search Body with criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getGermlineVariantUninterpretedCases(locusId: string, listBodyWithCriteria: ListBodyWithCriteria, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getGermlineVariantUninterpretedCases(locusId, listBodyWithCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetGermlineVariantConditionsPanelTypeEnum = {
    Omim: 'omim',
    Hpo: 'hpo',
    Orphanet: 'orphanet'
} as const;
export type GetGermlineVariantConditionsPanelTypeEnum = typeof GetGermlineVariantConditionsPanelTypeEnum[keyof typeof GetGermlineVariantConditionsPanelTypeEnum];



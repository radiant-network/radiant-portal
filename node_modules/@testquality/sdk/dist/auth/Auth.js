"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = exports.AuthCallbackActions = void 0;
const debug_1 = __importDefault(require("debug"));
const exceptions_1 = require("../exceptions");
const auth_1 = require("../services/auth");
const debug = (0, debug_1.default)('tq:sdk:Auth');
/**
 * Copyright (C) 2021 BitModern, Inc - All Rights Reserved
 */
const grantPath = '/oauth/access_token';
const ssoPath = '/sso';
const doesNotRequireAuth = [
    'auth/login',
    'auth/register',
    'email-verification/check',
    'email-verification/error',
    'oauth/access_token',
    'system/auth/begin_password_reset',
    'system/auth/complete_invite_user',
    'system/auth/complete_password_reset',
    'system/create_client',
    'system/github/authorize',
    'system/sign_up_with_email',
    'system/validate_site_name',
    'system/auth/complete_share_invite',
    'system/auth/complete_magic_share_invite',
];
var AuthCallbackActions;
(function (AuthCallbackActions) {
    AuthCallbackActions[AuthCallbackActions["Connected"] = 1] = "Connected";
    AuthCallbackActions[AuthCallbackActions["Refreshed"] = 2] = "Refreshed";
    AuthCallbackActions[AuthCallbackActions["Unauthorized"] = 3] = "Unauthorized";
    AuthCallbackActions[AuthCallbackActions["SubscriptionExpired"] = 4] = "SubscriptionExpired";
    AuthCallbackActions[AuthCallbackActions["TrialExpired"] = 5] = "TrialExpired";
    AuthCallbackActions[AuthCallbackActions["TokenUpdated"] = 6] = "TokenUpdated";
})(AuthCallbackActions || (exports.AuthCallbackActions = AuthCallbackActions = {}));
class Auth {
    static validateTokenPayload(token) {
        debug('validateTokenPayload: %j', token);
        if (token === null || token === void 0 ? void 0 : token.error) {
            throw new exceptions_1.GeneralError(token.error, exceptions_1.TOKEN);
        }
        else if (token === null || token === void 0 ? void 0 : token.message) {
            throw new exceptions_1.GeneralError(token.message, exceptions_1.TOKEN);
        }
        else if (token === null || token === void 0 ? void 0 : token.verification_ended_at) {
            // if verification ended then we don't have a token
            throw new exceptions_1.GeneralError('Email verification is required to login', exceptions_1.VERIFICATION);
        }
        else if (!(token === null || token === void 0 ? void 0 : token.access_token)) {
            throw new exceptions_1.GeneralError('Auth failed', exceptions_1.AUTH);
        }
        debug('validateTokenPayload: ok');
    }
    static urlRequiresAuth(url) {
        if (!url)
            return false;
        for (let i = 0; i < doesNotRequireAuth.length; i += 1) {
            if (url.match(new RegExp(doesNotRequireAuth[i]))) {
                return false;
            }
        }
        return true;
    }
    constructor(tokenStorage, client, authCallback) {
        this.tokenStorage = tokenStorage;
        this.client = client;
        this.authCallback = authCallback;
        this.disableHandler = false;
        this.id = Math.random();
        this.remember = true;
        this.setAuthCallback(authCallback);
        this.addInterceptors();
    }
    setAuthCallback(authCallback) {
        this.authCallback = authCallback;
        if (this.client.apiWorker) {
            this.client.apiWorker.setAuthCallback((action, token) => __awaiter(this, void 0, void 0, function* () {
                if (action === AuthCallbackActions.TokenUpdated) {
                    debug('token updated in apiWorker');
                    yield this.tokenStorage.setToken(token);
                }
                if (this.authCallback) {
                    yield this.authCallback(action, token);
                }
            }));
        }
    }
    passwordRecovery(email) {
        return this.client.api.get(`/system/auth/begin_password_reset/${email}`, {
            params: {
                is_web: true,
            },
        });
    }
    passwordReset(email, password, token) {
        return this.client.api.post('/system/auth/complete_password_reset', {
            email,
            password,
            token,
        });
    }
    login(username, password, remember = false, share, properties) {
        this.remember = remember;
        return this.client.api
            .post(grantPath, Object.assign({ grant_type: 'password', client_id: this.client.clientId, client_secret: this.client.clientSecret, username,
            password,
            share }, properties))
            .then((res) => this.performLogin(res.data));
    }
    loginSSO(username, callbackUrl, share) {
        return this.client.api
            .post(`${ssoPath}/openid`, {
            client_id: this.client.clientId,
            client_secret: this.client.clientSecret,
            username,
            callbackUrl,
            share,
        })
            .then((res) => ({ redirect_url: res.data.redirect_url }));
    }
    loginGithub(callbackUrl, verificationToken, appVersion, type, share) {
        return this.client.api
            .post(`${ssoPath}/github`, {
            callbackUrl,
            verificationToken,
            appVersion,
            type,
            share,
        })
            .then((res) => ({ redirect_url: res.data.redirect_url }));
    }
    loginGoogle(callbackUrl, verificationToken, type, share) {
        return this.client.api
            .post(`${ssoPath}/google`, {
            callbackUrl,
            verificationToken,
            type,
            share,
        })
            .then((res) => ({ redirect_url: res.data.redirect_url }));
    }
    loginAtlassian(callbackUrl, type, share) {
        return this.client.api
            .post(`${ssoPath}/atlassian`, { callbackUrl, type, share })
            .then((res) => ({ redirect_url: res.data.redirect_url }));
    }
    performLogin(token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setToken(token, this.remember);
            yield this.handleExpired(token);
            this.client.logger.info('Logged In');
            if (this.authCallback) {
                yield this.authCallback(AuthCallbackActions.Connected, token, this);
            }
            return token;
        });
    }
    logout() {
        return this.setToken(undefined, undefined);
    }
    register(email, password, recaptcha) {
        return this.client.api.post('auth/register', {
            client_id: this.client.clientId,
            email,
            g_recaptcha_response: recaptcha,
            password_confirmation: password,
            password,
            is_web: true,
        });
    }
    registerSite(email, password, site, recaptcha, type) {
        return this.client.api.post('/system/create_client', {
            name: site,
            development: false,
            g_recaptcha_response: recaptcha,
            is_web: true,
            type,
            user: {
                email,
                password,
                password_confirmation: password,
                g_recaptcha_response: recaptcha,
            },
        });
    }
    signUpWithEmail(data, config) {
        return this.client.api
            .post('/system/sign_up_with_email', data, config)
            .then((res) => this.performLogin(res.data));
    }
    refresh(refreshToken) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.refreshRequest) {
                debug('refresh: in process');
                return yield this.refreshRequest
                    .then(({ data }) => __awaiter(this, void 0, void 0, function* () {
                    debug('refresh: resolved');
                    return data;
                }))
                    .catch((err) => {
                    debug('refresh: error', err);
                    return undefined;
                });
            }
            let token = refreshToken;
            if (!token) {
                if (!(yield this.isLoggedIn())) {
                    // Do not attempt to refresh token as it will fail
                    debug('refresh: not authenticated');
                    return undefined;
                }
                token = (_a = (yield this.getToken())) === null || _a === void 0 ? void 0 : _a.refresh_token;
                if (!token) {
                    yield this.logout();
                    return yield Promise.reject(new exceptions_1.HttpError('No refresh token found.', exceptions_1.NO_REFRESH_TOKEN, 'Token Error', 400, exceptions_1.NO_REFRESH_TOKEN));
                }
            }
            debug('refreshRequest: starting', token);
            this.refreshRequest = this.client.api.request({
                method: 'post',
                url: grantPath,
                data: {
                    grant_type: 'refresh_token',
                    client_id: this.client.clientId,
                    client_secret: this.client.clientSecret,
                    refresh_token: token,
                },
            });
            return yield this.refreshRequest
                .then((response) => __awaiter(this, void 0, void 0, function* () {
                const data = response.data;
                yield this.setToken(data, this.remember);
                yield this.handleExpired(data);
                if (this.authCallback) {
                    yield this.authCallback(AuthCallbackActions.Refreshed, data, this);
                }
                debug('refreshRequest: ok');
                return data;
            }))
                .catch((error) => __awaiter(this, void 0, void 0, function* () {
                var _b;
                yield this.logout();
                debug('refreshRequest error:', (_b = error === null || error === void 0 ? void 0 : error.message) !== null && _b !== void 0 ? _b : error);
                return yield Promise.reject(new exceptions_1.HttpError('Could not refresh token.', exceptions_1.REFRESH_TOKEN_ERROR, 'Refresh Token Error', 400, exceptions_1.REFRESH_TOKEN_ERROR));
            }))
                .finally(() => {
                debug('refreshRequest: finished');
                this.refreshRequest = undefined;
            });
        });
    }
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            let token = yield this.getToken();
            if (token) {
                if (token.expires_at) {
                    const expiresAt = new Date(token.expires_at);
                    const diff = expiresAt.getTime() - new Date().getTime();
                    if (diff < 0) {
                        // token has expired, try to get a token
                        debug('getAccessToken: token expired, refreshing');
                        token = yield this.refresh();
                    }
                }
                return token === null || token === void 0 ? void 0 : token.access_token;
            }
            return undefined;
        });
    }
    checkSubscription() {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure access_token is not expired
            const accessToken = yield this.getAccessToken();
            if (!accessToken) {
                return undefined;
            }
            // Get current token
            const token = yield this.getToken();
            if (!token) {
                return undefined;
            }
            // Override config headers in auth interceptor to prevent deadlock
            const entitlement = yield (0, auth_1.getSubscriptionEntitlement)({
                headers: { Authorization: `Bearer ${accessToken}` },
            });
            if ((token === null || token === void 0 ? void 0 : token.subscription_ends_at) !== (entitlement === null || entitlement === void 0 ? void 0 : entitlement.subscription_ends_at)) {
                debug('checkSubscription: subscription_ends_at has changed');
                return yield this.refresh();
            }
            if ((token === null || token === void 0 ? void 0 : token.trial_ends_at) !== (entitlement === null || entitlement === void 0 ? void 0 : entitlement.trial_ends_at)) {
                debug('checkSubscription: trial_ends_at has changed');
                return yield this.refresh();
            }
            return undefined;
        });
    }
    refreshTokenIfSubscriptionStaled() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.checkSubscriptionRequest) {
                debug('refreshTokenIfSubscriptionStaled: starting');
                this.checkSubscriptionRequest = this.checkSubscription().finally(() => {
                    debug('refreshTokenIfSubscriptionStaled: finished');
                    this.checkSubscriptionRequest = undefined;
                });
                return yield this.checkSubscriptionRequest;
            }
            debug('refreshTokenIfSubscriptionStaled: in process');
            return yield this.checkSubscriptionRequest;
        });
    }
    isLoggedIn() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getToken()) !== undefined;
        });
    }
    getRemember() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.tokenStorage.getRemember();
        });
    }
    getToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.tokenStorage.getToken();
        });
    }
    setToken(token, remember) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('setToken: %j', { token, remember });
            if (token) {
                Auth.validateTokenPayload(token);
            }
            // The backend does not return when the token was created, it only returns
            // when the token will expire. If expires_at does not exist we assume token
            // has been created recently, although as mentioned this is not necessarily
            // true, it is the best guess we can make.
            if ((token === null || token === void 0 ? void 0 : token.expires_in) && !(token === null || token === void 0 ? void 0 : token.expires_at)) {
                const now = new Date();
                now.setSeconds(now.getSeconds() + (token.expires_in - 15)); // subtract 15 seconds to guard against latency
                token.expires_at = JSON.parse(JSON.stringify(now));
            }
            if (this.authCallback) {
                yield this.authCallback(AuthCallbackActions.TokenUpdated, token, this);
            }
            if (this.client.apiWorker) {
                yield this.client.apiWorker.setToken(token);
            }
            return yield this.tokenStorage.setToken(token, remember);
        });
    }
    setPat(pat) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setToken({ access_token: pat });
            return this;
        });
    }
    isExpired(token) {
        var _a;
        return (_a = token === null || token === void 0 ? void 0 : token.is_expired) !== null && _a !== void 0 ? _a : false;
    }
    isSubscriptionExpired(token) {
        if (!token) {
            return false;
        }
        const now = Date.now();
        if (token.subscription_ends_at) {
            return new Date(token.subscription_ends_at).getTime() < now;
        }
        if (token.subscription_ended_at) {
            return new Date(token.subscription_ended_at).getTime() < now;
        }
        return false;
    }
    isTrialExpired(token) {
        if (!token) {
            return false;
        }
        const now = Date.now();
        if (token.trial_ends_at) {
            return new Date(token.trial_ends_at).getTime() < now;
        }
        if (token.trial_ended_at) {
            return new Date(token.trial_ended_at).getTime() < now;
        }
        return false;
    }
    handleExpired(token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.authCallback) {
                return;
            }
            if (!(token === null || token === void 0 ? void 0 : token.is_expired)) {
                return;
            }
            let action = AuthCallbackActions.SubscriptionExpired;
            let time = 0;
            if (token.subscription_ends_at &&
                new Date(token.subscription_ends_at).getTime() > time) {
                time = new Date(token.subscription_ends_at).getTime();
            }
            if (token.subscription_ended_at &&
                new Date(token.subscription_ended_at).getTime() > time) {
                time = new Date(token.subscription_ended_at).getTime();
            }
            if (token.trial_ends_at && new Date(token.trial_ends_at).getTime() > time) {
                time = new Date(token.trial_ends_at).getTime();
                action = AuthCallbackActions.TrialExpired;
            }
            if (token.trial_ended_at &&
                new Date(token.trial_ended_at).getTime() > time) {
                time = new Date(token.trial_ended_at).getTime();
                action = AuthCallbackActions.TrialExpired;
            }
            if (time && time < Date.now()) {
                yield this.authCallback(action, token, this);
            }
        });
    }
    addAuthorizationHeaderInterceptor() {
        this.client.api.interceptors.request.use((config) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const newConfig = Object.assign({}, config);
            if (Auth.urlRequiresAuth(config.url) &&
                newConfig.headers.Authorization === undefined) {
                if (this.checkSubscriptionRequest) {
                    // Wait till check is finished as the token might be refreshed.
                    debug('authorizationHeaderInterceptor: waiting for checkSubscriptionRequest', config.url);
                    yield this.checkSubscriptionRequest;
                    debug('authorizationHeaderInterceptor: resuming', config.url);
                }
                const accessToken = yield this.getAccessToken();
                if (!accessToken) {
                    throw new exceptions_1.HttpError('No access token found.', exceptions_1.NO_ACCESS_TOKEN, 'Token Error', 401, exceptions_1.NO_ACCESS_TOKEN);
                }
                newConfig.headers.Authorization = `Bearer ${accessToken}`;
            }
            if (this.client.debug) {
                newConfig.params = (_a = config.params) !== null && _a !== void 0 ? _a : {};
                newConfig.params.XDEBUG_SESSION_START = 'PHPSTORM';
            }
            return newConfig;
        }), (error) => {
            this.client.logger.error('Request error', error);
            return Promise.reject(error);
        });
    }
    // Axios interceptor for HTTP 401 Unauthorized
    // If the token is invalid or has expired, we regenerate a new token and then call the original REST again.
    addUnauthorizedInterceptor() {
        this.client.api.interceptors.response.use((response) => response, (error) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            // if error response is not HTTP 401, we do a reject to not process this error
            const status = ((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status)
                ? typeof error.response.status === 'string'
                    ? parseInt(error.response.status, 10)
                    : error.response.status
                : undefined;
            const isRetry = Boolean((_c = (_b = error.response) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c._retry);
            debug('unauthorizedInterceptor', {
                error: (_d = error === null || error === void 0 ? void 0 : error.message) !== null && _d !== void 0 ? _d : error,
                id: this.id,
                isAuthCallbackSet: !!this.authCallback,
                isDisabled: this.disableHandler,
                isRetry,
                status,
                url: (_e = error.config) === null || _e === void 0 ? void 0 : _e.url,
                urlRequiresAuth: Auth.urlRequiresAuth((_f = error.config) === null || _f === void 0 ? void 0 : _f.url),
            });
            // if not an authentication issue just let error flow through
            if (this.disableHandler ||
                isRetry ||
                status !== 401 ||
                !Auth.urlRequiresAuth((_g = error.config) === null || _g === void 0 ? void 0 : _g.url)) {
                if ((_h = error.response) === null || _h === void 0 ? void 0 : _h.data) {
                    return yield Promise.reject((0, exceptions_1.getHttpResponse)(error.response));
                }
                return yield Promise.reject(error);
            }
            const accessToken = yield this.getToken();
            if (!accessToken) {
                if (this.authCallback) {
                    debug('unauthorizedInterceptor: authCallback due to empty token');
                    yield this.authCallback(AuthCallbackActions.Unauthorized, undefined, this);
                }
                return yield Promise.reject((0, exceptions_1.getHttpResponse)(error.response));
            }
            // When response code is HTTP 401 Unauthorized, try to refresh the token.
            // Don't handle again so it doesn't loop in case token refresh causes
            // the 401 response.
            this.disableHandler = true;
            let authCallbackAlreadyInvoked = false;
            try {
                // use refresh token to generate new access token so request can be retried
                const token = yield this.refresh();
                if (token === null || token === void 0 ? void 0 : token.access_token) {
                    error.response.config.headers.Authorization = `Bearer ${token.access_token}`;
                    error.response.config._retry = true;
                    return yield this.client.api(error.response.config);
                }
                if (this.authCallback) {
                    debug('unauthorizedInterceptor: authCallback due to empty token after refresh');
                    authCallbackAlreadyInvoked = true;
                    yield this.authCallback(AuthCallbackActions.Unauthorized, undefined, this);
                }
                return yield Promise.reject((0, exceptions_1.getHttpResponse)(error.response));
            }
            catch (e) {
                // Add url that required authentication the error
                if (!e.url) {
                    e.url = (_j = error.config) === null || _j === void 0 ? void 0 : _j.url;
                }
                if (this.authCallback && !authCallbackAlreadyInvoked) {
                    debug('unauthorizedInterceptor: authCallback due to error', (_k = e === null || e === void 0 ? void 0 : e.message) !== null && _k !== void 0 ? _k : e);
                    yield this.authCallback(AuthCallbackActions.Unauthorized, undefined, this);
                }
                return yield Promise.reject(e);
            }
            finally {
                this.disableHandler = false;
            }
        }));
    }
    addInterceptors() {
        this.addAuthorizationHeaderInterceptor();
        this.addUnauthorizedInterceptor();
    }
}
exports.Auth = Auth;
//# sourceMappingURL=Auth.js.map
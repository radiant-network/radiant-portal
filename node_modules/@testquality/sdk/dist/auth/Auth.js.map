{"version":3,"file":"Auth.js","sourceRoot":"","sources":["../../src/auth/Auth.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  type InternalAxiosRequestConfig,\n  type AxiosResponse,\n  type AxiosRequestConfig,\n} from 'axios';\nimport Debug from 'debug';\nimport {\n  AUTH,\n  GeneralError,\n  getHttpResponse,\n  HttpError,\n  NO_ACCESS_TOKEN,\n  NO_REFRESH_TOKEN,\n  REFRESH_TOKEN_ERROR,\n  TOKEN,\n  VERIFICATION,\n} from '../exceptions';\nimport { type ClientSdk } from '../ClientSdk';\nimport { getSubscriptionEntitlement } from '../services/auth';\nimport { type TokenStorage } from '../TokenStorage';\nimport { type ReturnToken } from './ReturnToken';\n\nconst debug = Debug('tq:sdk:Auth');\n\n/**\n * Copyright (C) 2021 BitModern, Inc - All Rights Reserved\n */\n\nconst grantPath = '/oauth/access_token';\nconst ssoPath = '/sso';\n\nconst doesNotRequireAuth: string[] = [\n  'auth/login',\n  'auth/register',\n  'email-verification/check',\n  'email-verification/error',\n  'oauth/access_token',\n  'system/auth/begin_password_reset',\n  'system/auth/complete_invite_user',\n  'system/auth/complete_password_reset',\n  'system/create_client',\n  'system/github/authorize',\n  'system/sign_up_with_email',\n  'system/validate_site_name',\n  'system/auth/complete_share_invite',\n  'system/auth/complete_magic_share_invite',\n];\n\nexport enum AuthCallbackActions {\n  Connected = 1,\n  Refreshed,\n  Unauthorized,\n  SubscriptionExpired,\n  TrialExpired,\n  TokenUpdated,\n}\n\nexport type AuthCallback = (\n  action: AuthCallbackActions,\n  token?: ReturnToken,\n  me?: Auth,\n) => Promise<void>;\n\nexport interface SignUpWithEmailData {\n  email: string;\n  password: string;\n  recaptcha: string;\n  type?: number;\n}\n\nexport class Auth {\n  public static validateTokenPayload(token: any) {\n    debug('validateTokenPayload: %j', token);\n    if (token?.error) {\n      throw new GeneralError(token.error, TOKEN);\n    } else if (token?.message) {\n      throw new GeneralError(token.message, TOKEN);\n    } else if (token?.verification_ended_at) {\n      // if verification ended then we don't have a token\n      throw new GeneralError(\n        'Email verification is required to login',\n        VERIFICATION,\n      );\n    } else if (!token?.access_token) {\n      throw new GeneralError('Auth failed', AUTH);\n    }\n    debug('validateTokenPayload: ok');\n  }\n\n  public static urlRequiresAuth(url?: string) {\n    if (!url) return false;\n    for (let i = 0; i < doesNotRequireAuth.length; i += 1) {\n      if (url.match(new RegExp(doesNotRequireAuth[i]))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private checkSubscriptionRequest?: Promise<ReturnToken | undefined>;\n  private disableHandler = false;\n  public id = Math.random();\n  private refreshRequest?: Promise<AxiosResponse<ReturnToken>>;\n  private remember = true;\n\n  constructor(\n    private readonly tokenStorage: TokenStorage,\n    private readonly client: ClientSdk,\n    private authCallback?: AuthCallback,\n  ) {\n    this.setAuthCallback(authCallback);\n    this.addInterceptors();\n  }\n\n  public setAuthCallback(authCallback?: AuthCallback): void {\n    this.authCallback = authCallback;\n    if (this.client.apiWorker) {\n      this.client.apiWorker.setAuthCallback(\n        async (action: AuthCallbackActions, token?: ReturnToken) => {\n          if (action === AuthCallbackActions.TokenUpdated) {\n            debug('token updated in apiWorker');\n            await this.tokenStorage.setToken(token);\n          }\n          if (this.authCallback) {\n            await this.authCallback(action, token);\n          }\n        },\n      );\n    }\n  }\n\n  public passwordRecovery(email: string) {\n    return this.client.api.get(`/system/auth/begin_password_reset/${email}`, {\n      params: {\n        is_web: true,\n      },\n    });\n  }\n\n  public passwordReset(email: string, password: string, token: string) {\n    return this.client.api.post<ReturnToken>(\n      '/system/auth/complete_password_reset',\n      {\n        email,\n        password,\n        token,\n      },\n    );\n  }\n\n  public login(\n    username: string,\n    password: string,\n    remember = false,\n    share?: string,\n    properties?: any,\n  ): Promise<ReturnToken> {\n    this.remember = remember;\n    return this.client.api\n      .post<ReturnToken>(grantPath, {\n        grant_type: 'password',\n        client_id: this.client.clientId,\n        client_secret: this.client.clientSecret,\n        username,\n        password,\n        share,\n        ...properties,\n      })\n      .then((res) => this.performLogin(res.data));\n  }\n\n  public loginSSO(\n    username: string,\n    callbackUrl: string,\n    share?: string,\n  ): Promise<{ redirect_url: string }> {\n    return this.client.api\n      .post(`${ssoPath}/openid`, {\n        client_id: this.client.clientId,\n        client_secret: this.client.clientSecret,\n        username,\n        callbackUrl,\n        share,\n      })\n      .then((res) => ({ redirect_url: res.data.redirect_url }));\n  }\n\n  public loginGithub(\n    callbackUrl: string,\n    verificationToken?: string,\n    appVersion?: number,\n    type?: number,\n    share?: string,\n  ): Promise<{ redirect_url: string }> {\n    return this.client.api\n      .post(`${ssoPath}/github`, {\n        callbackUrl,\n        verificationToken,\n        appVersion,\n        type,\n        share,\n      })\n      .then((res) => ({ redirect_url: res.data.redirect_url }));\n  }\n\n  public loginGoogle(\n    callbackUrl: string,\n    verificationToken?: string,\n    type?: number,\n    share?: string,\n  ): Promise<{ redirect_url: string }> {\n    return this.client.api\n      .post(`${ssoPath}/google`, {\n        callbackUrl,\n        verificationToken,\n        type,\n        share,\n      })\n      .then((res) => ({ redirect_url: res.data.redirect_url }));\n  }\n\n  public loginAtlassian(\n    callbackUrl: string,\n    type?: number,\n    share?: string,\n  ): Promise<{ redirect_url: string }> {\n    return this.client.api\n      .post(`${ssoPath}/atlassian`, { callbackUrl, type, share })\n      .then((res) => ({ redirect_url: res.data.redirect_url }));\n  }\n\n  public async performLogin(token: ReturnToken): Promise<ReturnToken> {\n    await this.setToken(token, this.remember);\n    await this.handleExpired(token);\n    this.client.logger.info('Logged In');\n    if (this.authCallback) {\n      await this.authCallback(AuthCallbackActions.Connected, token, this);\n    }\n    return token;\n  }\n\n  public logout(): Promise<ReturnToken | undefined> {\n    return this.setToken(undefined, undefined);\n  }\n\n  public register(email: string, password: string, recaptcha: string) {\n    return this.client.api.post<ReturnToken>('auth/register', {\n      client_id: this.client.clientId,\n      email,\n      g_recaptcha_response: recaptcha,\n      password_confirmation: password,\n      password,\n      is_web: true,\n    });\n  }\n\n  public registerSite(\n    email: string,\n    password: string,\n    site: string,\n    recaptcha: string,\n    type?: number,\n  ) {\n    return this.client.api.post('/system/create_client', {\n      name: site,\n      development: false,\n      g_recaptcha_response: recaptcha,\n      is_web: true,\n      type,\n      user: {\n        email,\n        password,\n        password_confirmation: password,\n        g_recaptcha_response: recaptcha,\n      },\n    });\n  }\n\n  public signUpWithEmail(\n    data: SignUpWithEmailData,\n    config?: AxiosRequestConfig<SignUpWithEmailData>,\n  ): Promise<ReturnToken> {\n    return this.client.api\n      .post('/system/sign_up_with_email', data, config)\n      .then((res) => this.performLogin(res.data));\n  }\n\n  public async refresh(\n    refreshToken?: string,\n  ): Promise<ReturnToken | undefined> {\n    if (this.refreshRequest) {\n      debug('refresh: in process');\n      return await this.refreshRequest\n        .then(async ({ data }) => {\n          debug('refresh: resolved');\n          return data;\n        })\n        .catch((err) => {\n          debug('refresh: error', err);\n          return undefined;\n        });\n    }\n\n    let token = refreshToken;\n    if (!token) {\n      if (!(await this.isLoggedIn())) {\n        // Do not attempt to refresh token as it will fail\n        debug('refresh: not authenticated');\n        return undefined;\n      }\n      token = (await this.getToken())?.refresh_token;\n      if (!token) {\n        await this.logout();\n        return await Promise.reject(\n          new HttpError(\n            'No refresh token found.',\n            NO_REFRESH_TOKEN,\n            'Token Error',\n            400,\n            NO_REFRESH_TOKEN,\n          ),\n        );\n      }\n    }\n\n    debug('refreshRequest: starting', token);\n    this.refreshRequest = this.client.api.request<ReturnToken>({\n      method: 'post',\n      url: grantPath,\n      data: {\n        grant_type: 'refresh_token',\n        client_id: this.client.clientId,\n        client_secret: this.client.clientSecret,\n        refresh_token: token,\n      },\n    });\n    return await this.refreshRequest\n      .then(async (response) => {\n        const data = response.data;\n        await this.setToken(data, this.remember);\n        await this.handleExpired(data);\n        if (this.authCallback) {\n          await this.authCallback(AuthCallbackActions.Refreshed, data, this);\n        }\n        debug('refreshRequest: ok');\n        return data;\n      })\n      .catch(async (error: any) => {\n        await this.logout();\n        debug('refreshRequest error:', error?.message ?? error);\n        return await Promise.reject(\n          new HttpError(\n            'Could not refresh token.',\n            REFRESH_TOKEN_ERROR,\n            'Refresh Token Error',\n            400,\n            REFRESH_TOKEN_ERROR,\n          ),\n        );\n      })\n      .finally(() => {\n        debug('refreshRequest: finished');\n        this.refreshRequest = undefined;\n      });\n  }\n\n  public async getAccessToken(): Promise<string | undefined> {\n    let token = await this.getToken();\n    if (token) {\n      if (token.expires_at) {\n        const expiresAt: Date = new Date(token.expires_at);\n        const diff = expiresAt.getTime() - new Date().getTime();\n\n        if (diff < 0) {\n          // token has expired, try to get a token\n          debug('getAccessToken: token expired, refreshing');\n          token = await this.refresh();\n        }\n      }\n      return token?.access_token;\n    }\n    return undefined;\n  }\n\n  private async checkSubscription(): Promise<ReturnToken | undefined> {\n    // Ensure access_token is not expired\n    const accessToken = await this.getAccessToken();\n    if (!accessToken) {\n      return undefined;\n    }\n\n    // Get current token\n    const token = await this.getToken();\n    if (!token) {\n      return undefined;\n    }\n\n    // Override config headers in auth interceptor to prevent deadlock\n    const entitlement = await getSubscriptionEntitlement({\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n\n    if (token?.subscription_ends_at !== entitlement?.subscription_ends_at) {\n      debug('checkSubscription: subscription_ends_at has changed');\n      return await this.refresh();\n    }\n\n    if (token?.trial_ends_at !== entitlement?.trial_ends_at) {\n      debug('checkSubscription: trial_ends_at has changed');\n      return await this.refresh();\n    }\n\n    return undefined;\n  }\n\n  public async refreshTokenIfSubscriptionStaled(): Promise<\n    ReturnToken | undefined\n  > {\n    if (!this.checkSubscriptionRequest) {\n      debug('refreshTokenIfSubscriptionStaled: starting');\n      this.checkSubscriptionRequest = this.checkSubscription().finally(() => {\n        debug('refreshTokenIfSubscriptionStaled: finished');\n        this.checkSubscriptionRequest = undefined;\n      });\n      return await this.checkSubscriptionRequest;\n    }\n\n    debug('refreshTokenIfSubscriptionStaled: in process');\n    return await this.checkSubscriptionRequest;\n  }\n\n  public async isLoggedIn(): Promise<boolean> {\n    return (await this.getToken()) !== undefined;\n  }\n\n  public async getRemember(): Promise<boolean | undefined> {\n    return await this.tokenStorage.getRemember();\n  }\n\n  public async getToken(): Promise<ReturnToken | undefined> {\n    return await this.tokenStorage.getToken();\n  }\n\n  public async setToken(\n    token?: ReturnToken,\n    remember?: boolean,\n  ): Promise<ReturnToken | undefined> {\n    debug('setToken: %j', { token, remember });\n    if (token) {\n      Auth.validateTokenPayload(token);\n    }\n    // The backend does not return when the token was created, it only returns\n    // when the token will expire. If expires_at does not exist we assume token\n    // has been created recently, although as mentioned this is not necessarily\n    // true, it is the best guess we can make.\n    if (token?.expires_in && !token?.expires_at) {\n      const now = new Date();\n      now.setSeconds(now.getSeconds() + (token.expires_in - 15)); // subtract 15 seconds to guard against latency\n      token.expires_at = JSON.parse(JSON.stringify(now));\n    }\n    if (this.authCallback) {\n      await this.authCallback(AuthCallbackActions.TokenUpdated, token, this);\n    }\n    if (this.client.apiWorker) {\n      await this.client.apiWorker.setToken(token);\n    }\n    return await this.tokenStorage.setToken(token, remember);\n  }\n\n  public async setPat(pat: string): Promise<this> {\n    await this.setToken({ access_token: pat } as any);\n    return this;\n  }\n\n  public isExpired(token?: ReturnToken): boolean {\n    return token?.is_expired ?? false;\n  }\n\n  public isSubscriptionExpired(token?: ReturnToken): boolean {\n    if (!token) {\n      return false;\n    }\n    const now = Date.now();\n    if (token.subscription_ends_at) {\n      return new Date(token.subscription_ends_at).getTime() < now;\n    }\n    if (token.subscription_ended_at) {\n      return new Date(token.subscription_ended_at).getTime() < now;\n    }\n    return false;\n  }\n\n  public isTrialExpired(token?: ReturnToken): boolean {\n    if (!token) {\n      return false;\n    }\n    const now = Date.now();\n    if (token.trial_ends_at) {\n      return new Date(token.trial_ends_at).getTime() < now;\n    }\n    if (token.trial_ended_at) {\n      return new Date(token.trial_ended_at).getTime() < now;\n    }\n    return false;\n  }\n\n  protected async handleExpired(token?: ReturnToken): Promise<undefined> {\n    if (!this.authCallback) {\n      return;\n    }\n    if (!token?.is_expired) {\n      return;\n    }\n\n    let action = AuthCallbackActions.SubscriptionExpired;\n    let time = 0;\n\n    if (\n      token.subscription_ends_at &&\n      new Date(token.subscription_ends_at).getTime() > time\n    ) {\n      time = new Date(token.subscription_ends_at).getTime();\n    }\n    if (\n      token.subscription_ended_at &&\n      new Date(token.subscription_ended_at).getTime() > time\n    ) {\n      time = new Date(token.subscription_ended_at).getTime();\n    }\n    if (token.trial_ends_at && new Date(token.trial_ends_at).getTime() > time) {\n      time = new Date(token.trial_ends_at).getTime();\n      action = AuthCallbackActions.TrialExpired;\n    }\n    if (\n      token.trial_ended_at &&\n      new Date(token.trial_ended_at).getTime() > time\n    ) {\n      time = new Date(token.trial_ended_at).getTime();\n      action = AuthCallbackActions.TrialExpired;\n    }\n\n    if (time && time < Date.now()) {\n      await this.authCallback(action, token, this);\n    }\n  }\n\n  protected addAuthorizationHeaderInterceptor() {\n    this.client.api.interceptors.request.use(\n      async (config): Promise<InternalAxiosRequestConfig> => {\n        const newConfig = { ...config };\n        if (\n          Auth.urlRequiresAuth(config.url) &&\n          newConfig.headers.Authorization === undefined\n        ) {\n          if (this.checkSubscriptionRequest) {\n            // Wait till check is finished as the token might be refreshed.\n            debug(\n              'authorizationHeaderInterceptor: waiting for checkSubscriptionRequest',\n              config.url,\n            );\n            await this.checkSubscriptionRequest;\n            debug('authorizationHeaderInterceptor: resuming', config.url);\n          }\n          const accessToken = await this.getAccessToken();\n          if (!accessToken) {\n            throw new HttpError(\n              'No access token found.',\n              NO_ACCESS_TOKEN,\n              'Token Error',\n              401,\n              NO_ACCESS_TOKEN,\n            );\n          }\n          newConfig.headers.Authorization = `Bearer ${accessToken}`;\n        }\n        if (this.client.debug) {\n          newConfig.params = config.params ?? {};\n          newConfig.params.XDEBUG_SESSION_START = 'PHPSTORM';\n        }\n        return newConfig;\n      },\n      (error: any) => {\n        this.client.logger.error('Request error', error);\n        return Promise.reject(error);\n      },\n    );\n  }\n\n  // Axios interceptor for HTTP 401 Unauthorized\n  // If the token is invalid or has expired, we regenerate a new token and then call the original REST again.\n  protected addUnauthorizedInterceptor() {\n    this.client.api.interceptors.response.use(\n      (response) => response,\n      async (error: any) => {\n        // if error response is not HTTP 401, we do a reject to not process this error\n        const status = error?.response?.status\n          ? typeof error.response.status === 'string'\n            ? parseInt(error.response.status, 10)\n            : error.response.status\n          : undefined;\n\n        const isRetry = Boolean(error.response?.config?._retry);\n\n        debug('unauthorizedInterceptor', {\n          error: error?.message ?? error,\n          id: this.id,\n          isAuthCallbackSet: !!this.authCallback,\n          isDisabled: this.disableHandler,\n          isRetry,\n          status,\n          url: error.config?.url,\n          urlRequiresAuth: Auth.urlRequiresAuth(error.config?.url),\n        });\n\n        // if not an authentication issue just let error flow through\n        if (\n          this.disableHandler ||\n          isRetry ||\n          status !== 401 ||\n          !Auth.urlRequiresAuth(error.config?.url)\n        ) {\n          if (error.response?.data) {\n            return await Promise.reject(getHttpResponse(error.response));\n          }\n          return await Promise.reject(error);\n        }\n\n        const accessToken = await this.getToken();\n        if (!accessToken) {\n          if (this.authCallback) {\n            debug('unauthorizedInterceptor: authCallback due to empty token');\n            await this.authCallback(\n              AuthCallbackActions.Unauthorized,\n              undefined,\n              this,\n            );\n          }\n          return await Promise.reject(getHttpResponse(error.response));\n        }\n\n        // When response code is HTTP 401 Unauthorized, try to refresh the token.\n        // Don't handle again so it doesn't loop in case token refresh causes\n        // the 401 response.\n        this.disableHandler = true;\n\n        let authCallbackAlreadyInvoked = false;\n        try {\n          // use refresh token to generate new access token so request can be retried\n          const token = await this.refresh();\n          if (token?.access_token) {\n            error.response.config.headers.Authorization = `Bearer ${token.access_token}`;\n            error.response.config._retry = true;\n            return await this.client.api(error.response.config);\n          }\n          if (this.authCallback) {\n            debug(\n              'unauthorizedInterceptor: authCallback due to empty token after refresh',\n            );\n            authCallbackAlreadyInvoked = true;\n            await this.authCallback(\n              AuthCallbackActions.Unauthorized,\n              undefined,\n              this,\n            );\n          }\n          return await Promise.reject(getHttpResponse(error.response));\n        } catch (e: any) {\n          // Add url that required authentication the error\n          if (!e.url) {\n            e.url = error.config?.url;\n          }\n          if (this.authCallback && !authCallbackAlreadyInvoked) {\n            debug(\n              'unauthorizedInterceptor: authCallback due to error',\n              e?.message ?? e,\n            );\n            await this.authCallback(\n              AuthCallbackActions.Unauthorized,\n              undefined,\n              this,\n            );\n          }\n          return await Promise.reject(e);\n        } finally {\n          this.disableHandler = false;\n        }\n      },\n    );\n  }\n\n  protected addInterceptors(): void {\n    this.addAuthorizationHeaderInterceptor();\n    this.addUnauthorizedInterceptor();\n  }\n}\n"]}